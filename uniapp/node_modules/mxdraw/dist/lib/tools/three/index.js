export function setGeometrPostion(e,t){for(let n=0;n<e.vertices.length;n++)e.vertices[n].x+=t.x,e.vertices[n].y+=t.y,e.vertices[n].z+=t.z};export function repairGeometryFaceVertexUvs(e){e.computeBoundingBox();const t=e.boundingBox.min,n=e.boundingBox.max,o=new THREE.Vector2(0-t.x,0-t.y),r=new THREE.Vector2(n.x-t.x,n.y-t.y);e.faceVertexUvs[0]=[];const c=e.faces;for(let t=0;t<c.length;t++){const n=c[t],a=e.vertices[n.a],l=e.vertices[n.b],i=e.vertices[n.c];e.faceVertexUvs[0].push([new THREE.Vector2((a.x+o.x)/r.x,(a.y+o.y)/r.y),new THREE.Vector2((l.x+o.x)/r.x,(l.y+o.y)/r.y),new THREE.Vector2((i.x+o.x)/r.x,(i.y+o.y)/r.y)])}return e.uvsNeedUpdate=!0,e};export function getToGenerateRoundedCorners(e,t,n=!0){if(t.length>0){const o=new THREE.CurvePath;n||e.push(e[0]);for(let r=0;r<e.length-1;r++){const c=t[r]||0;if(0===r&&!n){const t=e[0].clone().sub(e[1]);t.normalize();const n=e[1].clone();n.add(t.clone().multiplyScalar(c));const r=new THREE.LineCurve3(e[0],n);o.curves.push(r);continue}const a=!n||e[r-1]?e[r-1].clone().sub(e[r]):e[e.length-1].clone().sub(e[0]);a.normalize();const l=!n||e[r+1]?e[r+1].clone().sub(e[r]):e[1].clone().sub(e[0]);l.normalize(),e[r].clone().add(a.clone().multiplyScalar(c));const i=e[r].clone().add(a.clone().multiplyScalar(c)),s=e[r].clone(),E=e[r].clone().add(l.clone().multiplyScalar(c)),u=new THREE.QuadraticBezierCurve3(i,s,E);if(r===e.length-2){const t=e[r].clone();t.add(l.clone().multiplyScalar(c));const a=e[r+1].clone();n?a.add(l.clone().multiplyScalar(-c)):a.add(l.clone());const i=new THREE.LineCurve3(t,a);o.curves.push(u,i)}else o.curves.push(u);0===r&&e.push(e[0])}return o.getPoints(50)}return e};export function computeRectPoints(e,t){return[e,e.clone().set(t.x,e.y,t.z),t,t.clone().set(e.x,t.y,e.z)]};export function calculateArcOrigin(e,t,n){const o=e.x,r=t.x,c=n.x,a=e.y,l=t.y,i=n.y,s=o-r,E=a-l,u=o-c,x=a-i,T=(o*o-r*r+(a*a-l*l))/2,g=(o*o-c*c+(a*a-i*i))/2,R=E*u-s*x,y=-(x*T-E*g)/R,d=-(s*g-u*T)/R;return new THREE.Vector3(y,d,0)};export function calculateRadiusArc(e,t){const n=e.x,o=e.y,r=t.x,c=t.y;return Math.sqrt((n-r)*(n-r)+(o-c)*(o-c))};export function calculateArcAngle(e,t,n){const o=e.x,r=t.x;let c,a,l;return c=(e.y-t.y)/n,(a=(o-r)/n)>=.99999&&(a=.99999),a<=-.99999&&(a=-.99999),l=(l=Math.acos(a))/Math.PI*180,c<-.05&&(l=360-l),{sin:c,cos:a,angle:l}};export function judgementArcRenderDirection(e,t,n){let o,r;return o=e<n?n-e:n-e+360,(r=e<t?t-e:t-e+360)>o};export function createThreePointArc(e,t,n,o=!1,r=!1,c=new THREE.Color("#ff0000")){const a=calculateArcOrigin(e,t,n),l=a.x,i=a.y,s=calculateRadiusArc(e,a),E=calculateArcAngle(e,a,s),u=calculateArcAngle(t,a,s),x=calculateArcAngle(n,a,s);let T,g,R=E.angle,y=u.angle,d=x.angle,h=judgementArcRenderDirection(R,y,d);r&&(h=!0),o?(g=new THREE.ArcCurve(l,i,s,THREE.MathUtils.degToRad(R),THREE.MathUtils.degToRad(y),!h),T=h?y>R?THREE.MathUtils.radToDeg(g.aEndAngle-g.aStartAngle):360-Math.abs(THREE.MathUtils.radToDeg(g.aEndAngle-g.aStartAngle)):R>y?Math.abs(THREE.MathUtils.radToDeg(g.aEndAngle-g.aStartAngle)):360-THREE.MathUtils.radToDeg(g.aEndAngle-g.aStartAngle)):(g=new THREE.ArcCurve(l,i,s,THREE.MathUtils.degToRad(R),THREE.MathUtils.degToRad(d),h),T=h?d>R?360-THREE.MathUtils.radToDeg(g.aEndAngle-g.aStartAngle):Math.abs(THREE.MathUtils.radToDeg(g.aEndAngle-g.aStartAngle)):R>d?360+THREE.MathUtils.radToDeg(g.aEndAngle-g.aStartAngle):THREE.MathUtils.radToDeg(g.aEndAngle-g.aStartAngle));const H=T*Math.PI*s/180,p=(new THREE.BufferGeometry).setFromPoints(g.getPoints(50)),f=new THREE.LineBasicMaterial({color:c});return{arc:new THREE.Line(p,f),radius:s,angle:T,arcLength:H}};export function createAnyLine(e){const t=new THREE.CatmullRomCurve3(e,!1,"chordal");e=t.getPoints(50);const n=new THREE.BufferGeometry,o=Math.round(12*e.length);let r=new THREE.Vector3;const c=[],a=[],l=new THREE.Color("#ff0000");for(let e=0,n=o;e<n;e++){const o=e/n;r=t.getPoint(o),c.push(r.x,r.y,r.z),a.push(l.r,l.g,l.b)}n.setAttribute("position",new THREE.Float32BufferAttribute(c,3)),n.setAttribute("color",new THREE.Float32BufferAttribute(a,3));const i=new THREE.LineBasicMaterial({vertexColors:THREE.VertexColors,linewidth:10}),s=new THREE.Line(n,i);return s.computeLineDistances(),s};export function createThreeEllipse(e,t,n){const o=e.clone().set(t.x,e.y,t.z),r=t.clone().set(e.x,t.y,e.z),c=e.distanceTo(o)/2,a=e.distanceTo(r)/2,l=e.x>t.x,i=e.y>t.y,s=new THREE.EllipseCurve(l?e.x-c:e.x+c,i?e.y-a:e.y+a,-c,-a,0,2*Math.PI,!1,0).getPoints(50),E=(new THREE.Geometry).setFromPoints(s),u=new THREE.LineBasicMaterial({color:n});return new THREE.Line(E,u)};export function computeRegularPolygonVertices(e=new THREE.Vector3,t=new THREE.Vector3,n=3){const o=[];n=Math.max(3,n),o.push(t);const r=2*Math.PI/n;for(let c=1;c<n;c++){const n=Math.cos(r*c),a=Math.sin(r*c),l=e.clone(),i=t.clone(),s=i.x-l.x,E=i.y-l.y,u=new THREE.Vector3(s*n-E*a+l.x,s*a+E*n+l.y);o.push(u)}return o};export function createThreeRegularPolygon(e,t,n,o){const r=new THREE.Geometry;r.vertices=computeRegularPolygonVertices(e,t,n);const c=new THREE.LineBasicMaterial({color:o});return new THREE.LineLoop(r,c)};export function computeBounding(e){if(0==e.length){let e=new THREE.Vector3;return{centerPoint:e,minPoint:e,maxPoint:e}}{let t=new THREE.Vector3(e[0].x,e[0].y,e[0].z||0),n=new THREE.Vector3(e[0].x,e[0].y,e[0].z||0),o=e.length;for(let r=1;r<o;r++){let o=e[r];t.x>o.x&&(t.x=o.x),t.y>o.y&&(t.y=o.y),n.x<o.x&&(n.x=o.x),n.y<o.y&&(n.y=o.y)}return{centerPoint:new THREE.Vector3(t.x+.5*(n.x-t.x),t.y+.5*(n.y-t.y),0),minPoint:t,maxPoint:n}}};