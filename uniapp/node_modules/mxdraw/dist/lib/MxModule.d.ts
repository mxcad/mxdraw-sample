import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';
import * as three from 'three';
import { Color } from 'three';

/**
 * 加载MxDraw库的核心代码 才能使用Mx的其他模块
 * @returns Promise<{@link MxFun}>
 * @example
 * ```
 * Mx.loadCoreCode().then(()=> console.log("加载完成", Mx.MxFun))
 * ```
 */
declare function loadCoreCode(): Promise<void>;

/** @module MxCADObject */
interface MxCADLayerTableRecord {
    id: number;
    name: string;
    color: number;
    off: boolean;
}
/**
 * MxCAD 对象，用来实现在线编辑功能
 *
 */
declare class MxCADObject {
    private _mxCAD;
    constructor(mxCAD: any);
    /**
     * 新建一个图纸
     * @example
     * ```typescript
     *
     * ```
     */
    newFile(): void;
    /** 撤销操作 */
    undo(): void;
    /**
     * 打开个CAD文件
     * @example
     * ```typescript
     *
     * ```
     */
    openFile(file: string, retfun?: (ret: Object) => void): void;
    /**
     * 保存CAD文件
     * 文件保存路径，在bin/release/ini.json, 中server.savepath设置。默认保存到，bin/release/public/save目录下。
     * @example
     * ```typescript
     *
     * ```
     */
    saveFile(file: string, retfun: (ret: Object) => void): void;
    /**
     * 从服务器上得到显示数据
     * @example
     * ```typescript
     *
     * ```
     */
    getDisplayFromServer(): void;
    /**
     * 获取打开的文件名称
     * @param file 文件路径
     * @param retfun 保存文件后的回调函数
     *
     * */
    getFileName(): string;
    /**
     * 获取全部图层数据
     * @retruns 全部图层数据
     *
     * */
    getAllLayerData(): MxCADLayerTableRecord[];
}

/** @module McGiWorldDrawType*/
/**
 * 动态绘制类型
 * @example ```typescript

 * ```
 */
declare enum McGiWorldDrawType {
    /** 正常绘制 */
    kWorldDraw = 1,
    /** 动态拖动的绘制 */
    kDynDragDraw = 2,
    /** 对选择高亮的绘制 */
    kSelectDraw = 3
}

/**
 * 动态绘制类型
 * @example ```typescript

 * ```
 */
declare enum MxCloneType {
    /** 正常Clone */
    kClone = 1,
    /** 动态拖动Clone */
    kDragClone = 2,
    /** 数据归档 */
    kMxFileClone = 3,
    /** 保存数据到DWG文件 */
    kSaveDwgClone = 4
}
/**
 * 控件对象缺省的绘制顺序
 * @example ```typescript

 * ```
 */
declare enum MxDefaultRenderOrder {
    kCADMeshRenderOrder = 10,
    kCADCurveRenderOrder = 20,
    kMxEntityRenderOrder = 30,
    kGripRenderOrder = 110,
    kDynJigRenderOrder = 120
}
/**
 * 交互操作，需要的输入的触摸类型.
 * @example ```typescript
 * ```
 */
declare enum InputToucheType {
    kGetBegan = 1,
    kGetEnd = 2
}
declare type MxColorType = number | string | THREE.Color;
declare type UnstableColor = MxColorType | undefined;

type MxType_MxCloneType = MxCloneType;
declare const MxType_MxCloneType: typeof MxCloneType;
type MxType_MxDefaultRenderOrder = MxDefaultRenderOrder;
declare const MxType_MxDefaultRenderOrder: typeof MxDefaultRenderOrder;
type MxType_InputToucheType = InputToucheType;
declare const MxType_InputToucheType: typeof InputToucheType;
type MxType_MxColorType = MxColorType;
type MxType_UnstableColor = UnstableColor;
declare namespace MxType {
  export {
    MxType_MxCloneType as MxCloneType,
    MxType_MxDefaultRenderOrder as MxDefaultRenderOrder,
    MxType_InputToucheType as InputToucheType,
    MxType_MxColorType as MxColorType,
    MxType_UnstableColor as UnstableColor,
  };
}

/** @module McGiWorldDraw*/

/**
 * McGiWorldDraw 用于构建一个动态绘制回调对象的规范接口
 * @abstract 是  {@link MxDbEntity.worldDraw }必须实现的抽象回调方法中的回调对象 通过回调对象完成一些动态绘制任务
 * @example ```typescript
 *
 * ```
 */
interface McGiWorldDraw {
    /**
     * 得到WorldDraw的绘制类型.
     * @returns McGiWorldDrawType
     * @example
     * ``` typescript
     *
     * ```
     *
     */
    getType(): McGiWorldDrawType;
    /**
     * 绘制一个Three.js对象
     * @param ent Three.js对象
     * @returns void
     * @example
     * ``` typescript
     *
     * ```
     *
     */
    drawEntity(ent: THREE.Object3D): void;
    /**
     * 返回动态绘制的控件对像
     * @returns MxDrawObject
     * @example
     * ``` typescript
     *
     * ```
     *
     */
    getMxObject(): MxDrawObject;
    /**
     * 设置绘制颜色
     * @param iColor 颜色值
     * @returns
     * @example
     * ``` typescript
     *
     * ```
     *
     */
    setColor(iColor: UnstableColor): void;
    /**
     * 返回绘制颜色
     * @returns
     * @example
     * ``` typescript
     *
     * ```
     *
     */
    getColor(): number;
    /**
     * 设置绘制的线宽
     * @returns
     * @example
     * ``` typescript
     *
     * ```
     *
     */
    setLineWidth(iLineWidth: number): void;
    /**
     * 返回绘制的线宽
     * @returns
     * @example
     * ``` typescript
     *
     * ```
     *
     */
    getLineWidth(): number;
    /**
     * 绘制直线
     * @param pt1 第一个点 THREE.Vector3
     * @param pt2 第二个点
     * @returns
     * @example
     * ``` typescript
     *
     * ```
     *
     */
    drawLine(pt1: THREE.Vector3 | number, pt2: THREE.Vector3 | number, x2?: number, y2?: number): void;
    /**
     * 绘制连续的直线
     * @param points 点数组
     * @returns
     * @example
     * ``` typescript
     *
     * ```
     *
     */
    drawLines(points: THREE.Vector3[] | THREE.Vector2[]): void;
    /**
     * 根据几何数据绘制直线
     * @param points 点数组
     * @returns
     * @example
     * ``` typescript
     *
     * ```
     *
     */
    drawGeometryLines(geometry: THREE.Geometry): void;
    /**
     * 绘制圆
     * @param cen 圆的中心点 THREE.Vector3
     * @param dRadius 圆的半径
     * @returns
     * @example
     * ``` typescript
     *
     * ```
     *
     */
    drawCircle(cen: THREE.Vector3, dRadius: number): void;
    /**
     * 绘文本
     * @param sText 文本信息
     * @param iSize 文字大小
     * @param dAngle  角度
     * @param pt 位置
     * @returns
     * @example
     * ``` typescript
     *
     * ```
     *
     */
    drawText(sText: string, iSize: number, dAngle: number, pt: THREE.Vector3, width?: number, callGetFontStyle?: (iFontSize: number) => string): THREE.Sprite | null;
    /**
     * 设置DrawOrder,默认值为100.
     * @returns
     * @example
     * ``` typescript
     *
     * ```
     *
     */
    setRenderOrder(iRenderOrder: number): void;
    /**
     * 得到DrawOrder
     * @returns
     * @example
     * ``` typescript
     *
     * ```
     *
     */
    getRenderOrder(): number;
    /**
     * 设置宽度单位是屏幕像素，默认是屏幕像素，设置false,单位是Threejs坐标。
     * @returns
     * @example
     * ``` typescript
     *
     * ```
     *
     */
    setLineWidthIsPixels(isPixels: boolean): void;
    /**
     * 得到宽度单位
     * @returns
     * @example
     * ``` typescript
     *
     * ```
     *
     */
    getLineWidthIsPixels(): boolean;
    /**
     * 设置虚线显示数据。
     * @returns
     * @example
     * ``` typescript
     *
     * ```
     *
     */
    setDash(dDashArray: number, dDashRatio: number): void;
    /**
     * 得到虚线显示数据。
     * @returns
     * @example
     * ``` typescript
     *
     * ```
     *
     */
    getDash(): any;
    /**
     * 设置虚线显示
     * @returns
     * @example
     * ``` typescript
     *
     * ```
     *
     */
    setDashLineDisplay(isDashLine: boolean): void;
    /**
     *是否虚线显示
     * @returns
     * @example
     * ``` typescript
     *
     * ```
     *
     */
    isDashLineDisplay(): boolean;
    /**
     *绘制选择线。
     * @returns
     * @example
     * ``` typescript
     *
     * ```
     *
     */
    drawSelectLine(pt1: THREE.Vector3 | number, pt2: THREE.Vector3 | number, x2?: number, y2?: number): void;
    /**
     * 设置变换矩阵
     * @param
     */
    setMatrix(matrix: THREE.Matrix4 | null): void;
    /**
     * 返回变换矩阵
     * @param
     */
    getMatrix(): THREE.Matrix4 | null;
    /**
     *设置透明度
     * @returns
     * @example
     * ``` typescript
     *
     * ```
     *
     */
    setOpacity(opacity: number): void;
    /**
     *返回透明度
     * @returns
     * @example
     * ``` typescript
     *
     * ```
     *
     */
    getOpacity(): number;
    /**
     *绘制纯色填充
     * @returns
     * @example
     * ``` typescript
     *
     * ```
     *
     */
    drawSolid(points: THREE.Vector3[]): void;
    /**
     *把一个对象的绘图属性设置到当前绘图上下文
     * @returns
     * @example
     * ``` typescript
     *
     * ```
     *
     */
    setupForEntity(ent: MxDbEntity): void;
    /**
     *设置drawEntity函数，绘制的three.js对象，附加一个扩展数据，方便在后续选择对象，得到该扩展数据.、
     *只会对一次的drawEntity调用有效.
     * @returns
     * @example
     * ``` typescript
     *
     * ```
     *
     */
    setXData(xData: any): void;
}

/**
 * MxDbEntity 用于构建一个自定义对象的抽象类(该类无法实例化 请通过继承的方式对其抽象方法进行实现)
 * @description MxDbEntity 属于 abstract class(抽象类) 主要用途是通过继承这个类实现一个用于动态绘制的图形对象
 * 继承实现这个类必须实现的抽象方法：（方法名称前有'Abstract'标签就是必须实现的方法）
 * @example ```typescript
 * import THREE from "three"
 * import { McGiWorldDraw, MxDbEntity } from "mxdraw"
 * class MxLineEntity extends MxDbEntity {
 *    constructor() {
 *       super(); // 在派生类的构造函数中必须调用 super()
 *    }
 *    private pt1: THREE.Vector3 = new THREE.Vector3();
 *    private pt2: THREE.Vector3 = new THREE.Vector3();
 *    worldDraw(pWorldDraw: McGiWorldDraw) {
 *        pWorldDraw.drawLine(this.pt1,this.pt2);
 *    }
 *    ...
 * }
 * ```
 */
declare abstract class MxDbEntity {
    constructor();
    /** 该类注册的cmd命令名称 */
    static cmd: string;
    /** 该类注册的cmd命令绘制函数 */
    static draw: Function;
    /** 该类是否已注册 */
    static isRegister: boolean;
    /** 注册该类的cmd命令和初始化 (引入该类时自动注册 当该类的isRegister为ture时表示已经注册) */
    static register(): void;
    /** 使用该类的cmd命令 执行默认的绘制功能 */
    static use(): Promise<void>;
    /**
     * 颜色值
     * */
    color: UnstableColor;
    /**
     * 显示顺序
     * */
    renderOrder: number;
    /**
     * 设置透明度 0 ~ 1,1表示完全不透明，0表示全透明.
     * */
    opacity: number;
    /**
     * 该矩形对象是否可见
     * */
    visible: boolean;
    /**
     * 用户自定义数据.
     * */
    userData: {
        [key: string]: any;
    };
    sGuid: string;
    dLineWidth: number;
    lineWidthByPixels: boolean;
    dDashArray: number;
    dDashRatio: number;
    layer: string;
    private _event;
    abstract getTypeName(): string;
    initGuid(guid: string): void;
    /**
     * 自定义对象的绘制函数。在方法中定义如何绘制图形
     * @param  pWorldDraw 绘制对象{@link McGiWorldDraw }
     * @returns void
     */
    abstract worldDraw(pWorldDraw: McGiWorldDraw): void;
    /**
     * 返回自定义对象的夹点.
     * @param
     * @returns Array<THREE.Vector3>
     */
    abstract getGripPoints(): Array<THREE.Vector3>;
    /**
     * 移动自定义对象的夹点.
     * @param
     * @returns boolean
     */
    abstract moveGripPointsAt(index: number, offset: THREE.Vector3): boolean;
    /**
     * 自定义对象数据输入，辅助函数.
     * @param obj 数据对象
     * @param aryProp 属性名称列表
     * @param hooks.getVal 交互数据输入钩子函数 return null | undefined 默认深拷贝 ; return Value 返回数据
     * @param hooks.getCacheVal 归档数据构子函数 return null | undefined 默认深拷贝 ; return Value 返回数据
     * @returns boolean
     * @example
     * ``` typescript
     *  class MxLine extends MxDbEntity {
     *    dwgIn(obj) {
     *        // 必须调用 同步自定义数据对象输入
     *       this.dwgInHelp(obj,["xxx"])
     *    }
     *  }
     * ```
     */
    protected dwgInHelp<T extends (string | {
        key: string;
        default: any;
    })[]>(obj: any, aryProp: T, hooks?: {
        getVal?: (v: any) => any;
        getCacheVal?: (v: any) => any;
    }): boolean;
    /**
     * 自定义对象数据输出 辅助函数.
     * @param
     * @returns object
     * @example
     * ``` typescript
     *  class MxLine extends MxDbEntity {
     *    dwgOut(obj) {
     *        // 必须调用 同步自定义数据对象输出
     *       this.dwgOutHelp(obj,["xxx"])
     *    }
     *  }
     * ```
     */
    protected dwgOutHelp(obj: any, aryProp: (string | {
        key: string;
        default: any;
    })[]): any;
    protected callEvent(sEventName: string, param?: any): any;
    /**
     * 新创建一个自定义对象 (默认调用该对象的构造函数来创建新的对象)
     * @param { T } options
     * @returns MxDbEntity
     */
    create(options?: {}): any;
    /**
     * 自定义对象数据输入，必须要实现该函数
     * @param
     * @returns boolean
     * @example
     * ``` typescript
     *  class MxLine extends MxDbEntity {
     *    dwgIn(obj) {
     *        // 必须调用 同步自定义数据对象输入
     *       this.onDwgIn(obj)
     *    }
     *  }
     * ```
     */
    abstract dwgIn(obj: {
        type: MxType.MxCloneType;
        [x: string]: any;
    }): boolean;
    /**
     * 自定义对象数据输出，必须要实现该函数
     * @param
     * @returns object
     * @example
     * ``` typescript
     *  class MxLine extends MxDbEntity {
     *    dwgOut(obj) {
     *        // 必须调用 同步自定义数据对象输出
     *       this.onDwgOut(obj)
     *    }
     *  }
     * ```
     */
    abstract dwgOut(obj: {
        type: MxType.MxCloneType;
        [x: string]: any;
    }): object;
    /**
     * 自定义实体的矩阵 坐标变换 (需要重写该方法实现如果通过矩阵对自定义实体进行操作 默认不会进行任何操作)
     * @param _mat THREE.Matrix4 变化矩阵
     * @returns void
     */
    transformBy(_mat: THREE.Matrix4): void;
    /**
     * 返回对象最小外包.
     * @param
     * @returns void
     */
    getGeomExtents(): THREE.Box3 | null;
    /**
     * 对一个点到这个对象的最近点 。
     * iOperationType == 0正常操作求值最近点.
     * iOperationType == 1点选择操作求值最近点.
     * @param
     * @returns void
     */
    getClosestPointTo(pt: THREE.Vector3, iOperationType?: number): THREE.Vector3 | null;
    private getImp;
    /**
     * 更新显示
     * @param 为true 重绘时立即更新显示,默认值false
     * @returns boolean
  
     */
    setNeedUpdateDisplay(isImmediate?: boolean): boolean;
    /**
     * 返回对象所在的控件对象。
     * @returns {@link MxDrawObject}
     */
    getMxObject(): MxDrawObject | null;
    /**
     * 视区显示比较发生成变化，继承类可以向应该事件，更新显示大小。
     * @returns boolean
     */
    protected onViewChange(): boolean;
    /**
     * 得到对象的id.
     * @returns number
     */
    objectId(): number;
    /**
     * 删除对象
     * @returns boolean
     */
    erase(): boolean;
    /**
     * 设置图层
     * @returns boolean
     */
    setLayer(layer: string): void;
    /**
     * 得到图层
     * @returns boolean
     */
    getLayer(): string;
    /**
     * 设置颜色
     * @param color 颜色值
     * @returns boolean
     */
    setColor(color: MxColorType): this;
    /**
     * 得到颜色
     * @returns boolean
     */
    getColor(): MxColorType;
    /**
     * 复制克隆对象。
     * @param type {@link MxType.MxCloneType} 传入参数区分是正常拷贝还是动态拷贝
     * @returns MxDbEntity
     */
    clone(type?: number): any;
    /**
     * 自定义对象内部数据输入同步（重写实现dwgIn抽象方法时 必须在实现中调用 this.onDwgIn(obj)）
     * @param obj dwgIn抽象方法的回调数据
     */
    protected onDwgIn(obj: any): void;
    /**
     * 自定义对象内部数据输出同步（重写实现dwgIn抽象方法 必须在实现中调用 this.onDwgIn(obj)
     * @param obj dwgOut抽象方法的回调数据
     */
    protected onDwgOut(obj: any): void;
    /**
     * 初始自定义对象的类型信息.(如果需要实现该图形对象的保存数据和恢复数据的功能, 需要在项目中初始化一次该图形对象的类)
     * @returns
     */
    rxInit(): void;
    /**
     * 设置显示顺序 (通过显示顺序控制图层)
     * @param renderOrder 显示顺序
     */
    setRenderOrder(renderOrder: number): void;
    /**
     * 得到显示顺序
     * @returns number
     */
    getRenderOrder(): number;
    /**
     * 设置线宽是否随像素
     * @returns number
     */
    setLineWidthByPixels(isPixels: boolean): this;
    /**
     * 线宽是否随像素
     * @returns number
     */
    getLineWidthByPixels(): boolean;
    /**
     * 设置线宽
     * @returns number
     */
    setLineWidth(dLineWidth: number): this;
    /**
     * 得到线宽
     * @returns number
     */
    getLineWidth(): number;
    /**
     * 返回曲线长度
     * @returns number
     */
    getGetLength(): number;
    /**
     * 设置虚线 +实线的长度.
     * dDashRatio确定虚线，与实线的比率.
     * @returns number
     */
    setDashLen(dashLen: number): this;
    /**
     * 设置虚线，与实线的比率
     * @returns number
     */
    setDashRatio(dDashRatio: number): this;
    /**
     * 设置实线虚线总段数 = 1 / dashArray
     * @returns number
     */
    setDashArray(dDashArray: number): this;
    /**
     * 设置虚线数据
     * @returns number
     */
    setDash(dDashArray: number, dDashRatio: number): this;
    /**
     * 得到虚线数据
     * @returns number
     */
    getDash(): any;
    /**
     * 设置虚线显示。并初始化一个默认值。
     * @returns number
     */
    setDashLineDisplay(isDashLine: boolean): this;
    /**
     * 是否虚线显示
     * @returns number
     */
    isDashLineDisplay(): boolean;
    /**
     * 返回唯一标识guid
     * @returns string
     */
    guid(): string;
    /**
     * 对象结束开始编辑
     * @returns string
     */
    onEndGripEidt(): void;
    /**
     * 对象开始开始编辑
     * @returns string
     */
    onStartGripEidt(): any;
    /**
     * 添加一个事件处理
     * @returns void
     */
    addEvent(name: string, fun: object): void;
    /**
     * 删除一个事件处理
     * @returns void
     */
    removeEvent(name: string): void;
    /**
    * 把一个对象变成一个json字体串.
    * @returns void
    */
    toJsonString(type?: MxType.MxCloneType): string;
    /**
     * 从一个josn字符串加载数据.
     * @returns void
     */
    fromJsonString(str: string): boolean;
}

/** @module MxDbGroup */
/**
 * MxDbGroup 组对象对象.
 *
 */
interface MxDbGroup {
    name(): string;
    append(id: number): void;
    clear(): void;
    getAll(): number[];
    has(id: number): boolean;
    delete(id: number): boolean;
}

/** @module MxDbLayerTableRecord */
/**
 * MxDbDatabase 当前数据库对象.
 *
 */
interface MxDbLayerTableRecord {
    getName(): string;
    setVisible(visible: boolean): void;
    getVisible(): boolean;
}

/** @module MxDbDatabase */

/**
 * MxDbDatabase 当前数据库对象.
 *
 */
declare class MxDbDatabase {
    private _mxDatabase;
    constructor(mxDatabase: any);
    /**
     * 添加图层.
     * @example
     * ```typescript
     *
     * ```
     */
    addLayer(layer: string): MxDbLayerTableRecord;
    /**
     * 显示或隐藏图层
     * @example
     * ```typescript
     *
     * ```
     */
    showLayer(layer: string, isVisible: boolean): void;
    /**
     * 设置当前图层
     * @example
     * ```typescript
     *
     * ```
     */
    setCurrentLayer(layer: string): MxDbLayerTableRecord;
    /**
     * 得到图层对象.
     * @example
     * ```typescript
     *
     * ```
     */
    getLayer(layer: string): MxDbLayerTableRecord;
    /**
     * 添加对象到当前数据库.
     * @example
     * ```typescript
     *
     * ```
     */
    addEntity(ent: MxDbEntity): number;
    /**
     * 根据组名，得到组对象。
     * @example
     * ```typescript
     *
     * ```
     */
    getGroup(sName: string): MxDbGroup;
    /**
     * 添加一个组，如果组已经存在，直接返回该组。
     * @example
     * ```typescript
     *
     * ```
     */
    addGroup(sName: string): MxDbGroup;
    /**
     * 得到一个实体所在的所有组。
     * @example
     * ```typescript
     *
     * ```
     */
    getEntityInGroup(id: number): MxDbGroup[];
    /**
     * 删除一个组.
     * @example
     * ```typescript
     *
     * ```
     */
    deleteGroup(sName: string): MxDbGroup;
}

/** @module MxDrawObject */

interface MxDrawObjectType {
    renderer: THREE.WebGLRenderer;
    addEvent(arg0: string, arg1: (...parmes: any) => any): void;
    setIniset(arg0: {
        EnableOsnapFunction: boolean;
    }): void;
    getScene(): THREE.Scene;
    getCamera(): THREE.Camera;
    setMouseRightRotate(isRotate: boolean): void;
    getFullDisplayRange(): object;
    getCanvas(): HTMLCanvasElement;
    updateDisplay(): void;
    createCanvasImageData(fun: (imageData: string) => void, param?: object): void;
    setViewColor(color: number): void;
    setSize(width: number, height: number): void;
    getIntersectObjects(ptMouse: THREE.Vector2): THREE.Intersection[];
    getViewWidth(): number;
    getViewHeight(): number;
    zoomInitialStates(): void;
    zoomScale(scale: number): void;
    zoomW(minPt: THREE.Vector3, maxPt: THREE.Vector3, isWorld?: boolean): void;
    zoomCenter(dCenX: number, dCenY: number): void;
    initZoomW(pt1Doc: THREE.Vector3, pt2Doc: THREE.Vector3): void;
    addMxEntity(ent: any): number;
    eraseMxEntity(id: number): boolean;
    screenCoord2World(x: number, y: number, z?: number): THREE.Vector3;
    worldCoord2Screen(x: number, y: number, z: number): THREE.Vector3;
    screenCoord2Doc(x: number, y: number, z: number): THREE.Vector3;
    worldCoordLong2Doc(l: number): number;
    docCoordLong2World(l: number): number;
    docCoord2World(x: number, y: number, z: number): THREE.Vector3;
    worldCoord2Doc(x: number, y: number, z: number): THREE.Vector3;
    docCoord2Screen(x: number, y: number, z: number): THREE.Vector3;
    screenCoordLong2Doc(l: number): number;
    docCoordLong2Screen(l: number): number;
    screenCoordLong2World(l: number): number;
    worldCoordLong2Screen(l: number): number;
    initRendererParam(param: object): void;
    getMxAllSelect(): Array<number>;
    addMxCurrentSelect(id: number): void;
    clearMxCurrentSelect(): boolean;
    getMxEntityUserObject(id: number): MxDbEntity;
    findMxEntityAtPoint(ptMouse: THREE.Vector3, isDocCoord?: boolean, retWordDrawXDataCall?: (id: number, data: any) => void): Array<MxDbEntity>;
    setMouseMiddlePan(isPan: boolean): void;
    resetThreeJSControls(): void;
    getAllMxEntity(): Array<MxDbEntity>;
    enableZoom(isEnable: boolean): void;
    enablePan(isEnable: boolean): void;
    addObject(obj: THREE.Object3D | null, isAddToSelect?: boolean): void;
    addViewObject(obj: THREE.Object3D): void;
    removeViewObject(obj: THREE.Object3D): void;
    removeObject(obj: THREE.Object3D, isRemoveSelectObject?: boolean): void;
    saveMxEntityToJson(isSaveToDWG?: boolean): object;
    loadMxEntityFromJson(dataString: object): Promise<boolean>;
    eraseAllMxEntity(): void;
    makeCurrent(): void;
    getViewCenterDocCoord(): THREE.Vector3;
    updateCanvasSize(): void;
}
/**
 * 引入mxdraw库不会挂载MxDrawObject 只能在以下特定函数中获取
 * @function
 * {@link MxFun.createMxObject}中callback回调参数`mxDraw`的构造类
 * @function
 * {@link MxFun.getCurrentDraw} 方法返回值的构造类
 * @function
 * {@link MxFun.getCurrentMxCAD} 方法返回值的构造类
 *
 */
declare class MxDrawObject {
    private _mxdrawObj;
    constructor(Mxdraw: MxDrawObjectType);
    /**
     * @instance
     */
    renderer: THREE.WebGLRenderer;
    /**
     * 获取Three.js绘图场景
     * @returns THREE.Scene
     */
    getScene(): THREE.Scene;
    /**
     * 获取Three.js相机对象
     * @returns THREE.Camera
     */
    getCamera(): THREE.Camera;
    /**
     * 获取Three renderer渲染器
     * @returns THREE.WebGLRenderer
     */
    getRenderer(): THREE.WebGLRenderer;
    /**
     * 设置鼠标按下是否旋视区
     * @param isRotate  是否旋视区
     * @returns void
     * @example
     * ```typescript
     * Mx.MxFun.getCurrentDraw().setMouseRightRotate(false)
     * ```
     *
     */
    setMouseRightRotate(isRotate?: boolean): void;
    /**
     * 得到全部显示所有图形所需要的显示的范围 ，Three.js的坐标系。world坐标。
     * @returns {minPt: value,maxPt: value}
     * @example
     * ```typescript
     * Mx.MxFun.getCurrentDraw().getFullDisplayRange()
     * ```
     */
    getFullDisplayRange(): object;
    /**
     * 获取Canvas对象.
     * @returns HTMLCanvasElement
     */
    getCanvas(): HTMLCanvasElement;
    /**
     * 通知Three.js更新显示
     * @returns void
     */
    updateDisplay(): void;
    /**
     * 通知Three.js生成ImgeData显示I数据.
     * @param fn 回调函数或者imageData
     * @param param 函数载荷
     * @returns void
     * @example
     * ```typescript
     * Mx.MxFun.getCurrentDraw().createCanvasImageData((imageData)=> {
     *      console.log(imageData)
     * })
     * ```
     */
    createCanvasImageData(fn: (imageData: string) => void, param?: object): void;
    /**
     * 设置视区背景色,
     * @param color 如0xFFFFFF 白色
     * @returns void
     * @example
     * ```typescript
     * Mx.MxFun.getCurrentDraw().setViewColor(0xFFFFFF)
     * ```
     */
    setViewColor(color: number): void;
    /**
     * 设置视区背景色,
     * @param width 宽度
     * @param height 宽度
     * @returns void
     * @example
     * ```typescript
     * Mx.MxFun.getCurrentDraw().setSize(0xFFFFFF)
     * ```
     */
    setSize(width: number, height: number): void;
    /**
     * 获取某屏幕点下的绘制对象，ptMouse是.,
     * @param ptMouse THREE.Vector2 屏幕坐标
     * @returns THREE.Intersection[]
     * @example
     * ```typescript
     * Mx.MxFun.getCurrentDraw().getIntersectObjects(new THREE.Vector2(2, 3))
     * ```
     */
    getIntersectObjects(ptMouse: THREE.Vector2): THREE.Intersection[];
    /**
     * 添加THREE.Object3D对象到当前场景
     * @param obj THREE.Object3D
     * @param isAddToSelect 默认值为true  是否把对象添加选择对象集中,调用 getIntersectObjects可以找到
     * @returns void
     * @example
     * ```typescript
     * Mx.MxFun.getCurrentDraw().addObject(new THREE.Object3D(), false)
     * ```
     */
    addObject(obj: THREE.Object3D, isAddToSelect?: boolean): void;
    /**
     * 添加THREE.Object3D对象到视区场景，对象坐标系是窗口视区坐标系。0,0点在左下角.
     * @param obj THREE.Object3D
     * @returns void
     * @example
     * ```typescript
     * Mx.MxFun.getCurrentDraw().addViewObject(new THREE.Object3D())
     * ```
     */
    addViewObject(obj: THREE.Object3D): void;
    /**
     * 得到对象画布的宽度，单位屏幕像素
     * @returns number
     * @example
     * ```typescript
     * Mx.MxFun.getCurrentDraw().getViewWidth()
     * ```
     */
    getViewWidth(): number;
    /**
     * 得到对象画布的高度，单位屏幕像素
     * @returns number
     * @example
     * ```typescript
     * Mx.MxFun.getCurrentDraw().getViewHeight()
     * ```
     */
    getViewHeight(): number;
    /**
     * 删除addObject函数添加的THREE.Object3D对象
     * @param obj THREE.Object3D
     * @param isRemoveSelectObject 默认值为true  删除选择集中的对象
     * @returns void
     * @example
     * ```typescript
     * Mx.MxFun.getCurrentDraw().removeObject(new THREE.Object3D(), false)
     * ```
     */
    removeObject(obj: THREE.Object3D, isRemoveSelectObject?: boolean): void;
    /**
     * 把视区显示范围恢复到初始显示范围.
     * @returns void
     */
    zoomInitialStates(): void;
    /**
     * 缩放当前显示范围，它是相对于当前显示范围进行缩放
     * @param scale scale缩放比例
     * @returns void
     * @example
     * ```typescript
     * Mx.MxFun.getCurrentDraw().zoomScale(0.8)
     * ```
     */
    zoomScale(scale: number): void;
    /**
     * 把当前显示范围移到指定的显示范围
     * @param minPt 坐标1 THREE.Vector3
     * @param maxPt 坐标2 THREE.Vector3
     * @param isWorld 默认为felse DWG图纸坐标，设置为true是THREEJS坐标
     * @returns void
     * @example
     * ```typescript
     * Mx.MxFun.getCurrentDraw().zoomW(new THREE.Vector3(0,10,10), new THREE.Vector3(3,8,20), true)
     * ```
     */
    zoomW(minPt: THREE.Vector3, maxPt: THREE.Vector3, isWorld?: boolean): void;
    /**
     * 把当前显示范围移到指定的位置,dCenX,dCenY是DWG图纸坐标。
     * @param minPt DWG图纸坐标1 THREE.Vector3
     * @param maxPt DWG图纸坐标2 THREE.Vector3
     * @returns void
     * @example
     * ```typescript
     * Mx.MxFun.getCurrentDraw().zoomCenter(new THREE.Vector3(0,10,10), new THREE.Vector3(3,8,20))
     * ```
     */
    zoomCenter(dCenX: number, dCenY: number): void;
    /**
     * 初始化控件默认加载后，显示视区范围，默认使用图纸转换时的显示范围。。
     * @param minPt DWG文档坐标1显示区域的左下角 THREE.Vector3
     * @param maxPt DWG文档坐标2显示区域的右上角 THREE.Vector3
     * @returns void
     * @example
     * ```typescript
     * Mx.MxFun.getCurrentDraw().initZoomW(new THREE.Vector3(0,10,10), new THREE.Vector3(3,8,20))
     *
     * ```
     */
    initZoomW(pt1Doc: THREE.Vector3, pt2Doc: THREE.Vector3): void;
    /**
     * 初始化控件默认加载后，显示视区范围，默认使用图纸转换时的显示范围。。
     * @param minPt DWG文档坐标1显示区域的左下角 THREE.Vector3
     * @param maxPt DWG文档坐标2显示区域的右上角 THREE.Vector3
     * @returns void
     * @example
     * ```typescript
     * Mx.MxFun.getCurrentDraw().addEvent(new THREE.Vector3(0,10,10), new THREE.Vector3(3,8,20))
     *
     * ```
     */
    /**
     * 控件对象的事件监听
     * @param eventNaem 事件名称
     * @param fun 回调函数
     * @returns void
     * @example
     * ```typescript
     * Mx.MxFun.getCurrentDraw().addEvent("addResizeEvent", ()=> {})
     * Mx.MxFun.getCurrentDraw().addEvent("viewchange", ()=> {})
     * 图纸加载完成
     * Mx.MxFun.getCurrentDraw().addEvent("loadComplete", ()=> {})
     * 视区重绘事件.
     * Mx.MxFun.getCurrentDraw().addEvent("render", (renderer)=> {})
     * 视区大小被修改事件.,viewsize={viewWidth:viewWidth,viewHeight:viewHeight}
     * Mx.MxFun.getCurrentDraw().addEvent("viewsizechange", (viewsize)=> {})
     * 实体选择状态发生改变的事件.
     * Mx.MxFun.getCurrentDraw().addEvent("MxEntitySelectChange", (aryId:Array<number>)=> {})
     * ```
     */
    addEvent(eventNaem: string, fun: (...parmes: any) => any): void;
    /**
     * 控件对象的事件监听
     * @param eventNaem 事件名称
     * @param fun 回调函数
     * @returns void
     * @example
     * ```typescript
     * Mx.MxFun.getCurrentDraw().on("addResizeEvent", ()=> {})
     * Mx.MxFun.getCurrentDraw().on("viewchange", ()=> {})
     * 图纸加载完成
     * Mx.MxFun.getCurrentDraw().on("loadComplete", ()=> {})
     * 视区重绘事件.
     * Mx.MxFun.getCurrentDraw().on("render", (renderer)=> {})
     * 视区大小被修改事件.,viewsize={viewWidth:viewWidth,viewHeight:viewHeight}
     * Mx.MxFun.getCurrentDraw().on("viewsizechange", (viewsize)=> {})
     * 实体选择状态发生改变的事件.
     * Mx.MxFun.getCurrentDraw().on("MxEntitySelectChange", (aryId:Array<number>)=> {})
     * ```
     */
    on(eventNaem: string, fun: (...parmes: any) => any): void;
    /**
     * INI设置
     * @param options { EnableOsnapFunction: boolean; }
     * @returns void
     * @example
     * ```typescript
     * Mx.MxFun.getCurrentDraw().setIniset(options: { EnableOsnapFunction: true })
     *
     * ```
     */
    setIniset(options: {
        EnableOsnapFunction: boolean;
    }): void;
    /**
     * 屏幕坐标到ThreeJS坐标
     * @returns THREE.Vector3
     * @example
     * ```typescript
     *
     *
     * ```
     */
    screenCoord2World(x: number, y: number, z?: number): THREE.Vector3;
    /**
     * ThreeJS坐标到屏幕坐标,屏幕坐标的Y轴向下。坐标原点在左上角.
     * @returns THREE.Vector3
     * @example
     * ```typescript
     *
     *
     * ```
     */
    worldCoord2Screen(x: number, y: number, z: number): THREE.Vector3;
    /**
     * 屏幕坐标到DWG文档坐标
     * @returns THREE.Vector3
     * @example
     * ```typescript
     *
     *
     * ```
     */
    screenCoord2Doc(x: number, y: number): THREE.Vector3;
    /**
     * ThreeJS坐标长度到DWG文档坐标长度
     * @returns number
     * @example
     * ```typescript
     *
     *
     * ```
     */
    worldCoordLong2Doc(l: number): number;
    /**
     * DWG文档坐标长度到ThreeJS坐标长度
     * @returns number
     * @example
     * ```typescript
     *
     *
     * ```
     */
    docCoordLong2World(l: number): number;
    /**
     * DWG文档坐标到ThreeJS坐标
     * @returns number
     * @example
     * ```typescript
     *
     *
     * ```
     */
    docCoord2World(x: number, y: number, z: number): THREE.Vector3;
    /**
     * DWG文档坐标到ThreeJS坐标
     * @returns THREE.Vector3
     * @example
     * ```typescript
     *
     *
     * ```
     */
    docCoord2World2(pt: THREE.Vector3): THREE.Vector3;
    /**
     * ThreeJS坐标到DWG文档坐标
     * @returns number
     * @example
     * ```typescript
     *
     *
     * ```
     */
    worldCoord2Doc(x: number, y: number, z: number): THREE.Vector3;
    /**
     * ThreeJS坐标到DWG文档坐标
     * @returns THREE.Vector3
     * @example
     * ```typescript
     *
     *
     * ```
     */
    worldCoord2Doc2(pt: THREE.Vector3): THREE.Vector3;
    /**
     * DWG文档坐标到屏幕坐标
     * @returns number
     * @example
     * ```typescript
     *
     *
     * ```
     */
    docCoord2Screen(x: number, y: number): THREE.Vector3;
    /**
     * 屏幕坐标长度到DWG文档坐标长度
     * @returns number
     * @example
     * ```typescript
     *
     *
     * ```
     */
    screenCoordLong2Doc(l: number): number;
    /**
     * DWG文档坐标长度到屏幕坐标长度
     * @returns number
     * @example
     * ```typescript
     *
     *
     * ```
     */
    docCoordLong2Screen(l: number): number;
    /**
     * 屏幕坐标长度到ThreeJS坐标长度
     * @returns number
     * @example
     * ```typescript
     *
     *
     * ```
     */
    screenCoordLong2World(l: number): number;
    /**
     * ThreeJS坐标长度到屏幕坐标长度
     * @returns number
     * @example
     * ```typescript
     *
     *
     * ```
     */
    worldCoordLong2Screen(l: number): number;
    /**
     * 初始WebGL Renderer的创建参数,该函数在MxFun.createMxObject函数调用时，调用。
     * @param param
     * @returns void
     * @example
     * ```typescript
     * mxObj.initRendererParam({preserveDrawingBuffer: true})
     *
     * ```
     */
    initRendererParam(param: object): void;
    /**
     * 添加一个自定义实体到图上。
     * @param ent 自定义实体对象
     * @returns number 返回对象的id.
     * @example
     * ```typescript
     *
     *
     * ```
     */
    addMxEntity(ent: MxDbEntity): number;
    /**
     * 得到图上当前选择的对象.
     * @returns Array<number> 返回对象的id数组.
     * @example
     * ```typescript
     *
     *
     * ```
     */
    getMxCurrentSelect(): Array<number>;
    /**
     * 把对象添加到当前选择中.
     * @returns void
     * @example
     * ```typescript
     *
     *
     * ```
     */
    addMxCurrentSelect(id: number): void;
    /**
     * 清除当前所有选择
     * @returns void
     * @example
     * ```typescript
     *
     *
     * ```
     */
    clearMxCurrentSelect(): boolean;
    /**
     *通过id获取绘制的对象.
     * @param id 返回对象的id
     * @returns MxDbEntity
     * @example
     * ```typescript
     *
     *
     * ```
     */
    getMxEntity(id: number): MxDbEntity;
    /**
     * 查找某点位置处的用户自绘对象.
     * @param ptMouse 查找的点位 THREE.Vector3,默认是文档坐标
     * @returns MxDbEntity[] 返回用户自绘对象数组
     * @example
     * ```typescript
     *
     *
     * ```
     */
    findMxEntityAtPoint(ptMouse: THREE.Vector3, isDocCoord?: boolean, retWordDrawXDataCall?: (id: number, data: any) => void): Array<MxDbEntity>;
    /**
     *得到所有用户自绘对象.
     * @returns MxDbEntity[] 返回用户自绘对象数组
     * @example
     * ```typescript
     *
     *
     * ```
     */
    getAllMxEntity(): Array<MxDbEntity>;
    /**
     * 设置鼠标中键移动视区。
     * @param isPan 设置是否可以鼠标中键移动视区
     * @returns
     * @example
     * ```typescript
     *
     *
     * ```
     */
    setMouseMiddlePan(isPan: boolean): void;
    /**
     *重新设置ThreeJS Controls状态.
     * @returns
     * @example
     * ```typescript
     *
     *
     * ```
     */
    resetThreeJSControls(): void;
    /**
     * 启用或禁用鼠标中键滚动缩放视区
     * @param isEnable 是否启用
     * @returns
     * @example
     * ```typescript
     *
     *
     * ```
     */
    enableZoom(isEnable: boolean): void;
    /**
     * 启用或禁用鼠标移动视区
     * @param isEnable 是否启用
     * @returns
     * @example
     * ```typescript
     *
     *
     * ```
     */
    enablePan(isEnable: boolean): void;
    /**
     * 删除MxEntity
     * @param id 实体id.
     * @returns
     * @example
     * ```typescript
     *
     *
     * ```
     */
    eraseMxEntity(id: number): boolean;
    /**
     * 移除安视图坐标绘制的对象.
     * @param obj 对象.
     * @returns
     * @example
     * ```typescript
     *
     *
     * ```
     */
    removeViewObject(obj: THREE.Object3D): void;
    /**
     * 保存所有MxEntity的数据到json字符串.
     * @param
     * @returns json字符串
     * @example
     * ```typescript
     *
     *
     * ```
     */
    saveMxEntityToJson(isSaveToDWG?: boolean): string;
    /**
     * 保存所有MxEntity的数据到js对象.
     * @param
     * @returns js对象
     * @example
     * ```typescript
     *
     *
     * ```
     */
    saveMxEntityToObject(isSaveToDWG?: boolean): object;
    /**
     * 从json字符串恢复MxEntity
     * @param dataString json字符串.
     * @returns
     * @example
     * ```typescript
     *
     *
     * ```
     */
    loadMxEntityFromJson(dataString: string | object, aryPreloadSVG?: string[] | null): Promise<boolean>;
    /**
     * 删除所有的MxEntity
     * @param
     * @returns
     * @example
     * ```typescript
     *
     *
     * ```
     */
    eraseAllMxEntity(): void;
    /**
     * 把该控件对象，设置成当前控件.
     * @param
     * @returns
     * @example
     * ```typescript
     *
     *
     * ```
     */
    makeCurrent(): void;
    /**
     * 得到视区中心的文档坐标.
     * @param
     * @returns
     * @example
     * ```typescript
     *
     *
     * ```
     */
    getViewCenterDocCoord(): THREE.Vector3;
    /**
     * 画布大小，自动修改到它父亲div大小。
     * @param
     * @returns
     * @example
     * ```typescript
     *
     *
     * ```
     */
    updateCanvasSize(): void;
    /**
     * 新建图纸.
     * @param ptin1,ptin2新建图纸的显示范围.
     * @returns
     * @example
     * ```typescript
     *
     *
     * ```
     */
    newFile(ptin1: THREE.Vector3 | number, ptin2: THREE.Vector3 | number, x2?: number, y2?: number): boolean;
    /**
     * 停止当前加载
     * @example
     * ```typescript
     *
     * ```
     */
    stopAllLoading(): void;
    /**
     * 得到Three.js的 OrbitControls对象.
     * @example
     * ```typescript
     *
     * ```
     */
    getOrbitControls(): OrbitControls;
    /**
     * 禁用或启用视区的移动，放大，缩小等操作.
     * @example
     * ```typescript
     *
     * ```
     */
    enableViewControls(isEnable: boolean): void;
    /**
     * 得到当前图形数据库对象
     * @example
     * ```typescript
     *
     * ```
     */
    getMxDatabase(): MxDbDatabase;
    /**
     * 设置鼠标中键的滚动的缩放比例,在PC上，默认值4，手机上默认值，1.5
     * 返回之前设置值。
     * @example
     * ```typescript
     *
     * ```
     */
    setZoomSpeed(zoomSpeed: number): number;
    /**
     * 得到MxCAD对象.
     * @return MxCADObject
     * @example
     * ``` typescript
     * ```
     */
    getMxCAD(): MxCADObject;
    /**
     * 重新计数Renderer状态, this.renderer.info.reset();
     * @return
     * @example
     * ``` typescript
     * ```
     */
    resetRenderer(): any;
    /**
     * 设置服务器发送文件请求时，需要带的参数.;
     * @return
     * @example
     * ``` typescript
     * ``` mxobj.setRequestHeader("{'data':'value1'}");
     */
    setRequestHeader(val: string): any;
    /**
     * 在MxCAD模式下，关闭与服务器的socket连接 。
     * @return
     * @example
     */
    closeWebSocket(): any;
    /**
     * CAD坐标到文档坐标.
     * 默认情况下，cad等于doc,当前m_isCorrectLargeCoordinates为true时，doc变成了把cad图纸修改到小范围坐标系下的坐标。
     * @returns number
     * @example
     * ```typescript
     *
     *
     * ```
     */
    cadCoord2Doc(x: number, y: number, z: number): THREE.Vector3;
    /**
     * 文档坐标坐标到CAD.
     * 默认情况下，cad等于doc,当前m_isCorrectLargeCoordinates为true时，doc变成了把cad图纸修改到小范围坐标系下的坐标。
     * @returns number
     * @example
     * ```typescript
     *
     *
     * ```
     */
    docCoord2Cad(x: number, y: number, z: number): THREE.Vector3;
    /**
     * 设置视区的旋转角度
     * @example
     * ```typescript
     *
     *
     * ```
     */
    setViewAngle(ang: number): void;
    /**
     * 得到视区的旋转角度
     * @example
     * ```typescript
     *
     *
     * ```
     */
    getViewAngle(): number;
    /**
     * 得到系统变量
     * @example
     * ```typescript
     *
     *
     * ```
     */
    getSysVar(sName: string): any;
    /**
     * 设置系统变量
     * @example
     * ```typescript
     *
     *
     * ```
     */
    setSysVar(sName: string, val: any): void;
    /**
     * 是否是MxCAD模式运行.
     * @example
     * ```typescript
     *
     *
     * ```
     */
    isMxCAD(): boolean;
    /**
   * 得执行的内部MxObject对象.
   * @example
   * ```typescript
   *
   *
   * ```
   */
    getMxObjectImplement(): any;
    /**
    * 得到所有布局名
    * @example
    * ```typescript
    *
    *
    * ```
    */
    getAllLayoutName(): string[];
    /**
  * 得到数据库Json字符串数据.
  * @example
  * ```typescript
  *
  *
  * ```
  */
    getDtabaseJsonString(): string;
    /**
    * 跳转另一个布局页面.
    * @example
    * ```typescript
    *
    *
    * ```
    */
    gotoLayout(layout: string): void;
    /**
     * 初始cpp对象.
     * @example
     * ```typescript
     *
     *
     * ```
     */
    initMxCpp(mcppObjectImp: any): void;
    /**
     * 当前是否支持 opengles3
     * @example
     * ```typescript
     *
     *
     * ```
     */
    isWebgl2(): boolean;
}

/**
 * 使用canvas大小调整侦听器 (只有在 {@link MxFun.createMxObject} 的callbakc回调中调用才有效) 不调用该方法则默认使用window窗口监听从而自动调整画布大小，canvas大小或者其canvas父级元素变化不会自动调整。
 * > 注意：调用方法会加载[element-resize-event-polyfill](https://www.npmjs.com/package/element-resize-event-polyfill)}依赖包  可以通过resize监听dom元素大小变化 `dom.addEventListener('resize', callback)`
 * > 注意: MxFun.createMxObject 方法调用后默认会依据canvasParent父级元素作为自动调整的参考大小 所以传入的canvas也会默认监听canvas父级元素，适配大小请将canvas和canvasParent当作一个整体。
 * @param mxdrawObj 调用{@link MxFun.createMxObject}的callback回调函数拿到的 mxDraw 对象参数
 * @param canvas 调用{@link MxFun?.createMxObject}的callback回调函数拿到的dom.canvas作为要监听的元素
 * @param time 大小监听节流函数节流时间 默认 100
 * @param autoAdjust 是否自动调整大小 默认true
 * @param callback 监听回调
 */
declare function useCanvasResizeListener(mxdrawObj: MxDrawObject, canvas: HTMLCanvasElement, time?: number): Promise<void>;

/** @module McGePoint3d */
/**
 * McGePoint3d
 * @example ```typescript
 * ```
 */
interface McGePoint3d {
    x: number;
    y: number;
    z: number;
}

/** @module McGePoint3dArray */

/**
 * McGePoint3dArray
 * @example ```typescript
 * ```
 */
interface McGePoint3dArray {
    /**
     *
     * @returns
     */
    append(pt: McGePoint3d): void;
}

interface MxassemblyType {
    McGePoint3d: any;
    McGePoint3dArray: any;
    McGeTool: any;
}
declare class MxassemblyClass {
    constructor();
    private mxassembly;
    private initImp;
    NewMcGePoint3d(x?: number, y?: number, z?: number): McGePoint3d;
    NewMcGePoint3dArray(aryPoint?: Array<THREE.Vector3>): McGePoint3dArray;
}
/**
 * Mxassembly 模块
 * 导出库时已实例化，只需要调用实例方法 例如：
 * ```typescript
 * ```
 */
declare const Mxassembly: MxassemblyClass;

declare class MxVueComandLine {
    [x: string]: any;
    msCmdText: string;
    msCmdDisplay: string;
    msCmdTip: string;
    mUpDisplayFun: ((data: {
        msCmdTip: string;
        msCmdDisplay: string;
        msCmdText: string;
    }) => void) | undefined;
    mxFunObject: undefined;
    mountUpDisplayFun: (fun: ((data: {
        msCmdTip: string;
        msCmdDisplay: string;
        msCmdText: string;
    }) => void) | undefined) => void;
    upDisplay(): void;
    setCmdText: (str: string) => void;
    getCmdText: () => string;
    getCmdDisplay: () => string;
    setCmdDisplay: (str: string) => void;
    addCmdDisplay: (str: string) => void;
    setCmdTip: (str: string) => void;
    getCmdTip: () => string;
}
declare class MxDynamicInput {
    [x: string]: any;
    mType: number;
    mPos: number[];
    mTip: string;
    mValue1: string;
    mValue1Pos: number[];
    mValue2: string;
    mValue2Pos: number[];
    misShow: boolean;
    mOnKeydownEvent: ((arg0: any) => void) | undefined;
    mFocusValue: string;
    setFocusValue: (value: string) => void;
    getFocusValue: () => string;
    mountKeydownEvent: (fun: ((arg0: any) => void) | undefined) => void;
    onKeydown: (keyCode: any) => void;
    setType: (type: number) => void;
    getType: () => number;
    isShow: () => boolean;
    setPos: (pos: number[]) => void;
    setTip: (tip: string) => void;
    setValue1: (val: string) => void;
    getValue1: () => string;
    setValue1Pos: (pos: number[]) => void;
    setValue2: (val: string) => void;
    getValue2: () => string;
    setValue2Pos: (pos: number[]) => void;
    setShow: (isShow: boolean) => void;
    getData: () => {
        list: Array<{
            value: string;
            readonly: boolean;
            show?: boolean;
            pos?: number[];
        }>;
        pos: number[];
        postype: number;
    } | undefined;
}
declare class MxVueInterface {
    [x: string]: any;
    mSetCoordFun: ((coordTip: string) => void) | undefined;
    mUpdateCursorFun: ((cursorType: string) => void) | undefined;
    mOnKeydownEvent: ((arg0: any) => void) | undefined;
    mCursorType: string;
    mComandLine: MxVueComandLine;
    mdynamicInput: MxDynamicInput;
    mMxEvents: {
        [key: string]: Function;
    };
    mxFunObject: any;
    mFooterData: any;
    mLinetypeComboxData: any;
    mTitle: any;
    mTopButtonBarData: any;
    mMenuBarData: any;
    mRighButtonBarData: any;
    mLeftButtonBarData: any;
    mTitleButtonBarData: any;
    mLayerComboxData: any;
    mColorComboxData: any;
    mountSetCoordFun: (fun: ((coordTip: string) => void) | undefined) => void;
    mountUpdateCursorFun: (fun: ((cursorType: string) => void) | undefined) => void;
    mountKeydownEvent: (fun: ((arg0: any) => void) | undefined) => void;
    onKeydown: (keyCode: number) => void;
    setTipCoord: (str: any) => void;
    getCursorType: () => string;
    setCursorType: (curtype: string) => void;
    getTitle: () => any;
    getTopButtonBarData: () => any;
    getMenuBarData: () => any;
    getRighButtonBarData: () => any;
    getLeftButtonBarData: () => any;
    getTitleButtonBarData: () => any;
    getLayerComboxData: () => any;
    getColorComboxData: () => any;
    getLinetypeComboxData: () => any;
    getFooterData: () => any;
    sendStringToExecute: (sCmd: any) => void;
    getCmdLine: () => MxVueComandLine;
    getDynamicInput: () => MxDynamicInput;
    init: (mxFun: any) => void;
    OnMxEvent: (event: {
        [x: string]: any;
    }) => void;
    mountMxEvent: (name: string | number, call: any) => void;
}

declare let mxUiData: MxVueInterface;
interface CanvasParent extends HTMLElement {
    tabindex?: number;
}
interface CmdMangerType {
    McEdGetPointWorldDrawObjectClass(): any;
    getMrxDbgUiPrPointClass(): any;
}
interface MxFunType {
    createMxObject(canvasId: string, arg1: string | string[], arg2: (mxDraw: MxDrawObjectType) => void, is2d: boolean | undefined, isNewCreate?: boolean, isStaticLoad?: boolean, mapBox?: any): void;
    setMxServer(MXSERVER: string): void;
    addCommand(cmdName: string, fun: Function): void;
    sendStringToExecute(sCmd: string, ...params: any[]): boolean;
    call(cmd: string, param?: any, retfun?: Function): void;
    getCurrentDraw(): MxDrawObjectType;
    screenCoordLong2World(len: number): number;
    screenCoordLong2Doc(len: number): number;
    worldCoordLong2Doc(len: number): number;
    docCoordLong2World(len: number): number;
    docCoordLong2Screen(len: number): number;
    screenCoord2World(x: number | THREE.Vector3, y?: number, z?: number): THREE.Vector3;
    worldCoord2Screen(x: number | THREE.Vector3, y?: number, z?: number): THREE.Vector3;
    docCoord2World(x: number | THREE.Vector3, y?: number, z?: number): THREE.Vector3;
    worldCoord2Doc(x: number | THREE.Vector3, y?: number, z?: number): THREE.Vector3;
    screenCoord2Doc(x: number | THREE.Vector3, y?: number, z?: number): THREE.Vector3;
    docCoord2Screen(x: number | THREE.Vector3, y?: number, z?: number): THREE.Vector3;
    updateDisplay(): void;
    addWindowsEvent(fun: (type: string, event: any) => number): void;
    isRunningCommand(): boolean;
    zoomW(x1: number, y1: number, x2: number, y2: number, isWorld?: boolean): void;
    showLayer(idLayer: number | string, isShow: boolean, isSketch?: boolean): void;
    acutPrintf(sval: string, ...val: string[]): void;
    getCurrentMxCAD(): any;
    getQueryString(name: string): string;
    setIniset(iniObj: object): void;
    upDisplayForLayerData(dataLayers: any): boolean;
    enablStaticLoad(isStaticLoad?: boolean): void;
    setStaticServer(server: string): void;
    initUiDataObject(uiDataObj: any): void;
    loadImageMaterial(imageUrlPath: string, callResult: (material: THREE.MeshLambertMaterial) => void): void;
    initMxDbEntityType(userObject: any): void;
    initDynamicCreate(dynCreate: any): void;
    openFile(sFile: string | string[], useWebsocket: boolean): boolean;
    getMxJigCmdManager(): CmdMangerType;
    loadSVG(url: string, color?: number | string | THREE.Color, callResult?: any, loadSet?: any): void;
    getTHREE(): any;
}
declare class MxFunClass {
    constructor();
    /**
     * 创建图纸展示控件实例
     * @param canvasId 提供一个canvas元素或者唯一的ID或者class类亦或者Jquery选中的元素
     * @paramType string | HTMLCanvasElement | JQuery<HTMLElement>
     * @param cadFile 提供要展示的图纸名称
     * @paramType string
     * @param callback 图纸展示控件创建完成后的回调函数 回调参数mxDraw和dom
     * @paramType function
     * @param isNewFile 是否新建文件
     * @paramType boolean
     * @return void
     * @example
     * ``` typescript
     * Mx.MxFun.createMxObject({
     *   canvasId: "my-app",
     *   cadFile： "test2.dwg",
     *   callback(mxDraw, { canvas, canvasParent }) {
     *       console.log(mxDraw, canvas, canvasParent)
     *   },
     *   isNewFile: true
     * })
     * ```
     */
    createMxObject({ canvasId, cadFile, callback, isNewFile, useWebsocket, isAutoResize, mapBox, isMxCAD, userIdentitySign }: {
        canvasId?: string;
        cadFile?: string | string[];
        callback?: (mxDraw: MxDrawObject, dom: {
            canvas: HTMLCanvasElement;
            canvasParent: CanvasParent;
        }) => void;
        isNewFile?: boolean;
        useWebsocket?: boolean;
        isAutoResize?: boolean;
        mapBox?: any;
        isMxCAD?: boolean;
        userIdentitySign?: string;
    }): void;
    /**
     * 为程序设置服务器地址
     * @param MXSERVER 服务器地址
     * @return void
     * @example
     * ``` typescript
     * Mx.MxFun.setMxServer("ws://localhost:5090")
     * ```
     */
    setMxServer(MXSERVER?: string): void;
    /**
     * 设置加载dwg文件，直接使用html get协议加载数据，这样就不需要梦想后台服务器程序。
     * @param isStaticLoad 是否启用html get协议加载数据文件
     * @return void
     * @example
     * ``` typescript
     * Mx.MxFun.enablStaticLoad(true)
     * ```
     */
    enablStaticLoad(isStaticLoad?: boolean): void;
    /**
     * 设置加载dwg文件，直接使用html get协议加载数据时，使用的服务器地址。
     * @param server 服务网络地址.
     * @return void
     * @example
     * ``` typescript
     * Mx.MxFun.setStaticServer("http://localhost:3000/demo");
     * ```
     */
    setStaticServer(server: string): void;
    /**
     * 注册命令
     * @param cmdName 命令名
     * @param fun 命令函数
     * @return void
     * @example
     * ``` typescript
     * Mx.MxFun.addCommand("draw", ()=> {
     *   console.log("draw")
     * })
     * ```
     */
    addCommand(cmdName: string, fun: Function): void;
    /**
     * 执行命令
     * @param cmdName 命令名
     * @return boolean 命令执行成功为true
     * @example
     * ``` typescript
     * if(Mx.MxFun.sendStringToExecute("draw")) {
     *   console.log("成功执行draw命令")
     * }
     * ```
     */
    sendStringToExecute(cmdName: string, ...ages: any[]): boolean;
    /**
     * 调用后台服务程序中的NodeJS用户定义函数 后台程序使用Mx.MxFun.registFun注册用户定义函数
     * @param funName 函数名
     * @param param 函数参数
     * @param retfun 函数返回值回调
     * @return void
     * @example
     * ``` typescript
     * Mx.MxFun.call("getDrawObject", {
     *   cadFile: "test.dwg"
     * }, (res)=> {
     *   console.log(res)
     * })
     * ```
     */
    call(funName: string, param?: any, retfun?: Function): void;
    /**
     * 获取当前绘图控件对象
     * @return MxDrawObjectType 当前绘图控件对象
     * @example
     * ``` typescript
     * const mxDraw = Mx.MxFun.getCurrentDraw()
     * mxDraw.getScene()
     * ```
     */
    getCurrentDraw(): MxDrawObject;
    /**
     * 获得到当前数据库对象.
     * @return MxDbDatabase
     * @example
     * ``` typescript
     * ```
     */
    getCurrentDatabase(): MxDbDatabase;
    /**
     * 屏幕坐标长度转THREE.JS坐标长度
     * @param len 屏幕坐标长度
     * @return number THREE.JS坐标长度
     * @example
     * ``` typescript
     * const len = Mx.MxFun.screenCoordLong2World(36)
     * console.log(len)
     * ```
     */
    screenCoordLong2World(len: number): number;
    /**
     * 屏幕坐标长度转文档坐标长度
     * @param len 屏幕坐标长度
     * @return number 文档坐标长度
     * @example
     * ``` typescript
     * const len = Mx.MxFun.screenCoordLong2Doc(36)
     * console.log(len)
     * ```
     */
    screenCoordLong2Doc(len: number): number;
    /**
     * 文档坐标长度转屏幕坐标长度
     * @param len 文档坐标长度
     * @return number 屏幕坐标长度
     * @example
     * ``` typescript
     * const len = Mx.MxFun.docCoordLong2Screen(36)
     * console.log(len)
     * ```
     */
    docCoordLong2Screen(len: number): number;
    /**
     * THREE.JS坐标长度转屏幕坐标长度
     * @param len THREE.JS坐标长度
     * @return number 屏幕坐标长度
     * @example
     * ``` typescript
     * const len = Mx.MxFun.worldCoordLong2Doc(36)
     * console.log(len)
     * ```
     */
    worldCoordLong2Doc(len: number): number;
    /**
     * DWG文档坐标长度到ThreeJS坐标长度
     * @returns number
     * @example
     * ```typescript
     *
     *
     * ```
     */
    docCoordLong2World(l: number): number;
    /**
     * 屏幕坐标转THREE.JS坐标.
     * @param  x 坐标x
     * @param  y 坐标y
     * @param  z 坐标z
     * @return THREE.Vector3 THREE.JS坐标
     * @example
     * ``` typescript
     * const vector3 = Mx.MxFun.screenCoord2World(36, 21, 0)
     * console.log(vector3)
     * ```
     */
    screenCoord2World(x: number | THREE.Vector3, y?: number, z?: number): THREE.Vector3;
    /**
     * THREE.JS坐标转屏幕坐标.,屏幕坐标的Y轴向下。坐标原点在左上角.
     * @param  x 坐标x
     * @param  y 坐标y
     * @param  z 坐标z
     * @return THREE.Vector3 屏幕坐标
     * @example
     * ``` typescript
     * const vector3 = Mx.MxFun.worldCoord2Screen(36, 21, 0)
     * console.log(vector3)
     * ```
     */
    worldCoord2Screen(x: number | THREE.Vector3, y?: number, z?: number): THREE.Vector3;
    /**
     * 文档坐标转THREE.JS坐标
     * 说明： 文档坐标，THREE.JS坐标的X轴都是从左到右，Y轴是下到上,但是屏幕像素坐标系：X轴都是从左到右，Y轴是上到下
     * @param  x 坐标x
     * @param  y 坐标y
     * @param  z 坐标z
     * @return THREE.Vector3 THREE.JS坐标
     * @example
     * ``` typescript
     * const vector3 = Mx.MxFun.docCoord2World(36, 21, 0)
     * console.log(vector3)
     * ```
     */
    docCoord2World(x: number, y: number, z: number): THREE.Vector3;
    /**
     * THREE.JS坐标转文档坐标.
     * @param  x 坐标x
     * @param  y 坐标y
     * @param  z 坐标z
     * @return THREE.Vector3 文档坐标
     * @example
     * ``` typescript
     * const vector3 = Mx.MxFun.worldCoord2Doc(36, 21, 0)
     * console.log(vector3)
     * ```
     */
    worldCoord2Doc(x: number, y: number, z: number): THREE.Vector3;
    /**
     * 屏幕转文档坐标
     * @param  x 坐标x
     * @param  y 坐标y
     * @param  z 坐标z
     * @return THREE.Vector3 文档坐标
     * @example
     * ``` typescript
     * const vector3 = Mx.MxFun.screenCoord2Doc(36, 21, 0)
     * console.log(vector3)
     * ```
     */
    screenCoord2Doc(x: number | THREE.Vector3, y?: number): THREE.Vector3;
    /**
     * 文档转屏幕坐标.
     * @param  x 坐标x
     * @param  y 坐标y
     * @param  z 坐标z
     * @return THREE.Vector3 屏幕坐标
     * @example
     * ``` typescript
     * const vector3 = Mx.MxFun.docCoord2Screen(36, 21, 0)
     * console.log(vector3)
     * ```
     */
    docCoord2Screen(x: number | THREE.Vector3, y?: number): THREE.Vector3;
    /**
     * 更新显示，使用Three.js绘制了对象，调用该函数更新显示。
     * @return void
     * @example
     * ``` typescript
     * Mx.MxFun.updateDisplay()
     * ```
     */
    updateDisplay(): void;
    /**
     * 设置窗口鼠标等事件的回调操作
     * @param fun  参数1 type： 鼠标事件类型 "mouseup"鼠标释放 、"mousedown" 鼠标按下 参数2 event：事件对象 返回值: number 为0，表示事件往下传递，如果非0，表示事件已经被处理，不要往下传递了
     * @return void
     * @example
     * ``` typescript
     * Mx.MxFun.addWindowsEvent((type, event)=> {
     *   console.log(event)
     *   if(type = "mouseup") {
     *       console.log("鼠标释放")
     *   }else {
     *       console.log("鼠标按下")
     *   }
     *  // 事件往下传递
     *  // return 0
     *  // 事件已处理不再传递
     *   return -1
     * })
     * ```
     */
    addWindowsEvent(fun: (type: string, event: any) => number): void;
    /**
     * 当前是否有命令在运行
     * @return boolean
     * @example
     * ``` typescript
     * if(Mx.MxFun.isRunningCommand()) {
     *    // 当前已有命令在运行
     * }
     * ```
     */
    isRunningCommand(): boolean;
    /**
     * 窗口缩放，把指定的范围内的图形放到视区中
     * @param dLBx 矩形框范围的左下角X坐标
     * @param dLBy 矩形框范围的左下角X坐标
     * @param dRTx 矩形框范围的左下角X坐标
     * @param dRTy 矩形框范围的左下角X坐标
     * @param isWorld 传入的坐标是否是thruee.js坐标，默认传文档坐标
     * @return void
     * @example
     * ``` typescript
     * Mx.MxFun.zoomW(21, 22, 300, 310, false)
     * ```
     */
    zoomW(dLBx: number, dLBy: number, dRTx: number, dRTy: number, isWorld?: boolean): void;
    /**
     * 显示或隐藏图层
     * @param idLayer 图层id,或层名
     * @param isShow 是否显示
     * @param isSketch 暂不使用
     * @return void
     * @example
     * ``` typescript
     * Mx.MxFun.showLayer(366, true, false)
     * Mx.MxFun.showLayer("2363", fasle, false)
     * ```
     */
    showLayer(idLayer: number | string, isShow: boolean, isSketch?: boolean): void;
    /**
     * 输出字符串到命令行.
     * @param sval 输出字符串
     * @param ...val 剩余参数 命令cmd
     * @return void
     * @example
     * ``` typescript
     * Mx.MxFun.acutPrintf("{0}:", "draw")
     * ```
     */
    acutPrintf: ((sval: string, ...val: string[]) => void) | undefined;
    /**
     * 获取当前MxCAD对象,该函数在MxCAD模式下使用
     * @return MxDrawObjectType MxCAD对象
     * @example
     * ``` typescript
     * const mxcad = Mx.MxFun.getCurrentMxCAD()
     * console.log(mxcad)
     * ```
     */
    getCurrentMxCAD(): MxCADObject;
    /**
     * 得到地址栏参数
     * @param name
     * @return string 地址栏参数
     * @example
     * ``` typescript
     *  if(Mx.MxFun.getQueryString("mousetest") === "y")
     * ```
     */
    getQueryString(name: string): string;
    /**
     * 设置控件的配制参数.
     * @param name
     * @return object 配制参数.
     * @example
     * ``` typescript
     *       Mx.MxFun.setIniset({
     *           EnableIntelliSelect: true
     *       })
     * ```
     */
    setIniset(iniObj: object): void;
    /**
     * 更新图纸图层数据
     * @param dataLayers
     * @return boolean 更新成功或失败
     * @example
     * ``` typescript
     * if(Mx.MxFun.upDisplayForLayerData({
     *
     * })) {
     *   console.log("更新成功")
     * }
     * ```
     */
    upDisplayForLayerData(dataLayers: any): boolean;
    /**
     * 初始化插件的UI数据对象。
     * @param uiDataObj
     * @return
     * @example
     * ``` typescript
     * ```
     */
    initUiDataObject(uiDataObj: typeof mxUiData): void;
    /**
     * 获取UI数据对象
     * @param uiDataObj
     * @return  mxUiData
     * @example
     * ``` typescript
     * ```
     */
    getUIData(): MxVueInterface;
    /**
     * 梦想开发测试
     * @param p
     * @return any
     * @example
     * ``` typescript
     * console.log(Mx.MxFun.TestMX());
     * ```
     */
    testMX(p?: any): any;
    /**
     * 加载一个图片对象，返回Three.js材质对象，该函数具有缓存功能，下次加载同样的图片，可以直接返回.
     * @param p
     * @return any
     * @example
     * ``` typescript
     *
     * ```
     */
    loadImageMaterial(imageUrlPath: string, callResult: (material: THREE.MeshLambertMaterial) => void | null): Promise<THREE.MeshLambertMaterial | null>;
    /**
     * 重新打开cad文件，该函数在控件创建完后，需要再次重新打开文件，调用。
     * @param sFile 打的cad文件路径
     * @return any
     * @example
     * ``` typescript
     * ```
     */
    openFile(sFile: string | string[], useWebsocket?: boolean): boolean;
    /**
     * 添加一个MxDbEntity实体到当前绘图对象上。
     * @param ent  实体对象
     * @returns number 返回对象的id.
     * @example
     * ```typescript
     *
     *
     * ```
     */
    addToCurrentSpace(ent: MxDbEntity): number;
    /**
     * 在图上选择一个对象。
     * @param strPrompt  提示字符串
     * @param filter  过滤条件
     * @returns number 返回对象的id
     * @example
     * ```typescript
     *
     *
     * ```
     */
    selectEnt(strPrompt: string, filter?: any): Promise<number>;
    /**
     * 监听命令行消息动态更新的数据
     * 在取点对象中设置的命令以及我们提供的图形对象中是有一套命令提示和参数化绘图，而该回调函数主要用来监听消息变化
     * @parma callback 回调函数中data中的msCmdTip表示命令提示 msCmdText表示当前用户输入的输入内容  msCmdDisplay表示所有的消息记录
     * */
    listenForCommandLineInput(callback: ((data: {
        msCmdTip: string;
        msCmdDisplay: string;
        msCmdText: string;
    }) => void) | undefined): void;
    /**
     * 设置命令行消息数据 (在监听input输入框的onKeydown事件的回调函数中调用)
     * @param msCmdText 用户输入的数据 input输入框输入的文本信息
     * @param keyCode 按键Code input输入框的onKeydown事件的event事件对象的keyCode属性
     * */
    setCommandLineInputData(msCmdText: string, keyCode: number): void;
    /**
     * 监听指针(鼠标光标)移动变化的坐标信息
     * @parma callback 回调函数中返回坐标信息
     * */
    listenForCoordTip(callback: (coordTip: string) => void): void;
    /**
     * 监听光标更新
     * @parma cursorType当前使用的光标类型
     * */
    listenForUpdateCursor: (callback: ((cursorType: string) => void) | undefined) => void;
    /**
     * 返回mxfun.min.js中的THREE.JS对象，可以用它来创建mxfun.min.js中THREE对象。
     * */
    getMxFunTHREE(): any;
    /**
     * 返回mxfun.min.js中的ThreeJsTool对象
     * */
    getMxFunThreeTool(): any;
    /**
     * 创建十字光标图片
     * */
    ceneratecursor(cursorSize?: number, squareSize?: number, isRoss?: boolean, color?: string): HTMLImageElement;
    /**
     * 调用服务器后台CAD命令.
     * */
    callCommand(cmd: string, param: string, retCall?: (param: any) => void): any;
    /**
     * CAD坐标到文档坐标.
     * 默认情况下，cad等于doc,当前m_isCorrectLargeCoordinates为true时，doc变成了把cad图纸修改到小范围坐标系下的坐标。
     * @returns number
     * @example
     * ```typescript
     *
     *
     * ```
     */
    cadCoord2Doc(x: number, y: number, z: number): THREE.Vector3;
    /**
     * 文档坐标坐标到CAD.
     * 默认情况下，cad等于doc,当前m_isCorrectLargeCoordinates为true时，doc变成了把cad图纸修改到小范围坐标系下的坐标。
     * @returns number
     * @example
     * ```typescript
     *
     *
     * ```
     */
    docCoord2Cad(x: number, y: number, z: number): THREE.Vector3;
    /**
     * 通过id得到对象.
     * @returns 返MxDbEntity
     * @example
     * ```typescript
     *
     *
     * ```
     */
    getMxEntity(id: number): MxDbEntity | undefined;
    /**
   * 得到当前鼠标位置,返回的是屏幕坐标 。
   * @returns 返MxDbEntity
   * @example
   * ```typescript
   *
   *
   * ```
   */
    getCurrentMousePostion(): THREE.Vector3;
    /**
   * 停止运行当前命令
   * @returns
   * @example
   * ```typescript
   *
   *
   * ```
   */
    stopRunCommand(): any;
}
/**
 * MxFun 模块
 * 导出库时已实例化，只需要调用实例方法 例如：
 * ```typescript
 *  Mx.MxFun.createMxObject
 * ```
 */
declare const MxFun: MxFunClass;

declare class PubSub {
    events: {
        [x: string]: Function[];
    };
    constructor();
    /**
     * 订阅
     * @param event 事件名称
     * @param callback 事件回调
     */
    on(event: string, callback: Function): [] | number;
    /**
     * 发布
     * @param event 事件名称
     * @param data 载荷
     */
    emit<T>(event: string | number, ...data: T | any): any[];
    /**
     * 销毁事件
     * @param event 事件名称
     * @param callback 事件方法
     */
    off(event: string, callback: Function): void;
}

declare class Store<T extends {}> {
    actions: {
        [x: string | number]: Function;
    };
    mutations: {
        [x: string | number]: Function;
    };
    state: T;
    status: string;
    events: PubSub;
    constructor(params: {
        state: T;
        mutations: {
            [x: string | number]: Function;
        };
        actions: {
            [x: string | number]: Function;
        };
    });
    /**
     * 调用active方法 触发修改状态前的异步行为
     * @param actionKey 方法名称
     * @param payload 执行参数
     */
    dispatch<T>(actionKey: string | number, payload: T | any): boolean;
    /**
     * 调用mutation 的方法 修改state中属性的状态
     * @param mutationKey 方法名称
     * @param payload 执行参数
     */
    commit<T>(mutationKey: string | number, payload: T | any): boolean;
}

declare type stateType = {
    [x: string]: any;
    MxFun: MxFunType | null;
    Mxassembly: MxassemblyType | null;
    isCreateDrawObj: boolean;
};
declare const store: Store<stateType>;

/**
 * MxThreeJS 模块
 * ##### 使用说明:
 *
 * > 基于three.js实现创建直线对象、加载图片、SVG等功能，以下是使用的流程:
 * - 模块中大部分方法返回的{@link http://www.yanhuangxueyuan.com/threejs/docs/index.html#api/zh/core/Object3D | THREE.Object3D}类型继承创建的对象都可以通过取点对象{@link MrxDbgUiPrPointClass.value} 得到鼠标对应位置
 * - {@link MrxDbgUiPrPointClass.go}和{@link MrxDbgUiPrPointClass.goWhile}方法监听鼠标点击事件回调中通过
 * - {@link MxDrawObject.addObject} 方法添加到场景{@link MxDrawObject.getScene}中
 * - 最后调用{@link MxFun.updateDisplay} 更新视图显示完成
 *
 * > 提示: 在实际开发中MxThreeJS是配合着{@link MxDrawObject} 和 {@link MrxDbgUiPrPointClass} 完成绘制线段、文字、图片等功能,当然你也可以使用{@link http://www.yanhuangxueyuan.com/threejs/docs/index.html | three.js}来完成MxThreeJS模块的这些工作
 *
 * > 该模块导出库时已实例化为对象，只需要调用实例方法 例如：
 *
 * ```typescript
 * // html
 * <button id="line">line</button>
 *
 * // js
 * import Mx from "mxdraw"
 * import Three from "three"
 * Mx.loadCoreCode().then(()=> {
 *  Mx.MxFun.setMxServer()
 *  Mx.MxFun.createMxObject({
 *    callback(mxDraw, dom) {
 *      document.getElementById("line").onclick = ()=> {
 *       const getPoint = new Mx.MrxDbgUiPrPointClass()
 *       let lastPt, isLine
 *       getPoint.goWhile(()=> {
 *         const pt1 = getPoint.value()
 *         if(isLine) {
 *              const line = Mx.MxThreeJS.createLine(pt1, lastPt, 0xffffff)
 *              const currentDraw = Mx.MxFun.getCurrentDraw()
 *              currentDraw.addObject(line)
 *              Mx.MxFun.updateDisplay()
 *          }
 *          lastPt = pt1.clone()
 *          isLine = !isLine
 *       })
 *      }
 *    }
 * })
 * })
 * ```
 */
declare class MxThreeJS$1 {
    /**
     * 创建Three.js直线对象。
     * @param vPt1  {@link http://www.yanhuangxueyuan.com/threejs/docs/index.html#api/zh/math/Vector3 | THREE.Vector3} 点1
     * @param vPt2  {@link http://www.yanhuangxueyuan.com/threejs/docs/index.html#api/zh/math/Vector3 | THREE.Vector3} 点2
     * @param iColor 颜色Color
     * @returns  {@link http://www.yanhuangxueyuan.com/threejs/docs/index.html#api/zh/objects/Line |THREE.Line}
     * @example
     * ```typescript
     * Mx.MxThreeJS.createLine(new Three.Vector3(1,10,0), new Three.Vector3(1,300,0), 0)
     * ```
     */
    createLine(vPt1: THREE.Vector3, vPt2: THREE.Vector3, iColor: number | string | THREE.Color): THREE.Line;
    /**
     * 创建Three.js圆对象。
     * @param mCenterPt 圆中心点
     * @param dRadius 圆半径
     * @param iColor 颜色
     * @returns THREE.Object3D
     * @example
     * ```typescript
     * Mx.MxThreeJS.createCircle(new Three.Vector3(1,10,0), 10, 0)
     * ```
     */
    createCircle(mCenterPt: THREE.Vector3, dRadius: number, iColor: number | string | THREE.Color): THREE.Object3D;
    /**
     * 创建Three.js点对象。
     * @param mPt 点位置
     * @param iColor 颜色
     * @param size 大小
     * @returns THREE.Points
     * @example
     * ```typescript
     * Mx.MxThreeJS.createPoint(new Three.Vector3(1,10,0), 0)
     * ```
     */
    createPoint(mPt: THREE.Vector3, iColor: number | string | THREE.Color, size?: number): THREE.Points;
    /**
     * 创建Three.js 文字
     * @param message 文字信息
     * @param pt 位置
     * @param iSize 文字大小
     * @param fAngle 旋转角度
     * @param iColor 颜色
     * @returns THREE.Sprite
     * @example
     * ```typescript
     * Mx.MxThreeJS.creatTextSprite("hello",new Three.Vector3(1,10,0), 90, 60, 0)
     * ```
     */
    creatTextSprite: (message: string, pt: THREE.Vector3, iSize: number, fAngle: number, iColor: number | string | THREE.Color) => THREE.Sprite | null;
    /**
     * 计算creatTextSprite函数，创建的文字对象，的尺寸.
     * @param message 文字信息
     * @param iHeight 文字大小
     * @param iWidth 文字宽度.
     * @returns {spritewidth:number,spriteheight:number,textwidth:number,singleline:boolean}
     * @example
     * ```typescript
     *
     * ```
     */
    clacTextSpriteSize: (message: string, iHeight: number, iWidth?: number) => {
        spritewidth: number;
        spriteheight: number;
        textwidth: number;
        singleline: boolean;
    };
    /**
     * 计算文字宽度.
     * @param message 文字信息
     * @param iHeight 文字大小
     * @returns number
     * @example
     * ```typescript
     *
     * ```
     */
    clacTextSize: (message: string, iHeight: number) => number;
    /**
     * 根据三角形数组，创建Three.js Mesh
     * @param points 由三个点组成的数组
     * @param iColor 颜色
     * @param opacity 透明度
     * @returns THREE.Mesh
     * @example
     * ```typescript
     * Mx.MxThreeJS.createTriangle(
     * [new THREE.Vector3(1,2,2),new THREE.Vector3(1,65,4),new THREE.Vector3(12,2,2)],
     *  0,
     *  1
     * )
     * ```
     */
    createTriangle(points: Array<THREE.Vector3>, iColor: number | string | THREE.Color, opacity?: number): THREE.Mesh | null;
    /**
     * 创建连续直线
     * @param points 由多个点组成的数组
     * @param iColor 颜色
     * @returns THREE.Line
     * @example
     * ```typescript
     * Mx.MxThreeJS.createLines([new THREE.Vector3(1,2,2),new THREE.Vector3(1,65,4),new THREE.Vector3(12,2,2)], 0)
     * ```
     */
    createLines(points: Array<THREE.Vector3>, iColor: number | string | THREE.Color): THREE.Line;
    /**
     * 创建虚线
     * @param points 由多个点组成的数组
     * @param iColor 颜色
     * @param dashSize 短划线的大小
     * @param gapSize 短划线之间的距离
     * @returns THREE.Line
     * @example
     * ```typescript
     * Mx.MxThreeJS.createDashedLines([new THREE.Vector3(1,2,2),new THREE.Vector3(1,65,4),new THREE.Vector3(12,2,2)], 10, 20, 2)
     * ```
     */
    createDashedLines(points: Array<THREE.Vector3>, iColor: number | string | THREE.Color, dashSize: number, gapSize: number): THREE.Line;
    /**
     * 创建Image
     * @param pos 图片中心点位置,屏幕坐标，屏幕坐标的Y轴向上。坐标原点在左下角.
     * @param w 图片宽度
     * @param h 图片高度
     * @param imageUrlPath 图片URl地址
     * @param callResult 图片加载完成的回调 回调参数：THREE.Mesh
     * @returns void
     * @example
     * ```typescript
     * Mx.MxThreeJS.createImage(new THREE.Vector3(12,2,2), 10, 20, "../img/icon.png", (mesh)=> {
     *      console.log(mesh)
     * })
     * ```
     */
    createImage: (pos: THREE.Vector3, w: number, h: number, imageUrlPath: string, callResult?: (mesh: THREE.Mesh | null) => void) => void | Promise<THREE.Mesh | null>;
    /**
     * 加载SVG
     * @param url SVG路径地址,该函数具有缓存功能，下次加载同样的图片，可以直接返回.
     * @param color 颜色
     * @param callResult SVG加载完成的回调 回调参数：THREE.Object3D和Array<THREE.MeshBasicMaterial>
     * @returns void | THREE.Object3D | null
     * @example
     * ```typescript
     * Mx.MxThreeJS.loadSVG("../img/icon.svg", 10, 20, 1.5, new THREE.Color(0xff0000), (threeobj, aryMeterial)=> {
     *      console.log(threeobj, aryMeterial)
     * })
     * ```
     */
    loadSVG: (url: string, color?: number | string | THREE.Color, callResult?: (threeobj: THREE.Object3D, aryMeterial: Array<THREE.MeshBasicMaterial>) => void, loadSet?: any) => Promise<THREE.Object3D | null>;
}

declare const MxThreeJS: MxThreeJS$1;

/** @module McGeTool */

/**
 * McGeTool
 * @example ```typescript
 * ```
 */
declare class McGeToolClass {
    private mxgeTool;
    private initImp;
    /**
     * 计算闭合的区域面积
     * @param aryPoint 构成区域面积的顶点位置集合
     * @return number
     * @example
     * ```
     */
    calcArea(aryPoint: McGePoint3dArray | THREE.Vector3[]): number;
    /**
     * 判断点是否在一个闭合的多边形区域。
     * @param pt 点的坐标位置
     * @param aryPoint 闭合多边形区域的顶点坐标集合
     * @return any
     * @example
     * ``` typescript
     *      let aryPoint:Array<THREE.Vector3> = [];
     *      aryPoint.push(new THREE.Vector3(0,0,0));
     *      aryPoint.push(new THREE.Vector3(0,100,0));
     *      aryPoint.push(new THREE.Vector3(100,100,0));
     *      aryPoint.push(new THREE.Vector3(100,0,0));
     *      let pt:THREE.Vector3 = new THREE.Vector3(150,150);
     *      if(McGeTool.pointInPolyline(pt,aryPoint) ){
     *        console.log("in");
     *      }
     * ```
     */
    pointInPolyline(pt: McGePoint3d, aryPoint: McGePoint3dArray | THREE.Vector3[]): boolean;
}
declare const McGeTool: McGeToolClass;

/** @module McGeTool */

/**
 * MrxDbgUtils
 * 当常用的工具类.
 * @example ```typescript
 * ```
 */
declare class MrxDbgUtilsClass {
    private imp;
    private initImp;
    /**
     * 查找某个位置的对象.
     * @param pt 查找位置
     * @return 返回找到的对象id数组.
     * @example
     * ```
     */
    findEntAtPoint(pt: THREE.Vector3, filter?: any, mxObj?: MxDrawObject, isDocCoord?: boolean, retWordDrawXDataCall?: (id: number, data: any) => void): Promise<number[]>;
    /**
     * 交互选择对象.
     * @param strPrompt 提示字符串
     * @return 返回找到的对象id数组.
     * @example
     * ```
     */
    selectEnt(strPrompt?: string, filter?: any): Promise<number[]>;
}
declare const MrxDbgUtils: MrxDbgUtilsClass;

interface MxPaintBrushPropsType {
    /** 基础颜色 */
    color?: MxColorType;
    /** 渲染顺序 */
    renderOrder?: number;
    /** 透明度 */
    opacity?: number;
    /** 是否可见 */
    visible?: boolean;
    /** 线段宽度 */
    dLineWidth?: number;
    /** 线段宽度是否按照屏幕尺寸计算 */
    lineWidthByPixels?: boolean;
    /** 实线虚线总段数 破折号之间的长度和间距。
     * @describe
     * 0: 表示实线了, 0.1:有10段, 0.5:表示有两段 1: 有一段*/
    dashArray?: number;
    /** 虚线长度和实线长度的比率 (0 -全实线，1 -全虚线[不可见])
     * @describe
     * 例如取值为0.5, 虚线长度 / (实线长度 + 虚线长度) = 0.5,表示，实线与虚线长度相等*/
    dDashRatio?: number;
    /** 设置图层 */
    layer?: string;
    /** 自定义数据（必须保证JSON.parse(JSON.stringify(userData))不报错） */
    userData?: {
        [key: string]: any;
    };
    /** 其它自定义对象上的属性 */
    [propName: string]: any;
}
/** 自定义对象绘制时使用全局默认属性的画笔对象 */
declare const MxPaintBrush: {
    /** 获取当前的画笔属性 */
    getProps(): MxPaintBrushPropsType;
    /** 设置当前画笔属性 */
    setProps(props: MxPaintBrushPropsType): MxPaintBrushPropsType;
    /** 使用画笔设置自定义对象的默认属性
     * @param entity MxDbEntity类的实例
     *  */
    use(entity: MxDbEntity): MxDbEntity & MxPaintBrushPropsType;
};

/**
 * McEdGetPointWorldDrawObject 用于构建一个动态绘制回调对象
 * @example ```typescript
 *  Mx.McEdGetPointWorldDrawObject()
 * ```
 */
declare class McEdGetPointWorldDrawObject {
    [x: string]: any;
    private _McEdGetPointWorldDraw;
    constructor();
    /**
     * 绘制圆
     * @param cen 圆心位置
     * @param dRadius 圆半径
     * @returns void
     * @example
     * ``` typescript
     * pWorldDraw.drawCircle(new HTREE.Vector3(0,100,5), 6)
     * ```
     *
     */
    drawCircle(cen: THREE.Vector3, dRadius: number): void;
    /**
     * 绘制直线
     * @param pt1 开始点
     * @param pt2 结束点
     * @returns void
     * @example
     * ``` typescript
     * pWorldDraw.drawLine(new HTREE.Vector3(0,100,5), new HTREE.Vector3(0,600,5))
     * ```
     *
     */
    drawLine(pt1: THREE.Vector3, pt2: THREE.Vector3): void;
    /**
     * 绘制一个Three.js对象.
     * @param ent THREE.Object3D对象
     * @returns void
     * @example
     * ``` typescript
     * pWorldDraw.drawEntity(new THREE.Object3D()))
     * ```
     *
     */
    drawEntity(ent: THREE.Object3D | null, renderOrder?: number): void;
    /**
     * 绘制一个文档对象
     * @param sText 文本
     * @param iSize 大小
     * @param dAngle 角度
     * @param pt 位置
     * @returns void
     * @example
     * ``` typescript
     * pWorldDraw.drawText("字符串" ,36 ,90 ,new HTREE.Vector3(0,100,5))
     * ```
     *
     */
    drawText(sText: string, iSize: number, dAngle: number, pt: THREE.Vector3): void;
    /**
     * 设置动态绘制回调函数。
     * @param call 回调函数 currentPoint 回调参数 当前位置 pWorldDraw 回调参数文档绘制对象
     * @returns void
     * @example
     * ``` typescript
     * pWorldDraw.setDraw((currentPoint, pWorldDraw)=> {
     *
     * })
     * ```
     */
    setDraw(call: (currentPoint: THREE.Vector3, pWorldDraw?: any) => void): void;
    /**
     * 设置绘制对象颜色.
     * @param iColor 颜色
     * @returns void
     * @example
     * ``` typescript
     * pWorldDraw.setColor(0xFFFFFF)
     * ```
     */
    setColor(iColor: number | string | THREE.Color): void;
    /**
     * 得到绘制对象颜色.
     * @returns 颜色
     * @example
     * ``` typescript
     * pWorldDraw.getColor()
     * ```
     */
    getColor(): void;
    /**
     * 动态绘制一个自定义实体
     * @returns
     * @example
     * ``` typescript
     *
     * ```
     */
    drawCustomEntity(ent: any, renderOrder?: number): void;
}

/** @module MrxDbgUiPrBaseReturn*/
/**
 * MrxDbgUiPrBaseReturn枚举
 * @description
 * 用于适配{@link MrxDbgUiPrPoint.go} 和 {@link MrxDbgUiPrPoint.goWhile} 方法中的回调参数`status`
 * @example
 * ```
 * const Point = new Mx.MrxDbgUiPrPoint()
 * Point.go((status)=> {
 *  if(Mx.MrxDbgUiPrBaseReturn.kCancel === status) {
 *    // 取消
 *  }
 * })
 *
 * ```
 * @enum
 * */
declare enum MrxDbgUiPrBaseReturn {
    /** 取消 */
    kCancel = -2,
    /** 空输入，当输入关键字和实体时会返回此值 */
    kNone = -1,
    /** 获取用户输入成功 */
    kOk = 0,
    /** 用户输入了关键字*/
    kKeyWord = 1
}

/** @module MrxDbgUiPrPointClass */

/**
 * MrxDbgUiPrPoint 用于构建一个取点对象
 * @example ```typescript
 *  new Mx.MrxDbgUiPrPoint()
 * ```
 */
declare class MrxDbgUiPrPoint {
    constructor();
    /**
     * 返回关键字列表
     * @returns 关键词列表
     */
    keyWords(): string;
    /**
     * 设置关键字列表
     * @param keyWordList 关键词列表
     * @returns void
     */
    setKeyWords(keyWordList: string): void;
    /**
     * 提示字符串
     * @returns 提示消息
     */
    message(): string;
    /**
     * 设置提示字符串
     * @param message 提示消息
     * @returns 提示消息
     */
    setMessage(message: string): void;
    /**
     * 返回用户选择的关键字
     * @returns 选择的关键字
     */
    keyWordPicked(): string;
    /**
     * 测试某一个关键字是否被用户选择
     * @param matchKeyWord 要检测的关键字
     * @returns true为真
     */
    isKeyWordPicked(matchKeyWord: string): boolean;
    /**
     * 设置交互过程的动态绘制调用对象
     * @param pDraw {@link McEdGetPointWorldDrawObject | 动态绘制调用对象}
     * @returns void
     */
    setUserDraw(pDraw: McEdGetPointWorldDrawObject | ((currentPoint: THREE.Vector3, pWorldDraw: McEdGetPointWorldDrawObject) => void)): void;
    /**
     * 得以获取的点对象，Three.js坐标
     * @returns 点对象 THREE.THREE.Vector3
     */
    value(): THREE.Vector3;
    /**
     * 得以获取的点对象，DWG图纸坐标.
     * @returns 点对象 DWG图纸坐标
     */
    valueDocCoord(): THREE.Vector3;
    /**
     * 得到动态拖动的基点
     * @returns 基点 THREE.THREE.Vector3
     */
    basePt(): THREE.Vector3;
    /**
     * 设置动态拖动的基点
     * @param basePt 基点 THREE.THREE.Vector3
     * @returns 点对象 DWG图纸坐标
     */
    setBasePt(basePt: THREE.Vector3): void;
    /**
     * 设置使用动态拖动的基点
     * @param useIt 是否设置 默认为false
     * @returns void
     */
    setUseBasePt(useIt: boolean): void;
    /**
     * 开始动态拖动
     * @param retcall  回调参数status {@link MrxDbgUiPrBaseReturn | 状态值}
     * @returns void
     */
    go(retcall?: (status: MrxDbgUiPrBaseReturn) => void): Promise<THREE.Vector3 | null>;
    /**
     * 动态拖动，连续取点，直到ESC退出。
     * @param retcall 回调参数status {@link MrxDbgUiPrBaseReturn | 状态值}
     * @param exitcall 回调参数status {@link MrxDbgUiPrBaseReturn | 状态值}
     * @returns void
     */
    goWhile(retcall: (status: MrxDbgUiPrBaseReturn) => any, exitcall?: (status: MrxDbgUiPrBaseReturn) => any): void;
    /**
     * 把动态绘制的对象，保留到图上。
     * @param callAddEntity 回调参数ent 类型：THREE.THREE.Object3D
     * @returns 点对象 DWG图纸坐标
     */
    drawReserve(callAddEntity?: (ent: THREE.Object3D) => void): void;
    /**
     * 设置需要的Touche输入类型,默认值是 {@link MxType.InputToucheType.kGetBegan}
     *
     */
    setInputToucheType(toucheType: number): void;
    /**
     * 返回需要的Touche输入类型
     */
    getInputToucheType(): number;
}

declare function drawMxDbImage(): void;

/**
 * MxDbImage 图片对象.
 */
declare class MxDbImage extends MxDbEntity {
    static cmd: string;
    static draw: typeof drawMxDbImage;
    private pt1;
    private pt2;
    private imagePath;
    private isLoadMaterialFromPath;
    private material;
    private angle;
    getTypeName(): string;
    /** 返回图片的旋转角度,相对图片中心点旋转.
     * @param
     * */
    getAngle(): number;
    /** 设置图片的旋转角度,相对图片中心点旋转.
     * @param
     * */
    setAngle(angle: number): void;
    worldDraw(pWorldDraw: McGiWorldDraw): void;
    /** 设置图片路径
     * @param sPath 路径
     * */
    setImagePath(sPath: string): void;
    /** 获取图片路径 */
    getImagePath(): string;
    /** 设置图片材质
     * @param material  THREE.MeshLambertMaterial
     * */
    setMaterial(material: THREE.MeshLambertMaterial): void;
    /** 加载图片材质
     * */
    loadMaterial(imagePath?: string): void;
    /** 设置图片对角点1
     * @param pt1 THREE.Vector3坐标点
     * */
    setPoint1(pt1: THREE.Vector3): void;
    /** 获得图片对角点1 */
    getPoint1(): THREE.Vector3;
    /** 设置图片对角点2
     * @param pt2 THREE.Vector3坐标点
     *  */
    setPoint2(pt2: THREE.Vector3): void;
    /** 获得图片对角点2 */
    getPoint2(): THREE.Vector3;
    getGripPoints(): Array<THREE.Vector3>;
    moveGripPointsAt(index: number, offset: THREE.Vector3): boolean;
    dwgIn(obj: any): boolean;
    dwgOut(obj: any): object;
    create(): MxDbEntity;
}

/** @module MxDbSVG*/
/**
 * MxDbSVGText 为SVG提供文字数据
 * */
declare class MxDbSVGText {
    /** 文字的位置 */
    txtPos: THREE.Vector3;
    /** 文字内容 */
    txt: string;
    /** 文字高度 */
    txtHeight: number;
    /** 文字颜色 */
    color: number | string | THREE.Color | undefined;
    /** THREE.Sprite */
    _txtObject: THREE.Sprite | null;
    /** 比例 */
    _txtAspectRatio: number;
    /** 文字是否能独立移动 */
    move: boolean;
    /** 文字移动到距图片远处，自动绘制一个连接线 */
    drawConnectingLine: boolean;
    /** 连接线的临时绘制对象 */
    _connectingLine: THREE.Line | null;
    /** 字体样式 */
    fontStyle: string;
    /** 下划线 */
    underline: boolean;
    /** 下划线的临时绘制对象 */
    _underLine: THREE.Line | null;
}

declare function drawMxDbSVG(): Promise<void>;

/**
 * MxDbSVG 绘制SVG图形.
 */
declare class MxDbSVG extends MxDbEntity {
    static cmd: string;
    static draw: typeof drawMxDbSVG;
    private svgPos;
    private svg;
    private svgPath;
    private svgSize;
    private svgAlignmentRatio;
    /** 延z轴旋转的数值 */
    svgRotate: number;
    /** 是否倒置SVG图形 */
    svgReverse: boolean;
    svgMirror: boolean;
    private svgChildColor;
    svgMargin: THREE.Vector2;
    private isSvgDirtyLocation;
    private isLoadFromPath;
    private aryText;
    private svgBoxSize;
    /** 固定尺寸，图片和文字大小，取屏幕像素绘图单位。 */
    fixedSize: boolean;
    /**使用svg的颜色 */
    useSvgColor: boolean;
    setSvgChildColor(aryColor: number[]): void;
    getSvgChildColor(): number[];
    private calcVewSize;
    private calcSvgDrawRect;
    worldDraw(pWorldDraw: McGiWorldDraw): void;
    /**
     * 设置SVG的路径
     * @param path 路径
     * @param preload 是否提前加载SVG
     * */
    setSvgPath(path: string, preload?: boolean): Promise<void>;
    /**
     * 获取SVG的路径
     * */
    getSvgPath(): string;
    /**
     * 设置SVG显示位置
     * @param pos  THREE.Vector3
     * */
    setSvgPostion(pos: THREE.Vector3): void;
    /**
     * 获取SVG显示位置
     * */
    getSvgPostion(): THREE.Vector3;
    /**
     * 设置SVG大小
     * @param size THREE.Vector2 x表示宽度y表示高度
     * */
    setSvgSize(size: THREE.Vector2): void;
    getSvgSize(): THREE.Vector2;
    /** 设置SVG 的调整比例
     * @param alignmentRatio THREE.Vector2
     *  */
    setSvgAlignmentRatio(alignmentRatio: THREE.Vector2): void;
    getSvgAlignmentRatio(): THREE.Vector2;
    /** 获取文字数组下标中的文字
     * @param index 数组下标
     * @return {@link MxDbSVGText}
     *  */
    getText(index: number): MxDbSVGText | null;
    /** 添加文字
     * @param txt {@link MxDbSVGText}
     *  */
    addText(txt: MxDbSVGText): void;
    getGripPoints(): Array<THREE.Vector3>;
    moveGripPointsAt(index: number, offset: THREE.Vector3): boolean;
    private calcSvgPosition;
    dwgIn(obj: any): boolean;
    dwgOut(obj: any): object;
    create(): MxDbSVG;
    transformBy(mat: THREE.Matrix4): void;
    getTypeName(): string;
    /**
     * 设置颜色
     * @param color 颜色值
     * */
    setColor(color: number | string | THREE.Color): this;
    /**
     * 设置svg对象
     * */
    setSvg(svg: any): void;
    private calcSvgBoxSize;
    reComputeSVG(): void;
    protected onViewChange(): boolean;
}

declare function drawMxDbPolyline(): void;

/**
 * MxDbPolyline 多义线对象(多个点构成的线段)
 */
declare class MxDbPolyline extends MxDbEntity {
    static cmd: string;
    static draw: typeof drawMxDbPolyline;
    /** 顶点位置集合 */
    points: THREE.Vector3[];
    getTypeName(): string;
    worldDraw(pWorldDraw: McGiWorldDraw): void;
    getGripPoints(): THREE.Vector3[];
    moveGripPointsAt(index: number, offset: THREE.Vector3): boolean;
    create(): MxDbEntity;
    dwgIn(obj: any): boolean;
    dwgOut(obj: any): object;
    /** 添加顶点位置 */
    addVertexAt(pt: THREE.Vector3): void;
    /** 顶点数量 */
    numVerts(): number;
    getPointAt(index: number): THREE.Vector3 | null;
    /**  设置顶点
     * @param index 替换的顶点在当前points集合的下标位置
     * @param pt 要替换设置的顶点
     *  */
    setPointAt(index: number, pt: THREE.Vector3): boolean;
}

declare function drawMxDb2LineAngularDimension(): MxDb2LineAngularDimension;

declare class MxDb2LineAngularDimension extends MxDbEntity {
    static cmd: string;
    static draw: typeof drawMxDb2LineAngularDimension;
    /**
     * MxDb2LineAngularDimension
     * 显示角度测量的图形
     * @param  options.points [point1(起始点)、point2(角顶点)、point3(结束点)]
     * @param  options.colors [起始线段颜色, 结束线段颜色, 标注角度圆弧颜色, 文字标注的角度颜色]
     * @example
     * ``` typescript
     * const draw = Mx.MxFun.getCurrentDraw();
     * const points = [ getPoint.value(),
     *          getPoint.value().add(new THREE.Vector3(8880, 0, 0)),
     *          getPoint.value().add(new THREE.Vector3(0, 6666, 0)),
     *       ]
     * const colors = ['#F00880','#00ff1a', void 0, 0XFF0000]
     * const obj = new Mx.MxDb2LineAngularDimension().setPoints(points).setColor(colors).setLineWidth(6)
     * draw.addMxEntity(obj)
     * ```
     **/
    constructor(options?: {
        /** 传入三个位置THREE向量 分别对应 属性: point1(起始点)、point2(角顶点)、point3(结束点) 计算角度 */
        points?: THREE.Vector3[];
        /**  colors 各标注的颜色设置:
         * [起始线段颜色, 结束线段颜色, 标注角度圆弧颜色, 文字标注的角度颜色]
         * 某一项为null或undefined采用绘制颜色 */
        colors?: UnstableColor[];
    });
    point1: three.Vector3;
    point2: three.Vector3;
    point3: three.Vector3;
    /**
     * colors 各标注的颜色设置:
     * [起始线段颜色, 结束线段颜色, 标注角度圆弧颜色, 文字标注的角度颜色]
     * 某一项为null或undefined采用绘制颜色
     * */
    colors: UnstableColor[];
    private calculateLineAngle;
    /**
     * 设置point1 、 point2、point3 向量位置
     * @param { THREE.Vector3[] } points
     */
    setPoints(points: THREE.Vector3[]): this;
    /**
     * 设置颜色组合
     * @param colors [起始线段颜色, 结束线段颜色, 标注角度圆弧颜色, 文字标注的角度颜色]
     * 某一项为null或undefined采用绘制颜色 || 单颜色
     * */
    setColor(colors: UnstableColor[] | MxColorType): this;
    worldDraw(pWorldDraw: McGiWorldDraw): void;
    getGripPoints(): three.Vector3[];
    moveGripPointsAt(index: number, offset: THREE.Vector3): boolean;
    dwgIn(obj: any): boolean;
    dwgOut(obj: any): any;
    create(): MxDb2LineAngularDimension;
    transformBy(mat: THREE.Matrix4): void;
    getTypeName(): string;
}

/** 简单颜色滤镜矩阵 */
interface ChannelParamTypes {
    r?: number;
    g?: number;
    b?: number;
}
declare class MxFilters {
    private uniformObj;
    private filtersStr;
    private filtersTypes;
    private VSHADER_SOURCE;
    private FSHADER_SOURCE;
    private _matrix;
    /**
     * 过滤或增强某个颜色通道
     * @param {ChannelParamTypes}
     * */
    channel({ r, g, b }: ChannelParamTypes): this;
    /**
     * 改变亮度
     * @param {number} p
     * p = 0 全暗，p > 0 且 p < 1 调暗，p = 1 原色， p > 1 调亮
     * */
    brightness(p: number): this;
    /**
     * 饱和度
     * @param {number} p
     * p = 0 完全灰度化，p = 1 原色，p > 1 增强饱和度
     * */
    saturate(p: number): this;
    /**
     * 对比度
     * @param {number} p
     *  p = 1 原色， p < 1 减弱对比度，p > 1 增强对比度
     * */
    contrast(p: number): this;
    /**
     * 透明度
     * @param {number} p
     * p = 0 全透明，p = 1 原色
     * */
    opacity(p: number): this;
    /**
     * 反色
     * @param {number} p
     * p = 0 原色， p = 1 完全反色
     * */
    invert(p: number): this;
    /**
     * 灰度
     * @param {number} p 0~1
     * */
    grayscale(p?: number): this;
    /**
     * 深褐色
     * @param {number} p 0~1
     * */
    sepia(p?: number): this;
    /**
     * 色相旋转，将色调沿极坐标转过deg角度
     * @param {number} deg 0~360
     * */
    hueRotate(deg: number): this;
    /**
     * 色相旋转，将色调沿极坐标转过deg角度
     * @param {number} deg 0~360
     * */
    /**
     * 卷积
     * @param {Matrix3} cKernel 3*3的矩阵
     * @param {number} stStep 1 / 9
     * @param {number} scaleFactor 521
     * */
    convolution(cKernel: THREE.Matrix3, stStep?: number, scaleFactor?: number): this;
    /**
     * 重置所有滤镜效果
     * */
    reset(): this;
    _getFilterShaderData(texture: THREE.Texture): {
        uniforms: {
            e_Texture: {
                value: three.Texture;
            };
            colorMatrix: {
                value: three.Matrix4;
            };
        };
        vertexShader: string;
        fragmentShader: string;
    };
    _getFilterColor(color?: string | number | THREE.Color, opacity?: number): three.Color;
    /** 转成JSON字符串 */
    toJSON(): string;
    /** 还原序列化的数据 */
    static fromJSON(json: string): MxFilters;
}

/** 动态绘制形状
 * 基于THREE.Shape计算实现的形状
 * 通过扩展可以实现各种2d 3d形状
 *  **/
declare class MxDbShape extends MxDbEntity {
    protected _paths: THREE.CurvePath<THREE.Vector3 | THREE.Vector2>;
    protected points: THREE.Vector3[];
    protected closedLine: THREE.Curve<THREE.Vector3>;
    protected isLoadMaterialFromPath: boolean;
    protected material: THREE.MeshLambertMaterial | null;
    /** 描边颜色 */
    stroke: UnstableColor;
    setStroke(stroke: UnstableColor): this;
    /** 描边线段的宽度 */
    strokeLineWidth: number;
    setStrokeLineWidth(strokeLineWidth: number): this;
    /** 描边是否为虚线 */
    isStrokeDashLine: boolean;
    setIsStrokeDashLine(isStrokeDashLine: boolean): this;
    /** 填充 */
    isFill: boolean;
    setIsFill(isFill: boolean): this;
    /** 填充图片路径 */
    protected _fillImageSrc: string | false | null;
    get fillImageSrc(): string | false | null;
    set fillImageSrc(src: string | false | null);
    setFillImageSrc(fillImageSrc: string): this;
    /**
    * fillImageParam 填充背景图片的参数设置(如果使用了滤镜则部分参数功能失效)
    * */
    fillImageParam: {
        offset?: THREE.Vector2;
        repeat?: THREE.Vector2;
        rotation?: number;
        center?: THREE.Vector2;
    } | undefined;
    /** 线段细分数值 */
    curveSegments: number;
    setCurveSegments(curveSegments: number): this;
    /** 闭合 */
    closed: boolean;
    setClosed(closed: boolean): this;
    /**
     * 设置滤镜对象{@link MxFilters} 默认为undefined | null 则不使用该滤镜效果
     * */
    filter: MxFilters | undefined | null;
    /** 圆角半径 (一个向量点对应一个角的半径值)*/
    cornerRadius: number[] | number;
    /**
     * 设置圆角 圆角的半径（如果参数为数组则一个角度对应一个圆角半径）
     * @param { number | number[] } radius 圆角半径 为数组时[3, 2, 1, 4]分别对应左上角圆角半径3  右上角2  右下角1 左下角4； 或者直接设置半径值 则四个角统一半径
     * */
    setCornerRadius(radius: number | number[], isScreenCoord?: boolean): void;
    /** 需要输入和输出的属性 */
    protected _propertyDbKeys: string[];
    getTypeName(): string;
    /** 获取坐标集合 */
    getShapePoints(paths: THREE.CurvePath<THREE.Vector3 | THREE.Vector2>): three.Vector3[];
    /*** 创建路径 */
    createPaths(shapes: THREE.Curve<THREE.Vector3 | THREE.Vector2> | THREE.Curve<THREE.Vector3 | THREE.Vector2>[]): three.CurvePath<three.Vector3 | three.Vector2>;
    /** 动态绘制函数*/
    _draw(pWorldDraw: McGiWorldDraw, vertices: THREE.Vector3[]): void;
    /** 获取生成圆角后的点 */
    getCornerRadiusPoints(points: THREE.Vector3[]): three.Vector3[];
    /** 绘制描边 */
    _drawStoreLine(pWorldDraw: McGiWorldDraw, points: THREE.Vector3[], draw?: (pWorldDraw: McGiWorldDraw) => void): void;
    /** 获取线段闭合后的曲线点数 */
    getClosedPoints(points: THREE.Vector3[]): three.Vector3[];
    /** 获取长度 */
    getTotalLength(): number;
    /** 获取面积 */
    getArea(): number;
    worldDraw(pWorldDraw: McGiWorldDraw): void;
    /** 图片填充 */
    _fillImg(pWorldDraw: McGiWorldDraw, points: THREE.Vector3[]): void;
    getGripPoints(): THREE.Vector3[];
    moveGripPointsAt(index: number, offset: THREE.Vector3): boolean;
    dwgIn(obj: any): boolean;
    dwgOut(obj: any): object;
}

/*** 椭圆(弧)形状 */
declare class MxDbEllipseShape extends MxDbShape {
    constructor();
    getTypeName(): string;
    /** 弧中心点 */
    center: three.Vector3;
    setCenter(center: THREE.Vector3): this;
    /** X轴椭圆弧半径 默认当前坐标转换下的10像素 */
    xRadius: number;
    setXRadius(xRadius: number): this;
    /**  Y轴椭圆弧半径 默认当前坐标转换下的10像素 */
    yRadius: number;
    setYRadius(yRadius: number): this;
    /** 弧开始角度 默认0*/
    startAngle: number;
    setStartAngle(startAngle: number): this;
    /** 弧结束角度 默认0*/
    endAngle: number;
    setEndAngle(endAngle: number): this;
    /** 以顺时针方向创建（扫过）弧线 默认false */
    clockwise: boolean;
    setClockwise(clockwise: boolean): this;
    /** 旋转角度 */
    rotation: number;
    setRotation(rotation: number): this;
    /** 是否闭合到中心位置 */
    isClosedToCenter: boolean;
    setIsClosedToCenter(isClosedToCenter: boolean): this;
    worldDraw(pWorldDraw: McGiWorldDraw): void;
    /** 绘制椭圆形状 */
    drawEllipseShape(pWorldDraw: McGiWorldDraw): {
        /** 圆心角 */
        centralAngle: number;
        /** 圆弧曲线 */
        curve: three.EllipseCurve;
        /** 构成圆弧的向量点 */
        points: three.Vector3[];
    };
    /** 创建圆弧 */
    createEllipseCurve(x?: number, y?: number, xRadius?: number, yRadius?: number, startAngle?: number, endAngle?: number, clockwise?: boolean, rotation?: number): three.EllipseCurve;
    /** 获取圆角的点集合(椭圆不需要) */
    getCornerRadiusPoints(points: THREE.Vector3[]): three.Vector3[];
    getClosedPoints(points: THREE.Vector3[]): THREE.Vector3[];
    getClosedLine(points: THREE.Vector3[]): three.CatmullRomCurve3;
    getGripPoints(): three.Vector3[];
    moveGripPointsAt(index: number, offset: THREE.Vector3): boolean;
}

/*** 圆(弧)形状 */
declare class MxDbCircleShape extends MxDbEllipseShape {
    getTypeName(): string;
    /*** 圆半径 */
    get radius(): number;
    set radius(radius: number);
    setRadius(radius: number): this;
    setXRadius(xRadius: number): this;
    setYRadius(yRadius: number): this;
}

declare function drawMx3PointArc(): void;

/** 三点动态绘制圆弧 point1圆弧起始点 point2是圆弧结束点, point3圆弧任意一点  */
declare class Mx3PointArc extends MxDbCircleShape {
    static cmd: string;
    static draw: typeof drawMx3PointArc;
    constructor();
    point1: three.Vector3;
    point2: three.Vector3;
    point3: three.Vector3;
    /** 自动确定顺逆时针绘制 */
    autoClockwise: boolean;
    getTypeName(): string;
    create(): Mx3PointArc;
    worldDraw(pWorldDraw: McGiWorldDraw): void;
    getGripPoints(): THREE.Vector3[];
    /** 计算三个控制点的角度 */
    compute3PointAngle(): number[];
    /** 根据三个控制点更新圆心 */
    upDateCenter(point1: THREE.Vector3, point2: THREE.Vector3, point3: THREE.Vector3): three.Vector3;
    /** 根据圆心和一个控制点自动更新半径大小 */
    upDateRadius(point: THREE.Vector3): number;
    /** 根据 三个控制点到圆心的角度  更新顺逆时针绘制 */
    upDataClockwise(angle1: number, angle2: number, angle3: number): void;
    moveGripPointsAt(index: number, offset: THREE.Vector3): boolean;
}

declare function drawMxDbCoord(): void;

/**
 * MxDbCoord 引线坐标测量
 */
declare class MxDbCoord extends MxDbEntity {
    static cmd: string;
    static draw: typeof drawMxDbCoord;
    /** 测量点位置 */
    point1: THREE.Vector3;
    /** 测量结果显示位置 */
    point2: THREE.Vector3;
    worldDraw(pWorldDraw: McGiWorldDraw): void;
    getGripPoints(): Array<THREE.Vector3>;
    moveGripPointsAt(index: number, offset: THREE.Vector3): boolean;
    dwgIn(obj: any): boolean;
    dwgOut(obj: any): object;
    create(): MxDbEntity;
    transformBy(mat: THREE.Matrix4): void;
    getTypeName(): string;
}

/** 绘制 MxDbLine */
declare function drawMxDbLine(): Promise<void>;

/**
 * MxDbLine 直线对象.
 */
declare class MxDbLine extends MxDbEntity {
    static cmd: string;
    static draw: typeof drawMxDbLine;
    /** 直线的开始点 */
    pt1: THREE.Vector3;
    /** 直线的结束点 */
    pt2: THREE.Vector3;
    getTypeName(): string;
    worldDraw(pWorldDraw: McGiWorldDraw): void;
    /** 设置的开始点 */
    setPoint1(pt1: THREE.Vector3): void;
    getPoint1(): THREE.Vector3;
    /** 设置的结束点 */
    setPoint2(pt2: THREE.Vector3): void;
    getPoint2(): THREE.Vector3;
    getGripPoints(): Array<THREE.Vector3>;
    moveGripPointsAt(index: number, offset: THREE.Vector3): boolean;
    dwgIn(obj: any): boolean;
    dwgOut(obj: any): object;
    create(): MxDbEntity;
    getGeomExtents(): THREE.Box3 | null;
    /**
     * 返回曲线长度.
     * @returns number
     */
    getGetLength(): number;
}

declare function drawMxDbRect(): Promise<void>;

/**
 * MxRectEntity 矩形对象.
 */
declare class MxDbRect extends MxDbEntity {
    static cmd: string;
    static draw: typeof drawMxDbRect;
    private cornerRadius;
    /**
     * pt1: 构成矩形的第一个点
     * */
    pt1: THREE.Vector3;
    /**
     * pt1: 构成矩形的第二个点(对角点)
     * */
    pt2: THREE.Vector3;
    /**
     * 是否需要颜色填充.
     * */
    isSolidColorFill: boolean;
    /**
     * fillImageParam 填充背景图片的参数设置(如果使用了滤镜则部分参数功能失效)
     * */
    private fillImageParam;
    /**
     * 设置滤镜对象{@link MxFilters} 默认为undefined | null 则不使用该滤镜效果
     * */
    private filter;
    /**
     * fillImageSrc(优先级低于fillColor属性) 填充背景图片的地址
     * */
    private fillImageSrc;
    private isLoadMaterialFromPath;
    private material;
    worldDraw(pWorldDraw: McGiWorldDraw): void;
    getGripPoints(): Array<THREE.Vector3>;
    moveGripPointsAt(index: number, offset: THREE.Vector3): boolean;
    dwgIn(obj: any): boolean;
    dwgOut(obj: any): object;
    create(): MxDbRect;
    transformBy(mat: THREE.Matrix4): void;
    /**
     * setRadius 设置圆角 圆角的半径  如[3, 2, 1, 4]分别对应左上角圆角半径3  右上角2  右下角1 左下角4
     * @param { number | number[] } radius 圆角半径 为数组时[3, 2, 1, 4]分别对应左上角圆角半径3  右上角2  右下角1 左下角4； 或者直接设置半径值 则四个角统一半径
     * */
    setRadius(radius: number | number[], isScreenCoord?: boolean): void;
    getTypeName(): string;
    /** 获取当前滤镜对象 {@link MxFilters} */
    getFilter(): MxFilters | undefined | null;
    /** 设置当前滤镜对象
     * @param filter {@link MxFilters}
     *  */
    setFilter(filter: MxFilters | undefined | null): void;
    /** 设置填充的背景图片路径 */
    setFillImagePath(sPath: string | undefined): void;
    /** 获取填充的背景图片路径 */
    getFillImagePath(): string | undefined;
}

declare function drawMxDbAlignedDimension(): MxDbAlignedDimension;

/** @module MxDbAlignedDimension*/

/**
 * MxDbAlignedDimension 尺寸标注
 */
declare class MxDbAlignedDimension extends MxDbEntity {
    static cmd: string;
    static draw: typeof drawMxDbAlignedDimension;
    /**
     * MxDbAlignedDimension
     * 尺寸标注
     * @param options.points 提供两个向量测量尺寸
     * @param options.fontColor 字体颜色
     * @example ```typescript
     * const draw = Mx.MxFun.getCurrentDraw();
     * const v3 = new THREE.Vector3()
     * const points = [v3 , v3.clone().add(new THREE.Vector3(8880, 0, 0))]
     * const colors = ['#F00880','#00ff1a']
     * draw.addMxEntity(
     *   new Mx.MxDbAlignedDimension({ points })
     *   .setColor(colors)
     *   .setLineWidth(6)
     * )
     * ```
     **/
    constructor(options?: {
        /** [point1, point2] 两个向量位置 */
        points?: THREE.Vector3[];
        /** 字体颜色 */
        fontColor?: MxColorType;
    });
    point1: THREE.Vector3;
    point2: THREE.Vector3;
    fontColor: UnstableColor;
    /**
     * 设置两个点位置向量
     * @param { THREE.Vector3[] } points [THREE.Vector3, THREE.Vector3]
     */
    setPoints(points: THREE.Vector3[]): void;
    getTypeName(): string;
    private getDirection;
    /**
     * 获取尺寸距离
     * */
    getDimText(): string;
    worldDraw(pWorldDraw: McGiWorldDraw): void;
    /**
     * 设置测量的开始点
     * @parma pt1 three.js坐标点位
     * */
    setPoint1(pt1: THREE.Vector3): void;
    /**
     * 设置测量的结束点
     * @parma pt1 three.js坐标点位
     * */
    setPoint2(pt2: THREE.Vector3): void;
    setColor(color: UnstableColor | UnstableColor[]): this;
    getGripPoints(): Array<THREE.Vector3>;
    moveGripPointsAt(index: number, offset: THREE.Vector3): boolean;
    dwgIn(obj: any): boolean;
    dwgOut(obj: any): object;
    create(): MxDbAlignedDimension;
}

declare function drawMxDbArea(): void;

/**
 * MxDbArea 任意不规则多边形
 * */
declare class MxDbArea extends MxDbEntity {
    static cmd: string;
    static draw: typeof drawMxDbArea;
    /** 构成多边形的顶点集合 */
    points: Array<THREE.Vector3>;
    isFill: boolean;
    fillColor: MxColorType;
    fillOpacity: number;
    getTypeName(): string;
    create(): MxDbEntity;
    /** 在worldDraw动态绘制时会计算当前顶点坐标集合的面积,并显示渲染计算后的计算结果
     * @returns 返回的计算后的面积结果
     *  */
    getDimText(): string;
    worldDraw(pWorldDraw: McGiWorldDraw): void;
    getGripPoints(): Array<THREE.Vector3>;
    moveGripPointsAt(index: number, offset: THREE.Vector3): boolean;
    dwgIn(obj: any): boolean;
    dwgOut(obj: any): object;
    /**
     * 添加构成多边形的点
     * @param pt 位置坐标
     *  */
    addPoint(pt: THREE.Vector3): void;
    /**
     * 获取构成多边形的顶点集合
     *  */
    getPoints(): Array<THREE.Vector3>;
    /**
     * 清空构成多边形的顶点集合
     *  */
    clearPoint(): void;
}

declare function drawMxDbLeadTag(): Promise<void>;

/**
 * MxDbLeadTag 引出标注
 * */
declare class MxDbLeadTag extends MxDbEntity {
    static cmd: string;
    static draw: typeof drawMxDbLeadTag;
    point: three.Vector3;
    leadLen: number;
    text: string;
    textHeight: number;
    getTypeName(): string;
    private createDots;
    worldDraw(pWorldDraw: McGiWorldDraw): void;
    getGripPoints(): THREE.Vector3[];
    onViewChange(): boolean;
    moveGripPointsAt(index: number, offset: THREE.Vector3): boolean;
    dwgIn(obj: any): boolean;
    dwgOut(obj: any): any;
}

declare function drawMxDbAnyLine(): void;

/** @module MxDbAnyLine*/

/**
 * MxDbAnyLine
 * 任意线段
 */
declare class MxDbAnyLine extends MxDbEntity {
    static cmd: string;
    static draw: typeof drawMxDbAnyLine;
    /** 构成线段的顶点坐标集合 */
    points: THREE.Vector3[];
    getTypeName(): string;
    create(): MxDbAnyLine;
    worldDraw(pWorldDraw: McGiWorldDraw): void;
    /** 设置线段points
     * @param points 构成线段的多个点
     */
    setPoints(points: THREE.Vector3[]): this;
    /** 获取线段的包围盒的中心点坐标 */
    getCenter(): THREE.Vector3;
    getGripPoints(): THREE.Vector3[];
    moveGripPointsAt(index: number, offset: THREE.Vector3): boolean;
    dwgIn(obj: any): boolean;
    dwgOut(obj: any): object;
}

declare function drawMxDbCloudLine(): void;

/**
 * MxDbCloudLine 对象. 绘制任意的云线
 */
declare class MxDbCloudLine extends MxDbEntity {
    static isRegister: boolean;
    static cmd: string;
    static draw: typeof drawMxDbCloudLine;
    private points;
    private radius;
    private cachePoint;
    getTypeName(): string;
    create(): MxDbEntity;
    /** 设置构成云线的每个圆弧半径长度
     * @parma radius 圆弧半径
     *  */
    setRadius(radius: number): void;
    /**
     * 获取云线的圆弧半径
     * */
    getRadius(): number;
    getCachePoint(): THREE.Vector3[] | null;
    private clacNewArcDiameterPoint;
    private createCloudArcCurvePoints;
    /**
     * 添加云线的顶点坐标, 该顶点坐标会根据上一个构成云线的点计算出下一个云线的顶点位置
     * @param pt 坐标位置
     * @param isAddToDrawGeometry 如果为true 将立即添加顶点并绘制下一个圆弧
     * */
    addPoint(pt: THREE.Vector3, isAddToDrawGeometry?: boolean): void;
    /**
     * 绘制两点之间的云线(与addPoint不同的是它不是只绘制一个半圆弧,而是绘制两点之间相连接的所有半圆弧)
     * @param pt1 云线开始点
     * @param pt2 云线结束点
     * */
    addLine(pt1: THREE.Vector3, pt2: THREE.Vector3): three.Vector3;
    /** 重新计算云线的的所有顶点坐标, 如绘制完云线后 重新设置了圆弧半径, 在worldDraw动态绘制时会调用该方法 */
    reCalculateDrawGeometryPoint(): THREE.Vector3[] | null;
    worldDraw(pWorldDraw: McGiWorldDraw): void;
    /**
     * 获取云线包围盒的中心点
     * */
    getCenter(): THREE.Vector3;
    getGripPoints(): THREE.Vector3[];
    moveGripPointsAt(index: number, offset: THREE.Vector3): boolean;
    dwgIn(obj: any): boolean;
    dwgOut(obj: any): object;
}

declare function drawMxDbRegularPolygon(): void;

declare class MxDbRegularPolygon extends MxDbShape {
    static cmd: string;
    static draw: typeof drawMxDbRegularPolygon;
    /** 正多边形的中心点位置 */
    centerPoint: three.Vector3;
    /** 正多边形两条边之间的交点位置 */
    otherPoint: three.Vector3;
    /** 正多边形边的数量 */
    sidesNumber: number;
    getTypeName(): string;
    /**
     * MxDbRegularPolygon 正多边形
     */
    constructor();
    worldDraw(pWorldDraw: McGiWorldDraw): void;
    getGripPoints(): THREE.Vector3[];
    moveGripPointsAt(index: number, offset: THREE.Vector3): boolean;
}

declare function drawMxDbLeadComment(): void;

/**
 * MxDbLeadComment 引线文字标注
 * */
declare class MxDbLeadComment extends MxDbEntity {
    static cmd: string;
    static draw: typeof drawMxDbLeadComment;
    /** 标注点 */
    point1: THREE.Vector3;
    /** 文字显示位置 */
    point2: THREE.Vector3;
    /** 文字内容 */
    text: string;
    /** 文字高度 */
    textHeight: number;
    textWidth: number;
    /** 文字大小，取屏幕像素绘图单位。 */
    fixedSize: boolean;
    getTypeName(): string;
    create(): MxDbEntity;
    worldDraw(pWorldDraw: McGiWorldDraw): void;
    getGripPoints(): Array<THREE.Vector3>;
    moveGripPointsAt(index: number, offset: THREE.Vector3): boolean;
    dwgIn(obj: any): boolean;
    dwgOut(obj: any): object;
    protected onViewChange(): boolean;
}

declare function drawMxDbRectBoxLeadComment(): void;

/**
 * MxDbRectBoxLeadComment 引线审图标注
 * */
declare class MxDbRectBoxLeadComment extends MxDbEntity {
    static cmd: string;
    static draw: typeof drawMxDbRectBoxLeadComment;
    /** 云线矩形的对角点1 */
    point1: THREE.Vector3;
    /** 云线矩形的对角点2 */
    point2: THREE.Vector3;
    /** 要标注的内容位置 */
    point3: THREE.Vector3;
    /** 要显示的文字内容*/
    text: string;
    /**文字高度*/
    textHeight: number;
    /** 云线的半圆弧半径 */
    radius: number;
    textWidth: number;
    /** 文字大小，取屏幕像素绘图单位。 */
    fixedSize: boolean;
    getTypeName(): string;
    create(): MxDbEntity;
    getCloudLine(): any;
    worldDraw(pWorldDraw: McGiWorldDraw): void;
    getGripPoints(): Array<THREE.Vector3>;
    moveGripPointsAt(index: number, offset: THREE.Vector3): boolean;
    dwgIn(obj: any): boolean;
    dwgOut(obj: any): object;
    protected onViewChange(): boolean;
}

declare function drawMxDbEllipse(): void;

/** 通过两个构成矩形的点绘制椭圆形 */
declare class MxDbEllipse extends MxDbEllipseShape {
    static cmd: string;
    static draw: typeof drawMxDbEllipse;
    constructor();
    getTypeName(): string;
    create(): MxDbEllipse;
    /** 开始点 */
    point1: three.Vector3;
    setPoint1(point1: THREE.Vector3): this;
    /** 结束点 */
    point2: three.Vector3;
    setPoint2(point2: THREE.Vector3): this;
    isClosedToCenter: boolean;
    closed: boolean;
    worldDraw(pWorldDraw: McGiWorldDraw): void;
    getGripPoints(): THREE.Vector3[];
    moveGripPointsAt(index: number, offset: THREE.Vector3): boolean;
}

declare function drawMxDbText(): Promise<void>;

declare type SpriteTextColorType = THREE.Color | string | number | CanvasGradient | CanvasPattern | undefined;
declare type SpriteTextObj = SpriteText;
declare type TextFontWeight = 'normal' | 'bold' | 'lighter' | 'bolder' | 'inherit' | number;
declare type TextFontStyle = 'normal' | 'italic' | 'oblique';
declare class SpriteText extends THREE.Sprite {
    constructor(options?: SpriteTextOptions);
    text: string;
    textHeight: number;
    color: SpriteTextColorType;
    backgroundColor: SpriteTextColorType;
    padding: number | number[];
    borderWidth: number;
    borderRadius: number;
    borderColor: SpriteTextColorType;
    fontFace: string;
    fontSize: number;
    fontWeight: TextFontWeight;
    strokeWidth: number;
    strokeColor: SpriteTextColorType;
    textAlign: CanvasTextAlign;
    textShadowBlur: number;
    textShadowColor: string | number | THREE.Color | undefined;
    textShadowOffsetX: number;
    textShadowOffsetY: number;
    angle: number;
    textScale: number;
    underline: boolean;
    fontStyle: TextFontStyle;
    fontVariant: string;
    _genCanvas(): void;
    dispose(): void;
}
interface SpriteTextOptions {
    text?: string;
    textHeight?: number;
    color?: SpriteTextColorType;
    backgroundColor?: SpriteTextColorType | undefined;
    padding?: number | number[];
    borderWidth?: number;
    borderRadius?: number;
    borderColor?: SpriteTextColorType;
    strokeWidth?: number;
    strokeColor?: SpriteTextColorType;
    fontFace?: string;
    fontSize?: number;
    fontWeight?: TextFontWeight;
    textAlign?: CanvasTextAlign;
    textBaseline?: CanvasTextBaseline;
    textShadowBlur?: number;
    textShadowColor?: string | number | THREE.Color | undefined;
    textShadowOffsetX?: number;
    textShadowOffsetY?: number;
    angle?: number;
    scale?: number;
    underline?: boolean;
    fontStyle?: TextFontStyle;
    fontVariant?: string;
}

/**
 * MxDbText 绘制文字
 * @describe 适用于标签标注类型的文字(永远面向相机的平面)
 * @example
 * ``` js
 *  obj = new MxDbText()
    obj.rxInit()
    obj.position = new THREE.Vector3()
    obj.backgroundColor = '#ff0000'
    obj.padding = 5
    obj.strokeWidth = 3
    obj.strokeColor = "#3a8bd2"
    obj.borderColor = "#ff00ff"
    obj.borderWidth = 2
    obj.borderRadius = 2
    obj.opacity = 0.8
    obj.text  = 'This is\nsome multi-line\ntext'
    obj.height = 100000
    obj.color = "#fff000"
 * ```
 */
declare class MxDbText extends MxDbEntity {
    static cmd: string;
    static draw: typeof drawMxDbText;
    /** 文字所在位置*/
    position: three.Vector3;
    setPosition(position: THREE.Vector3): this;
    private _text;
    /** 文字内容*/
    get text(): string;
    set text(text: string);
    setText(text: string): this;
    private _height;
    /** 文字高度*/
    get height(): number;
    set height(height: number);
    setHeight(height: number): this;
    private _backgroundColor;
    /** 背景颜色 */
    get backgroundColor(): SpriteTextColorType;
    set backgroundColor(color: SpriteTextColorType);
    setBackgroundColor(backgroundColor: SpriteTextColorType): this;
    private _padding;
    /** 填充范围 */
    get padding(): number | number[];
    set padding(padding: number | number[]);
    setPadding(padding: number | number[]): this;
    private _borderWidth;
    /** 边框宽度 */
    get borderWidth(): number;
    set borderWidth(borderWidth: number);
    setBorderWidth(borderWidth: number): this;
    private _borderRadius;
    /** 边框圆角 */
    get borderRadius(): number;
    set borderRadius(borderRadius: number);
    setBorderRadius(borderRadius: number): this;
    private _borderColor;
    /** 边框颜色 */
    get borderColor(): SpriteTextColorType;
    set borderColor(borderColor: SpriteTextColorType);
    setBorderColor(borderColor: SpriteTextColorType): this;
    private _fontFace;
    /** 客户端字体 */
    get fontFace(): string;
    set fontFace(fontFace: string);
    setFontFace(fontFace: string): this;
    private _fontSize;
    /** 字体大小 */
    get fontSize(): number;
    set fontSize(fontSize: number);
    setFontSize(fontSize: number): this;
    private _fontWeight;
    /** 字体粗细 */
    get fontWeight(): TextFontWeight;
    set fontWeight(fontWeight: TextFontWeight);
    setFontWeight(fontWeight: TextFontWeight): this;
    private _strokeWidth;
    /** 笔划宽度 */
    get strokeWidth(): number;
    set strokeWidth(strokeWidth: number);
    setStrokeWidth(strokeWidth: number): this;
    private _strokeColor;
    /** 笔划颜色 */
    get strokeColor(): SpriteTextColorType;
    set strokeColor(strokeColor: SpriteTextColorType);
    setStrokeColor(strokeColor: SpriteTextColorType): this;
    private _textAlign;
    /** 文本格式 */
    get textAlign(): CanvasTextAlign;
    set textAlign(textAlign: CanvasTextAlign);
    setTextAlign(textAlign: CanvasTextAlign): this;
    private _textShadowBlur;
    /** 文字阴影模糊程度 */
    get textShadowBlur(): number;
    set textShadowBlur(textShadowBlur: number);
    setTextShadowBlur(textShadowBlur: number): this;
    private _textShadowColor;
    /**  文字阴影颜色*/
    get textShadowColor(): string | number | Color | undefined;
    set textShadowColor(textShadowColor: string | number | Color | undefined);
    setTextShadowColor(textShadowColor: string | number | Color | undefined): this;
    private _textShadowOffsetX;
    /** 文字阴影X轴偏移量 */
    get textShadowOffsetX(): number;
    set textShadowOffsetX(textShadowOffsetX: number);
    setTextShadowOffsetX(textShadowOffsetX: number): this;
    private _textShadowOffsetY;
    /** 文字阴影X轴偏移量 */
    get textShadowOffsetY(): number;
    set textShadowOffsetY(textShadowOffsetY: number);
    setTextShadowOffsetY(textShadowOffsetY: number): this;
    private _angle;
    /** 角度*/
    get angle(): number;
    set angle(angle: number);
    setAngle(angle: number): this;
    private _scale;
    /** 缩放倍数 */
    get scale(): number;
    set scale(scale: number);
    setScale(scale: number): this;
    private _underline;
    /** 下划线 */
    get underline(): boolean;
    set underline(underline: boolean);
    setUnderline(underline: boolean): void;
    /** SpriteText实例 */
    protected spriteText: SpriteTextObj;
    getTypeName(): string;
    worldDraw(pWorldDraw: McGiWorldDraw): void;
    /**创建精灵文字对象 */
    protected createSpriteText(): void;
    getGripPoints(): THREE.Vector3[];
    moveGripPointsAt(index: number, offset: THREE.Vector3): boolean;
    create(): MxDbEntity;
    dwgIn(obj: any): boolean;
    dwgOut(obj: any): object;
    getGeomExtents(): THREE.Box3 | null;
    erase(): boolean;
}

/**
 * MxDbHatch 填充对象
 */
declare class MxDbHatch extends MxDbEntity {
    points: THREE.Vector3[];
    worldDraw(pWorldDraw: McGiWorldDraw): void;
    getTypeName(): string;
    moveGripPointsAt(index: number, offset: THREE.Vector3): boolean;
    /** 设置顶点坐标 */
    setPoints(points: THREE.Vector3[]): void;
    getGripPoints(): THREE.Vector3[];
    dwgIn(obj: any): boolean;
    dwgOut(obj: any): any;
}

/***
 * 渐变线段
 * @augments MxDbEntity
 * */
declare class MxDbGradientLine extends MxDbEntity {
    /** 点集合 */
    points: THREE.Vector3[];
    /** 渐变色 */
    colors: (THREE.Color | string | number)[];
    /**
     * 定义线两端的样式
     *  @access public
     * */
    linecap: 'butt' | 'round' | 'square';
    /**
     * 定义线连接节点的样式
     * @access public
     * */
    linejoin: 'round' | 'bevel' | 'miter';
    /**
     * 定义线形状是否闭合，从而创建多边形或斑点
     * @access public
     * */
    closed: boolean;
    /**
     * 曲线的类型: chordal: 弦线、 centripetal： 向心线、 catmullrom: Catmull-Rom曲线 默认：centripetal
     * @access public
     * */
    curveType: 'chordal' | 'centripetal' | 'catmullrom';
    /**
     *  当curveType为catmullrom时，定义catmullrom的张力。 张力: 数值越大，曲线越弯曲。值为0将导致没有插值。默认值是0
     *  @access public
     *
     */
    tension: number;
    /**
     * 如果没有提供张力，但bezierType赋值为'quadratic'| 'cubic'，则使用点集合中的点绘制一条bezier线  默认: undefined
     * @summary quadratic: 三维二次贝塞尔曲线 => 起点 – 中间的控制点 – 终点
     * @summary cubic: 三维三次贝塞尔曲线 => 起点v – 第一个控制点 – 第二个控制点 – 终点
     */
    bezierType: 'quadratic' | 'cubic' | undefined;
    protected curve?: THREE.CatmullRomCurve3 | THREE.CurvePath<THREE.Vector3>;
    create(): MxDbGradientLine;
    getTypeName(): string;
    setPoints(points: THREE.Vector3[]): this;
    setColors(colors: (THREE.Color | string | number)[]): this;
    addColor(color: THREE.Color): this;
    setLinecap(linecap: 'butt' | 'round' | 'square'): void;
    setClosed(closed: boolean): void;
    setCurveType(curveType: 'chordal' | 'centripetal' | 'catmullrom'): void;
    setTension(tension: number): void;
    setBezierType(bezierType: 'quadratic' | 'cubic'): void;
    worldDraw(pWorldDraw: McGiWorldDraw): void;
    getGripPoints(): THREE.Vector3[];
    getPoints(): three.Vector3[];
    moveGripPointsAt(index: number, offset: THREE.Vector3): boolean;
    move(index: number, offset: THREE.Vector3): this;
    dwgIn(obj: any): boolean;
    dwgOut(obj: any): object;
}

declare function drawMxDbEllipseArc(): void;

/**
* 根据中心点、椭圆开始点和结束点确定椭圆弧
*  */
declare class MxDbEllipseArc extends MxDbEllipseShape {
    static cmd: string;
    static draw: typeof drawMxDbEllipseArc;
    getTypeName(): string;
    constructor();
    /** 椭圆弧决定开始点 控制x轴半径和开始角度 */
    startPoint: THREE.Vector3;
    setStartPoint(startPoint: THREE.Vector3): this;
    /** 椭圆弧决定结束点 控制y轴半径和结束角度*/
    endPoint: THREE.Vector3;
    setEndPoint(endPoint: THREE.Vector3): this;
    worldDraw(pWorldDraw: McGiWorldDraw): void;
    getGripPoints(): three.Vector3[];
    moveGripPointsAt(index: number, offset: THREE.Vector3): boolean;
}

declare function drawMxDbCircleArc(): void;

declare class MxDbCircleArc extends MxDbCircleShape {
    static cmd: string;
    static draw: typeof drawMxDbCircleArc;
    /** 根据圆心、起始点、结束点位置动态绘制圆弧 **/
    constructor();
    getTypeName(): string;
    /** 圆弧开始点 设置开始点将自动计算 radius、startAngle、endAngle */
    startPoint: THREE.Vector3;
    setStartPoint(startPoint: THREE.Vector3): this;
    /** 圆弧结束点 设置结束点将自动计算 radius、startAngle、endAngle */
    endPoint: THREE.Vector3;
    setEndPoint(endPoint: THREE.Vector3): this;
    worldDraw(pWorldDraw: McGiWorldDraw): void;
    computePointAngle(point: THREE.Vector3): number;
    getGripPoints(): three.Vector3[];
    moveGripPointsAt(index: number, offset: THREE.Vector3): boolean;
}

declare class MxDbArcShape extends MxDbCircleArc {
    /** 环形 */
    constructor();
    getTypeName(): string;
    center: three.Vector3;
    innerRadius: number;
    outerRadius: number;
    worldDraw(pWorldDraw: McGiWorldDraw): void;
    drawArcShape(pWorldDraw: McGiWorldDraw): void;
    getGripPoints(): THREE.Vector3[];
    moveGripPointsAt(index: number, offset: THREE.Vector3): boolean;
}

declare function drawMxDbArcShape(): void;

declare class MxDbArcShapeDraw extends MxDbArcShape {
    static isRegister: boolean;
    static cmd: string;
    static draw: typeof drawMxDbArcShape;
    getTypeName(): string;
    /** 绘制弧形 */
    constructor();
    outerRadiusPoint: three.Vector3;
    interRadiusPoint: three.Vector3;
    worldDraw(pWorldDraw: McGiWorldDraw): void;
    getGripPoints(): THREE.Vector3[];
    moveGripPointsAt(index: number, offset: THREE.Vector3): boolean;
}

declare function drawMxDbRingShape(): void;

/** 环形 */
declare class MxDbRingShape extends MxDbArcShape {
    static isRegister: boolean;
    static cmd: string;
    static draw: typeof drawMxDbRingShape;
    getTypeName(): string;
    worldDraw(pWorldDraw: McGiWorldDraw): void;
}

declare function drawMxDbStarShape(): void;

/** 星形 */
declare class MxDbStarShape extends MxDbShape {
    static cmd: string;
    static draw: typeof drawMxDbStarShape;
    getTypeName(): string;
    constructor();
    center: three.Vector3;
    /** 顶点数量 */
    numPoints: number;
    /** 内部半径 */
    innerRadius: number;
    /** 外部半径 */
    outerRadius: number;
    worldDraw(pWorldDraw: McGiWorldDraw): void;
    getGripPoints(): THREE.Vector3[];
    moveGripPointsAt(index: number, offset: THREE.Vector3): boolean;
}

/** 等边多边形 */
declare class MxDbRegularPolygonShape extends MxDbShape {
    center: three.Vector3;
    sidesNumber: number;
    radius: number;
    getTypeName(): string;
    constructor();
    worldDraw(pWorldDraw: McGiWorldDraw): void;
    _drawPolygonShape(pWorldDraw: McGiWorldDraw): void;
    _getPoints(): {
        x: number;
        y: number;
    }[];
    getGripPoints(): THREE.Vector3[];
    moveGripPointsAt(index: number, offset: THREE.Vector3): boolean;
}

declare function drawMxDbArrow(): void;

declare class MxDbArrow extends MxDbShape {
    static cmd: string;
    static draw: typeof drawMxDbArrow;
    /** 箭头图形 */
    constructor();
    /** 开始是否为尖角 */
    isSharpCorner: boolean;
    /** 内部偏移量 */
    innerOffset: number;
    /** 外部偏移量 */
    outerOffset: number;
    /** 顶部偏移量 */
    topOffset: number;
    startPoint: three.Vector3;
    endPoint: three.Vector3;
    worldDraw(pWorldDraw: McGiWorldDraw): void;
    getArrowVertex(p1: THREE.Vector3, p2: THREE.Vector3, isSharpCorner?: boolean): three.Vector3[] | undefined;
    getGripPoints(): THREE.Vector3[];
    moveGripPointsAt(index: number, offset: THREE.Vector3): boolean;
}

/** 线形状 */
declare class MxDbLineShape extends MxDbShape {
    points: THREE.Vector3[];
    setPoints(points: THREE.Vector3[]): this;
    addPoint(point: THREE.Vector3): this;
    removePoint(index: number): this;
    constructor();
    getTypeName(): string;
    worldDraw(pWorldDraw: McGiWorldDraw): void;
    getGripPoints(): Array<THREE.Vector3>;
    moveGripPointsAt(index: number, offset: THREE.Vector3): boolean;
    /** 获取包围盒 */
    getGeomExtents(): THREE.Box3 | null;
    /**
     * 返回曲线长度.
     * @returns number
     */
    getGetLength(): number;
}

declare const Mx_loadCoreCode: typeof loadCoreCode;
declare const Mx_useCanvasResizeListener: typeof useCanvasResizeListener;
declare const Mx_store: typeof store;
declare const Mx_MxFun: typeof MxFun;
declare const Mx_MxThreeJS: typeof MxThreeJS;
declare const Mx_MxType: typeof MxType;
declare const Mx_Mxassembly: typeof Mxassembly;
declare const Mx_McGeTool: typeof McGeTool;
declare const Mx_MrxDbgUtils: typeof MrxDbgUtils;
declare const Mx_MxPaintBrush: typeof MxPaintBrush;
type Mx_MrxDbgUiPrPoint = MrxDbgUiPrPoint;
declare const Mx_MrxDbgUiPrPoint: typeof MrxDbgUiPrPoint;
type Mx_McEdGetPointWorldDrawObject = McEdGetPointWorldDrawObject;
declare const Mx_McEdGetPointWorldDrawObject: typeof McEdGetPointWorldDrawObject;
type Mx_MrxDbgUiPrBaseReturn = MrxDbgUiPrBaseReturn;
declare const Mx_MrxDbgUiPrBaseReturn: typeof MrxDbgUiPrBaseReturn;
type Mx_MxDbEntity = MxDbEntity;
declare const Mx_MxDbEntity: typeof MxDbEntity;
type Mx_MxDbImage = MxDbImage;
declare const Mx_MxDbImage: typeof MxDbImage;
type Mx_MxDbSVG = MxDbSVG;
declare const Mx_MxDbSVG: typeof MxDbSVG;
type Mx_MxDbSVGText = MxDbSVGText;
declare const Mx_MxDbSVGText: typeof MxDbSVGText;
type Mx_MxDbPolyline = MxDbPolyline;
declare const Mx_MxDbPolyline: typeof MxDbPolyline;
type Mx_MxDb2LineAngularDimension = MxDb2LineAngularDimension;
declare const Mx_MxDb2LineAngularDimension: typeof MxDb2LineAngularDimension;
type Mx_Mx3PointArc = Mx3PointArc;
declare const Mx_Mx3PointArc: typeof Mx3PointArc;
type Mx_MxDbCoord = MxDbCoord;
declare const Mx_MxDbCoord: typeof MxDbCoord;
type Mx_MxDbLine = MxDbLine;
declare const Mx_MxDbLine: typeof MxDbLine;
type Mx_MxDbRect = MxDbRect;
declare const Mx_MxDbRect: typeof MxDbRect;
type Mx_MxDbAlignedDimension = MxDbAlignedDimension;
declare const Mx_MxDbAlignedDimension: typeof MxDbAlignedDimension;
type Mx_MxFilters = MxFilters;
declare const Mx_MxFilters: typeof MxFilters;
type Mx_McGiWorldDraw = McGiWorldDraw;
type Mx_McGiWorldDrawType = McGiWorldDrawType;
declare const Mx_McGiWorldDrawType: typeof McGiWorldDrawType;
type Mx_MxDbArea = MxDbArea;
declare const Mx_MxDbArea: typeof MxDbArea;
type Mx_MxDbLeadTag = MxDbLeadTag;
declare const Mx_MxDbLeadTag: typeof MxDbLeadTag;
type Mx_MxDbAnyLine = MxDbAnyLine;
declare const Mx_MxDbAnyLine: typeof MxDbAnyLine;
type Mx_MxDbCloudLine = MxDbCloudLine;
declare const Mx_MxDbCloudLine: typeof MxDbCloudLine;
type Mx_MxDbRegularPolygon = MxDbRegularPolygon;
declare const Mx_MxDbRegularPolygon: typeof MxDbRegularPolygon;
type Mx_McGePoint3d = McGePoint3d;
type Mx_McGePoint3dArray = McGePoint3dArray;
type Mx_MxDbLeadComment = MxDbLeadComment;
declare const Mx_MxDbLeadComment: typeof MxDbLeadComment;
type Mx_MxDbRectBoxLeadComment = MxDbRectBoxLeadComment;
declare const Mx_MxDbRectBoxLeadComment: typeof MxDbRectBoxLeadComment;
type Mx_MxDbEllipse = MxDbEllipse;
declare const Mx_MxDbEllipse: typeof MxDbEllipse;
type Mx_MxDbText = MxDbText;
declare const Mx_MxDbText: typeof MxDbText;
type Mx_MxDrawObject = MxDrawObject;
declare const Mx_MxDrawObject: typeof MxDrawObject;
type Mx_MxDbHatch = MxDbHatch;
declare const Mx_MxDbHatch: typeof MxDbHatch;
type Mx_MxDbLayerTableRecord = MxDbLayerTableRecord;
type Mx_MxDbDatabase = MxDbDatabase;
declare const Mx_MxDbDatabase: typeof MxDbDatabase;
type Mx_MxCADObject = MxCADObject;
declare const Mx_MxCADObject: typeof MxCADObject;
type Mx_MxDbGroup = MxDbGroup;
type Mx_MxDbGradientLine = MxDbGradientLine;
declare const Mx_MxDbGradientLine: typeof MxDbGradientLine;
type Mx_MxDbShape = MxDbShape;
declare const Mx_MxDbShape: typeof MxDbShape;
type Mx_MxDbEllipseShape = MxDbEllipseShape;
declare const Mx_MxDbEllipseShape: typeof MxDbEllipseShape;
type Mx_MxDbEllipseArc = MxDbEllipseArc;
declare const Mx_MxDbEllipseArc: typeof MxDbEllipseArc;
type Mx_MxDbCircleShape = MxDbCircleShape;
declare const Mx_MxDbCircleShape: typeof MxDbCircleShape;
type Mx_MxDbCircleArc = MxDbCircleArc;
declare const Mx_MxDbCircleArc: typeof MxDbCircleArc;
type Mx_MxDbArcShapeDraw = MxDbArcShapeDraw;
declare const Mx_MxDbArcShapeDraw: typeof MxDbArcShapeDraw;
type Mx_MxDbRingShape = MxDbRingShape;
declare const Mx_MxDbRingShape: typeof MxDbRingShape;
type Mx_MxDbStarShape = MxDbStarShape;
declare const Mx_MxDbStarShape: typeof MxDbStarShape;
type Mx_MxDbRegularPolygonShape = MxDbRegularPolygonShape;
declare const Mx_MxDbRegularPolygonShape: typeof MxDbRegularPolygonShape;
type Mx_MxDbArrow = MxDbArrow;
declare const Mx_MxDbArrow: typeof MxDbArrow;
type Mx_MxDbLineShape = MxDbLineShape;
declare const Mx_MxDbLineShape: typeof MxDbLineShape;
declare namespace Mx {
  export {
    Mx_loadCoreCode as loadCoreCode,
    Mx_useCanvasResizeListener as useCanvasResizeListener,
    Mx_store as store,
    Mx_MxFun as MxFun,
    Mx_MxThreeJS as MxThreeJS,
    Mx_MxType as MxType,
    Mx_Mxassembly as Mxassembly,
    Mx_McGeTool as McGeTool,
    Mx_MrxDbgUtils as MrxDbgUtils,
    Mx_MxPaintBrush as MxPaintBrush,
    Mx_MrxDbgUiPrPoint as MrxDbgUiPrPoint,
    Mx_McEdGetPointWorldDrawObject as McEdGetPointWorldDrawObject,
    Mx_MrxDbgUiPrBaseReturn as MrxDbgUiPrBaseReturn,
    Mx_MxDbEntity as MxDbEntity,
    Mx_MxDbImage as MxDbImage,
    Mx_MxDbSVG as MxDbSVG,
    Mx_MxDbSVGText as MxDbSVGText,
    Mx_MxDbPolyline as MxDbPolyline,
    Mx_MxDb2LineAngularDimension as MxDb2LineAngularDimension,
    Mx_Mx3PointArc as Mx3PointArc,
    Mx_MxDbCoord as MxDbCoord,
    Mx_MxDbLine as MxDbLine,
    Mx_MxDbRect as MxDbRect,
    Mx_MxDbAlignedDimension as MxDbAlignedDimension,
    Mx_MxFilters as MxFilters,
    Mx_McGiWorldDraw as McGiWorldDraw,
    Mx_McGiWorldDrawType as McGiWorldDrawType,
    Mx_MxDbArea as MxDbArea,
    Mx_MxDbLeadTag as MxDbLeadTag,
    Mx_MxDbAnyLine as MxDbAnyLine,
    Mx_MxDbCloudLine as MxDbCloudLine,
    Mx_MxDbRegularPolygon as MxDbRegularPolygon,
    Mx_McGePoint3d as McGePoint3d,
    Mx_McGePoint3dArray as McGePoint3dArray,
    Mx_MxDbLeadComment as MxDbLeadComment,
    Mx_MxDbRectBoxLeadComment as MxDbRectBoxLeadComment,
    Mx_MxDbEllipse as MxDbEllipse,
    Mx_MxDbText as MxDbText,
    Mx_MxDrawObject as MxDrawObject,
    Mx_MxDbHatch as MxDbHatch,
    Mx_MxDbLayerTableRecord as MxDbLayerTableRecord,
    Mx_MxDbDatabase as MxDbDatabase,
    Mx_MxCADObject as MxCADObject,
    Mx_MxDbGroup as MxDbGroup,
    Mx_MxDbGradientLine as MxDbGradientLine,
    Mx_MxDbShape as MxDbShape,
    Mx_MxDbEllipseShape as MxDbEllipseShape,
    Mx_MxDbEllipseArc as MxDbEllipseArc,
    Mx_MxDbCircleShape as MxDbCircleShape,
    Mx_MxDbCircleArc as MxDbCircleArc,
    Mx_MxDbArcShapeDraw as MxDbArcShapeDraw,
    Mx_MxDbRingShape as MxDbRingShape,
    Mx_MxDbStarShape as MxDbStarShape,
    Mx_MxDbRegularPolygonShape as MxDbRegularPolygonShape,
    Mx_MxDbArrow as MxDbArrow,
    Mx_MxDbLineShape as MxDbLineShape,
  };
}

declare global {
    type THREE = typeof THREE;
    interface Window {
        THREE: typeof THREE;
    }
}

export { McEdGetPointWorldDrawObject, McGePoint3d, McGePoint3dArray, McGeTool, McGiWorldDraw, McGiWorldDrawType, MrxDbgUiPrBaseReturn, MrxDbgUiPrPoint, MrxDbgUtils, Mx3PointArc, MxCADObject, MxDb2LineAngularDimension, MxDbAlignedDimension, MxDbAnyLine, MxDbArcShapeDraw, MxDbArea, MxDbArrow, MxDbCircleArc, MxDbCircleShape, MxDbCloudLine, MxDbCoord, MxDbDatabase, MxDbEllipse, MxDbEllipseArc, MxDbEllipseShape, MxDbEntity, MxDbGradientLine, MxDbGroup, MxDbHatch, MxDbImage, MxDbLayerTableRecord, MxDbLeadComment, MxDbLeadTag, MxDbLine, MxDbLineShape, MxDbPolyline, MxDbRect, MxDbRectBoxLeadComment, MxDbRegularPolygon, MxDbRegularPolygonShape, MxDbRingShape, MxDbSVG, MxDbSVGText, MxDbShape, MxDbStarShape, MxDbText, MxDrawObject, MxFilters, MxFun, MxPaintBrush, MxThreeJS, MxType, Mxassembly, Mx as default, loadCoreCode, store, useCanvasResizeListener };
