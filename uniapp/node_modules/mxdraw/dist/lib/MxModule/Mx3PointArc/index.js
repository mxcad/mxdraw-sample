import{addRegisterMxDbEntity}from"../../tools/registerMxDbEntity";import{calculateArcAngle,calculateArcOrigin,calculateRadiusArc,judgementArcRenderDirection}from"../../tools/three";import MxDbCircleShape from"../MxDbCircleShape";import drawMx3PointArc from"./draw";class Mx3PointArc extends MxDbCircleShape{constructor(){super(),this.point1=new THREE.Vector3,this.point2=new THREE.Vector3,this.point3=new THREE.Vector3,this.autoClockwise=!0,this._propertyDbKeys=[...this._propertyDbKeys,"point1","point2","point3","autoClockwise"]}getTypeName(){return"Mx3PointArc"}create(){return new Mx3PointArc}worldDraw(t){let{point1:i,point2:e,point3:r}=this;this.upDateCenter(i,e,r),this.upDateRadius(i);const[n,o,s]=this.compute3PointAngle();this.upDataClockwise(n,o,s),this.startAngle=THREE.MathUtils.degToRad(n),this.endAngle=THREE.MathUtils.degToRad(o),this.drawEllipseShape(t)}getGripPoints(){return[this.point1,this.point2,this.point3,this.center]}compute3PointAngle(){const{point1:t,point2:i,point3:e}=this,r=calculateArcAngle(t,this.center,this.radius),n=calculateArcAngle(i,this.center,this.radius),o=calculateArcAngle(e,this.center,this.radius);return[r.angle,n.angle,o.angle]}upDateCenter(t,i,e){return this.center=calculateArcOrigin(t,i,e),this.center}upDateRadius(t){return this.radius=calculateRadiusArc(t,this.center),this.radius}upDataClockwise(t,i,e){const{autoClockwise:r}=this;r&&(this.clockwise=judgementArcRenderDirection(i,t,e))}moveGripPointsAt(t,i){return 0===t?this.point1.add(i):1===t?this.point2.add(i):2===t?this.point3.add(i):3===t&&(this.point1.add(i),this.point2.add(i),this.point3.add(i)),this.upDateCenter(this.point1,this.point2,this.point3),!0}}Mx3PointArc.cmd="Mx_3PointArc",Mx3PointArc.draw=drawMx3PointArc,addRegisterMxDbEntity(Mx3PointArc);export default Mx3PointArc;