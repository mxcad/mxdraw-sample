import MxDbEntity from"../MxDbEntity";import McGiWorldDrawType from"../McGiWorldDrawType";import MxType from"../MxType";import drawMxDbCloudLine from"./draw";import{addRegisterMxDbEntity}from"../../tools/registerMxDbEntity";const propertyDbKeys=["points","radius"];class MxDbCloudLine extends MxDbEntity{constructor(){super(...arguments),this.points=[],this.radius=16,this.cachePoint=null}getTypeName(){return"MxDbCloudLine"}create(){return new MxDbCloudLine}setRadius(t){this.radius=t}getRadius(){return this.radius}getCachePoint(){return this.cachePoint}clacNewArcDiameterPoint(t){if(0==this.points.length)return t;let e=this.points[this.points.length-1];const n=2*this.radius,i=e.distanceTo(t);if(i<n)return null;const r=n*(t.x-e.x)/i+e.x,o=n*(t.y-e.y)/i+e.y;return new THREE.Vector3(r,o,e.z)}createCloudArcCurvePoints(t,e,n){const i=new THREE.Vector3((t.x+e.x)/2,(t.y+e.y)/2,0);n||(n=i.distanceTo(t));const{startAngle:r,endAngle:o}=function(t,e,n){const i=2*Math.PI/360;return{startAngle:180*Math.atan2(e.y-t.y,e.x-t.x)/Math.PI*i,endAngle:180*Math.atan2(n.y-t.y,n.x-t.x)/Math.PI*i}}(i,t,e);return new THREE.ArcCurve(i.x,i.y,n,r,o,!0).getPoints(10)}addPoint(t,e){let n=this.clacNewArcDiameterPoint(t);n&&(this.points.push(n),this.cachePoint=null,e&&(this.cachePoint=this.reCalculateDrawGeometryPoint()))}addLine(t,e){this.addPoint(t);const n=2*this.radius;let i=this.points[this.points.length-1],r=i.distanceTo(e);const o=Math.round(r/n);for(let t=0;t<o;t++){r=i.distanceTo(e);const t=n*(e.x-i.x)/r+i.x,o=n*(e.y-i.y)/r+i.y;let s=new THREE.Vector3(t,o,e.z);this.addPoint(s),i=s}return this.points[this.points.length-1]}reCalculateDrawGeometryPoint(){if(this.points.length<2)return null;let t=this.points[0],e=this.points.length,n=[];for(let i=1;i<e;i++){let e=this.points[i];this.createCloudArcCurvePoints(t,e).forEach(t=>{n.push(new THREE.Vector3(t.x,t.y,0))}),t=e}return n}worldDraw(t){if(this.cachePoint||(this.cachePoint=this.reCalculateDrawGeometryPoint()),this.cachePoint)if(t.getType()===McGiWorldDrawType.kSelectDraw){let e=new THREE.Geometry;this.cachePoint.forEach(t=>{e.vertices.push(new THREE.Vector3(t.x,t.y,0))}),e.computeBoundingBox();const n=new THREE.Vector3;e.boundingBox.getSize(n);let i=new THREE.Vector3;e.boundingBox.getCenter(i);const r=n.x/2,o=n.y/2,s={x:i.x-r,y:i.y-o},a={x:i.x+r,y:i.y-o},c={x:i.x+r,y:i.y+o},h={x:i.x-r,y:i.y+o};t.drawLine(s.x,s.y,a.x,a.y),t.drawLine(a.x,a.y,c.x,c.y),t.drawLine(c.x,c.y,h.x,h.y),t.drawLine(h.x,h.y,s.x,s.y)}else t.drawLines(this.cachePoint)}getCenter(){const t=new THREE.Geometry;t.vertices=this.points;let e=new THREE.Vector3;return t.computeBoundingBox(),t.boundingBox.getCenter(e),e}getGripPoints(){return[this.getCenter()]}moveGripPointsAt(t,e){return this.points.forEach(t=>{t.add(e)}),this.cachePoint=null,!0}dwgIn(t){return this.onDwgIn(t),this.dwgInHelp(t,propertyDbKeys),this.cachePoint=null,!0}dwgOut(t){return this.onDwgOut(t),this.dwgOutHelp(t,propertyDbKeys),t.type===MxType.MxCloneType.kSaveDwgClone&&this.dwgOutHelp(t,["cachePoint"]),t}}MxDbCloudLine.isRegister=!1,MxDbCloudLine.cmd="Mx_CloudLine",MxDbCloudLine.draw=drawMxDbCloudLine,addRegisterMxDbEntity(MxDbCloudLine);export default MxDbCloudLine;