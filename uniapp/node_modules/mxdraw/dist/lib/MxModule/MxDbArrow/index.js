import{addRegisterMxDbEntity}from"../../tools/registerMxDbEntity";import MxDbShape from"../MxDbShape";import drawMxDbArrow from"./draw";class MxDbArrow extends MxDbShape{constructor(){super(),this.isSharpCorner=!0,this.innerOffset=10,this.outerOffset=22,this.topOffset=36,this.startPoint=new THREE.Vector3,this.endPoint=new THREE.Vector3,this._propertyDbKeys=[...this._propertyDbKeys,"outerOffset","topOffset","innerOffset","isSharpCorner","startPoint","endPoint"]}worldDraw(t){const r=this.getArrowVertex(this.startPoint,this.endPoint);r&&(this._draw(t,r),this._drawStoreLine(t,r))}getArrowVertex(t,r,e=this.isSharpCorner){let{innerOffset:o,topOffset:s,outerOffset:i}=this;const n=[];n[3]=r;const x=Math.sqrt((t.x-r.x)*(t.x-r.x)+(t.y-r.y)*(t.y-r.y));if(0===x)return;const y=-(r.x-t.x)/x,h=(r.y-t.y)/x,a=t.x+o,d=t.y+x-s,w=t.x+i,f=t.y+x-s,E=t.x-o,p=t.y+x-s,c=t.x-i,D=t.y+x-s;return e?(n[0]=t,n[6]=n[0]):(n[0]=new THREE.Vector3(t.x-(E-t.x)*h,t.y-(E-t.x)*y),n[6]=new THREE.Vector3(t.x+(E-t.x)*h,t.y+(E-t.x)*y),n[7]=n[0]),n[1]=new THREE.Vector3(t.x+(a-t.x)*h-(d-t.y)*y,t.y+(a-t.x)*y+(d-t.y)*h),n[2]=new THREE.Vector3(t.x+(w-t.x)*h-(f-t.y)*y,t.y+(w-t.x)*y+(f-t.y)*h),n[4]=new THREE.Vector3(t.x+(c-t.x)*h-(D-t.y)*y,t.y+(c-t.x)*y+(D-t.y)*h),n[5]=new THREE.Vector3(t.x+(E-t.x)*h-(p-t.y)*y,t.y+(E-t.x)*y+(p-t.y)*h),n}getGripPoints(){const t=new THREE.Vector3;return new THREE.Line3(this.startPoint,this.endPoint).getCenter(t),[this.startPoint,t,this.endPoint]}moveGripPointsAt(t,r){return 0===t&&this.startPoint.add(r),1===t&&(this.startPoint.add(r),this.endPoint.add(r)),2===t&&this.endPoint.add(r),!0}}MxDbArrow.cmd="Mx_MxDbArrow",MxDbArrow.draw=drawMxDbArrow,addRegisterMxDbEntity(MxDbArrow);export default MxDbArrow;