import{addRegisterMxDbEntity}from"../../tools/registerMxDbEntity";import McGiWorldDrawType from"../McGiWorldDrawType";import MxDbEllipseShape from"../MxDbEllipseShape";import drawMxDbEllipse from"./draw";class MxDbEllipse extends MxDbEllipseShape{constructor(){super(),this.point1=new THREE.Vector3,this.point2=new THREE.Vector3,this.isClosedToCenter=!1,this.closed=!1,this._propertyDbKeys=[...this._propertyDbKeys,"point1","point2"]}getTypeName(){return"MxDbEllipse"}create(){return new MxDbEllipse}setPoint1(t){return this.point1=t,this}setPoint2(t){return this.point2=t,this}worldDraw(t){const{point1:i,point2:e}=this,s=i.clone().set(e.x,i.y,e.z),r=e.clone().set(i.x,e.y,i.z);this.xRadius=i.distanceTo(s)/2,this.yRadius=i.distanceTo(r)/2;const o=i.x>e.x,p=i.y>e.y,n=o?i.x-this.xRadius:i.x+this.xRadius,l=p?i.y-this.yRadius:i.y+this.yRadius;this.center=new THREE.Vector3(n,l,0),this.drawEllipseShape(t),t.getType()===McGiWorldDrawType.kSelectDraw&&t.drawLines([i,new THREE.Vector3(i.x,e.y),e,new THREE.Vector3(e.x,i.y),i])}getGripPoints(){let t=new THREE.Vector3(.5*(this.point2.x+this.point1.x),.5*(this.point2.y+this.point1.y),0);return[this.point1,this.point2,t]}moveGripPointsAt(t,i){return 0===t?this.point1.add(i):1===t?this.point2.add(i):2===t&&(this.point1.add(i),this.point2.add(i)),!0}}MxDbEllipse.cmd="Mx_Ellipse",MxDbEllipse.draw=drawMxDbEllipse,addRegisterMxDbEntity(MxDbEllipse);export default MxDbEllipse;