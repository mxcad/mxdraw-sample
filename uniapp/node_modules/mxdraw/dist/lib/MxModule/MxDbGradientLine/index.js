import McGiWorldDrawType from"../McGiWorldDrawType";import MxDbEntity from"../MxDbEntity";import{addRegisterMxDbEntity}from"../../tools/registerMxDbEntity";function createCurvePath(e=!1){const t=new THREE.CurvePath;return t.autoClose=e,t}function createQuadraticBezierCurve3(e){let t=0,r=[];for(let i=0;i<e.length;i++){const i=e[t],n=e[++t]||i,s=e[++t]||n;if(!i||!n||!s)break;r.push(new THREE.QuadraticBezierCurve3(i,n,s))}return r}function createCubicBezierCurve3(e){let t=0,r=[];for(let i=0;i<e.length;i++){const i=e[t],n=e[++t]||i,s=e[++t]||n,o=e[++t]||s;if(!(i&&n&&s&&o))break;r.push(new THREE.CubicBezierCurve3(i,n,s,o))}return r}function getCurveColorGradientData(e,t){let r=0,i=[],n=[];const s=Number((1/t.length).toFixed(2));let o=new THREE.Color(t[r]),c=new THREE.Color(t[r+1]);for(let u=0,l=e.length;u<l;u++){const l=e[u],a=u/e.length;a/r>=s&&(r++,c.set(new THREE.Color(t[r]||t[--r]))),i.push(l.x,l.y,l.z||0),o.lerpHSL(c,a),n.push(o.r,o.g,o.b)}return[i,n]}function getColorGradientData(e,t){let r=[],i=[];for(let n=0,s=e.length;n<s;n++){const s=e[n];r.push(s.x,s.y,s.z||0);const o=new THREE.Color(t[n]);i.push(o.r,o.g,o.b)}return[r,i]}const propertyDbKeys=["points","colors","linecap","linejoin","closed","curveType","tension","bezierType"];class MxDbGradientLine extends MxDbEntity{constructor(){super(...arguments),this.linecap="round",this.linejoin="round",this.closed=!1,this.curveType="centripetal",this.tension=0,this.bezierType="quadratic"}create(){return new MxDbGradientLine}getTypeName(){return"MxDbGradientLine"}setPoints(e){return this.points=e,this}setColors(e){return this.colors=e,this}addColor(e){return this.colors.push(e),this}setLinecap(e){this.linecap=e}setClosed(e){this.closed=e}setCurveType(e){this.curveType=e}setTension(e){this.tension=e}setBezierType(e){this.bezierType=e}worldDraw(e){const t=e.getType();let r=this.getPoints();const{closed:i,curveType:n,tension:s,bezierType:o}=this,c=new THREE.BufferGeometry;let u=[],l=[];const a="cubic"===o,h="quadratic"===o;0!==s?this.curve=new THREE.CatmullRomCurve3(r,i,n,s):o?(this.curve=createCurvePath(i),a?this.curve.curves=createCubicBezierCurve3(r):h?this.curve.curves=createQuadraticBezierCurve3(r):this.curve=void 0):this.curve=void 0,this.curve&&(r=this.curve.getPoints(50));const{linecap:p,linejoin:d}=this;let v;if(this.colors&&this.colors.length>1){const e=i?[...this.colors,this.colors[0]]:this.colors;[u,l]=this.curve?getCurveColorGradientData(r,e):getColorGradientData(r,e),c.setAttribute("position",new THREE.Float32BufferAttribute(u,3)),c.setAttribute("color",new THREE.Float32BufferAttribute(l,3)),v=new THREE.LineBasicMaterial({vertexColors:THREE.VertexColors,linecap:p,linejoin:d})}else c.setFromPoints(r),v=new THREE.LineBasicMaterial({color:this.color,linecap:p,linejoin:d});const E=i?new THREE.LineLoop(c,v):new THREE.Line(c,v);if(e.drawEntity(E),(t===McGiWorldDrawType.kSelectDraw||t===McGiWorldDrawType.kDynDragDraw)&&this.curve){let t=this.getPoints();const r=e.getLineWidth();e.setLineWidth(1),e.drawLines(t),e.setLineWidth(r)}}getGripPoints(){return this.getPoints()}getPoints(){return this.closed?[...this.points,this.points[0]]:this.points}moveGripPointsAt(e,t){return this.move(e,t),!0}move(e,t){return this.points[e].add(t),this}dwgIn(e){return this.dwgInHelp(e,propertyDbKeys),this.curve=e.curve,!0}dwgOut(e){return this.dwgOutHelp(e,propertyDbKeys),e.curve=this.curve,e}}addRegisterMxDbEntity(MxDbGradientLine);export default MxDbGradientLine;