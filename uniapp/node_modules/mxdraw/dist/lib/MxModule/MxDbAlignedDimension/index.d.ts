/** @module MxDbAlignedDimension*/
import McGiWorldDraw from '../McGiWorldDraw';
import MxDbEntity from '../MxDbEntity';
import { MxColorType, UnstableColor } from '../MxType';
import drawMxDbAlignedDimension from './draw';
/**
 * MxDbAlignedDimension 尺寸标注
 */
declare class MxDbAlignedDimension extends MxDbEntity {
    static cmd: string;
    static draw: typeof drawMxDbAlignedDimension;
    /**
     * MxDbAlignedDimension
     * 尺寸标注
     * @param options.points 提供两个向量测量尺寸
     * @param options.fontColor 字体颜色
     * @example ```typescript
     * const draw = Mx.MxFun.getCurrentDraw();
     * const v3 = new THREE.Vector3()
     * const points = [v3 , v3.clone().add(new THREE.Vector3(8880, 0, 0))]
     * const colors = ['#F00880','#00ff1a']
     * draw.addMxEntity(
     *   new Mx.MxDbAlignedDimension({ points })
     *   .setColor(colors)
     *   .setLineWidth(6)
     * )
     * ```
     **/
    constructor(options?: {
        /** [point1, point2] 两个向量位置 */
        points?: THREE.Vector3[];
        /** 字体颜色 */
        fontColor?: MxColorType;
    });
    point1: THREE.Vector3;
    point2: THREE.Vector3;
    fontColor: UnstableColor;
    /**
     * 设置两个点位置向量
     * @param { THREE.Vector3[] } points [THREE.Vector3, THREE.Vector3]
     */
    setPoints(points: THREE.Vector3[]): void;
    getTypeName(): string;
    private getDirection;
    /**
     * 获取尺寸距离
     * */
    getDimText(): string;
    worldDraw(pWorldDraw: McGiWorldDraw): void;
    /**
     * 设置测量的开始点
     * @parma pt1 three.js坐标点位
     * */
    setPoint1(pt1: THREE.Vector3): void;
    /**
     * 设置测量的结束点
     * @parma pt1 three.js坐标点位
     * */
    setPoint2(pt2: THREE.Vector3): void;
    setColor(color: UnstableColor | UnstableColor[]): this;
    getGripPoints(): Array<THREE.Vector3>;
    moveGripPointsAt(index: number, offset: THREE.Vector3): boolean;
    dwgIn(obj: any): boolean;
    dwgOut(obj: any): object;
    create(): MxDbAlignedDimension;
}
export default MxDbAlignedDimension;
