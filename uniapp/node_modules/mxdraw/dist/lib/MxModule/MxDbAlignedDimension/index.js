import{addRegisterMxDbEntity}from"../../tools/registerMxDbEntity";import _ from"lodash";import McGiWorldDrawType from"../McGiWorldDrawType";import MxDbEntity from"../MxDbEntity";import MxThreeJS from"../MxThreeJS";import drawMxDbAlignedDimension from"./draw";const propertyDbKeys=["point1","point2","fontColor"];class MxDbAlignedDimension extends MxDbEntity{constructor(t){if(super(),this.point1=new THREE.Vector3,this.point2=new THREE.Vector3,t){const{points:e,fontColor:n}=t;e&&this.setPoints(e),n&&(this.fontColor=n)}}setPoints(t){const[e,n]=t;e&&(this.point1=e),n&&(this.point2=n)}getTypeName(){return"MxDbAlignedDimension"}getDirection(t,e,n){const i=new THREE.Vector3(t.x,t.y,0),o=new THREE.Vector3(1,0,0),r=t.angleTo(o);let a=-1;(r<7*Math.PI/18||r>10*Math.PI/18)&&e.x>n.x&&(a=1);const s=new THREE.Matrix4;return s.makeRotationZ(Math.PI/2*a),i.applyMatrix4(s),i}getDimText(){return new THREE.Vector3(this.point1.x-this.point2.x,this.point1.y-this.point2.y,0).length().toFixed(3)}worldDraw(t){if(t.getType()==McGiWorldDrawType.kWorldDraw||t.getType()==McGiWorldDrawType.kDynDragDraw){const e=this.point1,n=this.point2;let i,o,r,a,s,x,y;const c=new THREE.Vector3(e.x-n.x,e.y-n.y,0),p=this.getDirection(c,e,n),E=new THREE.Matrix4;E.makeScale(.01,.01,.01);const l=new THREE.Vector3(p.x,p.y,0);l.applyMatrix4(E);const h=new THREE.Vector3(e.x+l.x,e.y+l.y,0),w=new THREE.Vector3(n.x+l.x,n.y+l.y,0),M=this.getColor();x=MxThreeJS.createPoint(e,M),y=MxThreeJS.createPoint(n,M);{E.identity(),E.makeScale(.2,.2,0),new THREE.Vector3(p.x,p.y,0).applyMatrix4(E),E.identity(),E.makeScale(.02,.02,0);const r=new THREE.Vector3(p.x,p.y,0);r.applyMatrix4(E),t.drawLine(h,w),i=MxThreeJS.createLine(new THREE.Vector3(h.x+2*r.x,h.y+2*r.y,0),new THREE.Vector3(e.x+r.x,e.y+r.y,0),M),o=MxThreeJS.createLine(new THREE.Vector3(w.x+2*r.x,w.y+2*r.y,0),new THREE.Vector3(n.x+r.x,n.y+r.y,0),M)}{const i=new THREE.Vector3(1,0,0);let o=c.angleTo(i);const a=new THREE.Vector3(p.x,p.y,0);a.normalize();const s=e.distanceTo(n);c.y<0?o=o<Math.PI/2?2*Math.PI-o:Math.PI-o:o>Math.PI/2&&(o=Math.PI+o);const x=t.getMxObject();x&&(o-=x.getViewAngle());const y=this.getDimText();null!=(r=MxThreeJS.creatTextSprite(y,new THREE.Vector3(w.x+c.x/2+a.x*s/30,w.y+c.y/2+a.y*s/30,0),.07*s,o,this.fontColor||M))&&t.drawEntity(r)}{E.identity(),E.makeScale(.08,.08,.08);const t=new THREE.Matrix4;t.makeRotationZ(17*Math.PI/18);let e=new THREE.Vector3(c.x,c.y,0);e.applyMatrix4(E),e.applyMatrix4(t),t.identity(),t.makeRotationZ(17*-Math.PI/18);let n=new THREE.Vector3(c.x,c.y,0);n.applyMatrix4(E),n.applyMatrix4(t);const i=new Array;i.push(new THREE.Vector3(h.x,h.y,0),new THREE.Vector3(h.x+e.x,h.y+e.y,0),new THREE.Vector3(h.x+n.x,h.y+n.y,0)),a=MxThreeJS.createTriangle(i,M),t.identity(),t.makeRotationZ(Math.PI/18),(e=new THREE.Vector3(c.x,c.y,0)).applyMatrix4(E),e.applyMatrix4(t),t.identity(),t.makeRotationZ(-Math.PI/18),(n=new THREE.Vector3(c.x,c.y,0)).applyMatrix4(E),n.applyMatrix4(t);const o=new Array;o.push(new THREE.Vector3(w.x,w.y,0),new THREE.Vector3(w.x+e.x,w.y+e.y,0),new THREE.Vector3(w.x+n.x,w.y+n.y,0)),s=MxThreeJS.createTriangle(o,M)}t.drawEntity(i),t.drawEntity(o),a&&t.drawEntity(a),s&&t.drawEntity(s),t.drawEntity(x),t.drawEntity(y)}else t.drawLine(this.point1,this.point2)}setPoint1(t){this.point1=t}setPoint2(t){this.point2=t}setColor(t){return _.isArray(t)?([this.color=this.color,this.fontColor=this.fontColor||this.color]=t,console.log("this.fontColor : ",this.fontColor)):this.color=t,this}getGripPoints(){let t=[];return t.push(this.point1),t.push(this.point2),t}moveGripPointsAt(t,e){return 0==t?this.point1.add(e):(t=1)&&this.point2.add(e),!0}dwgIn(t){return this.onDwgIn(t),this.dwgInHelp(t,propertyDbKeys),!0}dwgOut(t){return this.onDwgOut(t),this.dwgOutHelp(t,propertyDbKeys),t}create(){return new MxDbAlignedDimension}}MxDbAlignedDimension.cmd="Mx_DimensionMeasurement",MxDbAlignedDimension.draw=drawMxDbAlignedDimension,addRegisterMxDbEntity(MxDbAlignedDimension);export default MxDbAlignedDimension;