import MxDbEntity from"../MxDbEntity";import McGiWorldDrawType from"../McGiWorldDrawType";import drawMxDbAnyLine from"./draw";import{addRegisterMxDbEntity}from"../../tools/registerMxDbEntity";const propertyDbKeys=["points"];class MxDbAnyLine extends MxDbEntity{constructor(){super(...arguments),this.points=[]}getTypeName(){return"MxDbAnyLine"}create(){return new MxDbAnyLine}worldDraw(t){let e=t.getMxObject();const n=(new THREE.Box3).setFromPoints(this.points);let r=new THREE.Vector3;if(n.getCenter(r),t.drawLines(this.points),t.getType()===McGiWorldDrawType.kSelectDraw){const i=new THREE.Vector3;n.getSize(i),i.addScalar(e.screenCoordLong2Doc(20));const o=i.x/2,s=i.y/2,y={x:r.x-o,y:r.y-s},x={x:r.x+o,y:r.y-s},d={x:r.x+o,y:r.y+s},p={x:r.x-o,y:r.y+s};t.drawLine(y.x,y.y,x.x,x.y),t.drawLine(x.x,x.y,d.x,d.y),t.drawLine(d.x,d.y,p.x,p.y),t.drawLine(p.x,p.y,y.x,y.y)}}setPoints(t){return this.points=t,this}getCenter(){const t=new THREE.Geometry;t.vertices=this.points;const e=new THREE.Vector3;return t.computeBoundingBox(),t.boundingBox.getCenter(e),e}getGripPoints(){return[this.getCenter()]}moveGripPointsAt(t,e){return 0===t&&this.points.forEach(t=>{t.add(e)}),!0}dwgIn(t){return this.onDwgIn(t),this.dwgInHelp(t,propertyDbKeys),!0}dwgOut(t){return this.onDwgOut(t),this.dwgOutHelp(t,propertyDbKeys),t}}MxDbAnyLine.cmd="Mx_AnyLine",MxDbAnyLine.draw=drawMxDbAnyLine,addRegisterMxDbEntity(MxDbAnyLine);export default MxDbAnyLine;