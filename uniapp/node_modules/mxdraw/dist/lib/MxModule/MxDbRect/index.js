import MxDbEntity from"../MxDbEntity";import{computeRectPoints,getToGenerateRoundedCorners,repairGeometryFaceVertexUvs}from"../../tools/three/index";import MxFun from"../MxFun";import McGiWorldDrawType from"../McGiWorldDrawType";import{addRegisterMxDbEntity}from"../../tools/registerMxDbEntity";import drawMxDbRect from"./draw";class MxDbRect extends MxDbEntity{constructor(){super(...arguments),this.cornerRadius=[],this.pt1=new THREE.Vector3,this.pt2=new THREE.Vector3,this.isSolidColorFill=!1,this.isLoadMaterialFromPath=!0,this.material=null}worldDraw(t){let e=computeRectPoints(this.pt1,this.pt2);if(this.cornerRadius.length>0&&(e=getToGenerateRoundedCorners(e,this.cornerRadius)),t.getType()!=McGiWorldDrawType.kWorldDraw)return e.push(e[0]),void t.drawLines(e);const i={transparent:!0,depthTest:!1,opacity:this.opacity,visible:this.visible};if(this.isSolidColorFill){let r;e=e.map(({x:t,y:e})=>new THREE.Vector2(t,e)),r=new THREE.ShapeGeometry(new THREE.Shape(e));let a=new THREE.MeshBasicMaterial(Object.assign({color:this.filter?this.filter._getFilterColor(this.color,this.opacity):new THREE.Color(this.color)},i)),s=new THREE.Mesh(r,a);t.drawEntity(s)}else if(this.fillImageSrc){if(this.material){e=e.map(({x:t,y:e})=>new THREE.Vector2(t,e));let r=this.material,a=new THREE.ShapeGeometry(new THREE.Shape(e));if(a=repairGeometryFaceVertexUvs(a),this.filter){const t=r.map;this.fillImageParam&&(this.fillImageParam.center&&(t.center=this.fillImageParam.center),this.fillImageParam.offset&&(t.offset=this.fillImageParam.offset),this.fillImageParam.repeat&&(t.repeat=this.fillImageParam.repeat),this.fillImageParam.rotation&&(t.rotation=this.fillImageParam.rotation));const e=this.filter._getFilterShaderData(t);r=new THREE.ShaderMaterial(Object.assign(Object.assign({},e),i))}r.depthTest=!1,r.transparent=!0,r.opacity=this.opacity,r.visible=this.visible;let s=new THREE.Mesh(a,r);t.drawEntity(s)}else if(this.fillImageSrc.length>0&&this.isLoadMaterialFromPath){let t=this;MxFun.loadImageMaterial(this.fillImageSrc,e=>{this.isLoadMaterialFromPath=!1,e&&(t.material=e,t.setNeedUpdateDisplay(),MxFun.updateDisplay())})}}else{let r=(new THREE.BufferGeometry).setFromPoints(e),a=new THREE.LineBasicMaterial(Object.assign({color:this.getColor()},i)),s=new THREE.LineLoop(r,a);t.drawEntity(s)}}getGripPoints(){let t=[];t.push(this.pt1);const e=new THREE.Line3(this.pt1,this.pt2);let i=new THREE.Vector3;return e.getCenter(i),t.push(i),t.push(this.pt2),t}moveGripPointsAt(t,e){return 0==t?this.pt1.add(e):1==t?(this.pt1.add(e),this.pt2.add(e)):2==t&&this.pt2.add(e),!0}dwgIn(t){return this.onDwgIn(t),this.pt1.copy(t.pt1),this.pt2.copy(t.pt2),this.isSolidColorFill=t.isSolidColorFill,this.fillImageSrc=t.fillImageSrc,this.fillImageParam=t.fillImageParam,this.cornerRadius=t.cornerRadius,this.filter=t.filter,this.isLoadMaterialFromPath=!0,this.material=null,!0}dwgOut(t){return this.onDwgOut(t),t.pt1=this.pt1,t.pt2=this.pt2,t.isSolidColorFill=this.isSolidColorFill,t.fillImageSrc=this.fillImageSrc,t.fillImageParam=this.fillImageParam,t.cornerRadius=this.cornerRadius,t.filter=this.filter,t}create(){return new MxDbRect}transformBy(t){this.pt1.applyMatrix4(t),this.pt2.applyMatrix4(t)}setRadius(t,e=!0){t instanceof Array?this.cornerRadius=t.map(t=>e?MxFun.screenCoordLong2Doc(t):t):this.cornerRadius=t>0?e?[MxFun.screenCoordLong2Doc(t),MxFun.screenCoordLong2Doc(t),MxFun.screenCoordLong2Doc(t),MxFun.screenCoordLong2Doc(t)]:[t,t,t,t]:[]}getTypeName(){return"MxDbRect"}getFilter(){return this.filter}setFilter(t){this.filter=t,this.isLoadMaterialFromPath=!0,this.material=null}setFillImagePath(t){this.fillImageSrc=t,this.isLoadMaterialFromPath=!0,this.material=null,this.fillImageSrc&&(this.isSolidColorFill=!1)}getFillImagePath(){return this.fillImageSrc}}MxDbRect.cmd="Mx_DrawRect",MxDbRect.draw=drawMxDbRect,addRegisterMxDbEntity(MxDbRect);export default MxDbRect;