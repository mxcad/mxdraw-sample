import {
  MxDbShape
} from "./chunk-56B5D36D.js";

// ../../../../../web/MxCADOnline/MxDrawPlugin/mxdraw-sample/uniapp/node_modules/mxdraw/dist/lib/MxModule/MxDbEllipseShape/index.js
var MxDbEllipseShape = class extends MxDbShape {
  constructor() {
    super(), this.center = new THREE.Vector3(), this.xRadius = 10, this.yRadius = 10, this.startAngle = 0, this.endAngle = 2 * Math.PI, this.clockwise = false, this.rotation = 0, this.isClosedToCenter = true, this._propertyDbKeys = [...this._propertyDbKeys, "center", "xRadius", "yRadius", "startAngle", "endAngle", "clockwise", "rotation", "isClosedToCenter"];
  }
  getTypeName() {
    return "MxDbEllipseShape";
  }
  setCenter(t) {
    return this.center = t, this;
  }
  setXRadius(t) {
    return this.xRadius = t, this;
  }
  setYRadius(t) {
    return this.yRadius = t, this;
  }
  setStartAngle(t) {
    return this.startAngle = t, this;
  }
  setEndAngle(t) {
    return this.endAngle = t, this;
  }
  setClockwise(t) {
    return this.clockwise = t, this;
  }
  setRotation(t) {
    return this.rotation = t, this;
  }
  setIsClosedToCenter(t) {
    return this.isClosedToCenter = t, this;
  }
  worldDraw(t) {
    this.drawEllipseShape(t);
  }
  drawEllipseShape(t) {
    let { startAngle: e, endAngle: s, clockwise: i } = this;
    const r = this.createEllipseCurve(), n = this.createPaths(r);
    let a, h = this.getShapePoints(n);
    return this._draw(t, h), this._drawStoreLine(t, h), { centralAngle: a = i ? s > e ? THREE.MathUtils.radToDeg(r.aEndAngle - r.aStartAngle) : 360 - Math.abs(THREE.MathUtils.radToDeg(r.aEndAngle - r.aStartAngle)) : e > s ? Math.abs(THREE.MathUtils.radToDeg(r.aEndAngle - r.aStartAngle)) : 360 - THREE.MathUtils.radToDeg(r.aEndAngle - r.aStartAngle), curve: r, points: h };
  }
  createEllipseCurve(t = this.center.x, e = this.center.y, s = this.xRadius, i = this.yRadius, r = this.startAngle, n = this.endAngle, a = this.clockwise, h = this.rotation) {
    return new THREE.EllipseCurve(t, e, s, i, r, n, a, h);
  }
  getCornerRadiusPoints(t) {
    return t;
  }
  getClosedPoints(t) {
    try {
      let e = (this._paths || new THREE.CatmullRomCurve3(t, false, "catmullrom", 0)).getLength();
      this.closedLine = this.getClosedLine(t);
      const s = this.closedLine.getLength();
      let i = this.curveSegments / e, r = 2.5 * (e > this.curveSegments ? s * i : 1);
      if (r > 20 * this.curveSegments && (r = 20 * this.curveSegments), r <= 0)
        return t;
      const n = this.closedLine.getPoints(r);
      return [...t, ...n];
    } catch (e) {
      return [...t, t[0]];
    }
  }
  getClosedLine(t) {
    const { isClosedToCenter: e, center: s } = this;
    let i = e ? [t[t.length - 1], s, t[0]] : [t[t.length - 1], t[0]];
    return new THREE.CatmullRomCurve3(i, false, "catmullrom", 0.01);
  }
  getGripPoints() {
    return [this.center];
  }
  moveGripPointsAt(t, e) {
    return 0 === t && this.center.add(e), true;
  }
};

export {
  MxDbEllipseShape
};
//# sourceMappingURL=chunk-FSS5QSU3.js.map
