import {
  MrxDbgUiPrPoint,
  MxDbEntity,
  MxFun_default,
  MxType_default,
  addRegisterMxDbEntity
} from "./chunk-EEK3ULSO.js";

// ../../../../../web/MxCADOnline/MxDrawPlugin/mxdraw-sample/uniapp/node_modules/mxdraw/dist/lib/MxModule/MxDbImage/draw.js
function drawMxDbImage() {
  const e = new MrxDbgUiPrPoint();
  e.setMessage("\n指定插入点:");
  let r = MxFun_default.getCurrentDraw();
  e.go((t) => {
    if (0 != t)
      return;
    let n = MxFun_default.screenCoordLong2Doc(300), o = MxFun_default.screenCoordLong2Doc(200);
    const d = e.value();
    let i = MxFun_default.screenCoord2Doc(10, 10);
    d.z = i.z;
    let a = new MxDbImage_default();
    a.setRenderOrder(MxType_default.MxDefaultRenderOrder.kCADMeshRenderOrder - 1), a.setPoint1(d);
    let x = new THREE.Vector3(d.x + n, d.y + o, d.z);
    a.setPoint2(x);
    let M = prompt("请填写图片网络地址", "https://cdn.pixabay.com/photo/2022/11/15/12/23/winter-7593872_960_720.jpg");
    M && (a.setImagePath(M), r.addMxEntity(a), a.addEvent("onStartGripEidt", () => (a.visible = false, a.setNeedUpdateDisplay(), { renderOrder: MxType_default.MxDefaultRenderOrder.kCADMeshRenderOrder - 1 })), a.addEvent("onEndGripEidt", () => {
      a.visible = true, a.setNeedUpdateDisplay();
    }));
  });
}

// ../../../../../web/MxCADOnline/MxDrawPlugin/mxdraw-sample/uniapp/node_modules/mxdraw/dist/lib/MxModule/MxDbImage/index.js
var MxDbImage = class extends MxDbEntity {
  constructor() {
    super(...arguments), this.pt1 = new THREE.Vector3(), this.pt2 = new THREE.Vector3(), this.imagePath = "", this.isLoadMaterialFromPath = true, this.material = null, this.angle = 0;
  }
  getTypeName() {
    return "MxDbImage";
  }
  getAngle() {
    return this.angle;
  }
  setAngle(t) {
    this.angle = t;
  }
  worldDraw(t) {
    let e = new THREE.Vector3(this.pt1.x, this.pt2.y), i = new THREE.Vector3(this.pt2.x, this.pt1.y);
    if (Math.abs(this.angle) > 1e-5) {
      let e2 = new THREE.Vector3(0.5 * (this.pt1.x - this.pt2.x) + this.pt2.x, 0.5 * (this.pt1.y - this.pt2.y) + this.pt2.y), i2 = new THREE.Matrix4();
      i2.makeRotationZ(this.angle);
      let a = new THREE.Matrix4().makeTranslation(e2.x, e2.y, e2.z).multiply(i2).multiply(new THREE.Matrix4().makeTranslation(-e2.x, -e2.y, -e2.z));
      t.setMatrix(a);
    }
    if (1 == t.getType()) {
      if (t.drawSelectLine(this.pt1, e), t.drawSelectLine(e, this.pt2), t.drawSelectLine(this.pt2, i), t.drawSelectLine(i, this.pt1), this.material) {
        let e2 = Math.abs(this.pt1.x - this.pt2.x), i2 = Math.abs(this.pt1.y - this.pt2.y), a = new THREE.PlaneGeometry(e2, i2), s = Math.min(this.pt1.x, this.pt2.x), h = Math.min(this.pt1.y, this.pt2.y);
        for (let t2 = 0; t2 < a.vertices.length; t2++)
          a.vertices[t2].x += s + 0.5 * e2, a.vertices[t2].y += h + 0.5 * i2, a.vertices[t2].z = 0;
        let r = new THREE.Mesh(a, this.material);
        r.material.depthTest = false, t.drawEntity(r);
      } else if (this.imagePath.length > 0 && this.isLoadMaterialFromPath) {
        let e2 = this, i2 = t.getMxObject();
        MxFun_default.loadImageMaterial(this.imagePath, (t2) => {
          this.isLoadMaterialFromPath = false, t2 && (e2.setMaterial(t2), e2.setNeedUpdateDisplay(), i2.updateDisplay());
        });
      }
    } else if (this.material) {
      let e2 = Math.abs(this.pt1.x - this.pt2.x), i2 = Math.abs(this.pt1.y - this.pt2.y), a = new THREE.PlaneGeometry(e2, i2), s = Math.min(this.pt1.x, this.pt2.x), h = Math.min(this.pt1.y, this.pt2.y);
      for (let t2 = 0; t2 < a.vertices.length; t2++)
        a.vertices[t2].x += s + 0.5 * e2, a.vertices[t2].y += h + 0.5 * i2, a.vertices[t2].z = 0;
      let r = new THREE.Mesh(a, this.material);
      r.material.depthTest = false, t.drawEntity(r);
    } else
      t.drawLine(this.pt1, e), t.drawLine(e, this.pt2), t.drawLine(this.pt2, i), t.drawLine(i, this.pt1);
    t.setMatrix(null);
  }
  setImagePath(t) {
    this.imagePath = t, this.isLoadMaterialFromPath = true, this.material = null;
  }
  getImagePath() {
    return this.imagePath;
  }
  setMaterial(t) {
    this.material = t;
  }
  loadMaterial(t) {
    t && (this.imagePath = t), this.isLoadMaterialFromPath = false, this.material = null;
    let e = this;
    MxFun_default.loadImageMaterial(this.imagePath, (t2) => {
      this.isLoadMaterialFromPath = false, e.setMaterial(t2);
    });
  }
  setPoint1(t) {
    this.pt1 = t;
  }
  getPoint1() {
    return this.pt1;
  }
  setPoint2(t) {
    this.pt2 = t;
  }
  getPoint2() {
    return this.pt2;
  }
  getGripPoints() {
    let t = [];
    t.push(this.pt1), t.push(this.pt2);
    let e = new THREE.Vector3(this.pt1.x + 0.5 * (this.pt2.x - this.pt1.x), this.pt1.y + 0.5 * (this.pt2.y - this.pt1.y));
    return t.push(e), t;
  }
  moveGripPointsAt(t, e) {
    return 0 == t ? this.pt1.add(e) : 1 == t ? this.pt2.add(e) : 2 == t && (this.pt1.add(e), this.pt2.add(e)), true;
  }
  dwgIn(t) {
    return this.onDwgIn(t), this.pt1.copy(t.pt1), this.pt2.copy(t.pt2), this.imagePath = t.imagePath.substr(0), this.isLoadMaterialFromPath = true, t.angle && (this.angle = t.angle), t.material && (this.material = t.material), true;
  }
  dwgOut(t) {
    return this.onDwgOut(t), t.pt1 = this.pt1, t.pt2 = this.pt2, t.imagePath = this.imagePath, t.angle = this.angle, t.type == MxType_default.MxCloneType.kDragClone && (t.material = this.material), t;
  }
  create() {
    return new MxDbImage();
  }
};
MxDbImage.cmd = "Mx_DrawImage", MxDbImage.draw = drawMxDbImage, addRegisterMxDbEntity(MxDbImage);
var MxDbImage_default = MxDbImage;

export {
  MxDbImage_default
};
//# sourceMappingURL=chunk-CXTPH6BJ.js.map
