import {
  McGiWorldDrawType_default
} from "./chunk-3EHWTHVA.js";
import {
  MrxDbgUiPrPoint,
  MxDbEntity,
  MxFun_default,
  MxType_default,
  addRegisterMxDbEntity
} from "./chunk-EEK3ULSO.js";

// ../../../../../web/MxCADOnline/MxDrawPlugin/mxdraw-sample/uniapp/node_modules/mxdraw/dist/lib/MxModule/MxDbText/draw.js
var __awaiter = function(t, n, e, r) {
  return new (e || (e = Promise))(function(o, i) {
    function u(t2) {
      try {
        x(r.next(t2));
      } catch (t3) {
        i(t3);
      }
    }
    function a(t2) {
      try {
        x(r.throw(t2));
      } catch (t3) {
        i(t3);
      }
    }
    function x(t2) {
      var n2;
      t2.done ? o(t2.value) : (n2 = t2.value, n2 instanceof e ? n2 : new e(function(t3) {
        t3(n2);
      })).then(u, a);
    }
    x((r = r.apply(t, n || [])).next());
  });
};
function drawMxDbText() {
  return __awaiter(this, void 0, void 0, function* () {
    const t = new MrxDbgUiPrPoint();
    t.setMessage("\n 点取文字插入点:");
    let n = yield t.go();
    if (null == n)
      return;
    let e = prompt("请输入文字");
    if (!e)
      return;
    let r = new MxDbText();
    r.position = n, r.height = MxFun_default.screenCoordLong2Doc(50), r.text = e;
    MxFun_default.addToCurrentSpace(r);
  });
}

// ../../../../../web/MxCADOnline/MxDrawPlugin/mxdraw-sample/uniapp/node_modules/mxdraw/dist/lib/MxModule/MxDbText/SpriteText.js
var __awaiter2 = function(t, e, i, o) {
  return new (i || (i = Promise))(function(s, h) {
    function r(t2) {
      try {
        a(o.next(t2));
      } catch (t3) {
        h(t3);
      }
    }
    function n(t2) {
      try {
        a(o.throw(t2));
      } catch (t3) {
        h(t3);
      }
    }
    function a(t2) {
      var e2;
      t2.done ? s(t2.value) : (e2 = t2.value, e2 instanceof i ? e2 : new i(function(t3) {
        t3(e2);
      })).then(r, n);
    }
    a((o = o.apply(t, e || [])).next());
  });
};
var _SpriteText;
function getSpriteTextColor(t) {
  return t ? t instanceof THREE.Color ? t.getStyle() : "number" == typeof t ? new THREE.Color(t).getStyle() : t : "#fff";
}
function toCSSFont(t, e, i, o, s) {
  let h = document.createElement("span");
  return h.style.font = "1px serif", h.style.fontFamily = t, h.style.fontSize = `${e}px`, h.style.fontStyle = i, h.style.fontVariant = o, h.style.fontWeight = s, h.style.font;
}
function getSpriteTextClass() {
  if (!_SpriteText) {
    class t extends THREE.Sprite {
      constructor(t2) {
        super(new THREE.SpriteMaterial());
        const { text: e, textHeight: i, color: o, backgroundColor: s, padding: h, borderWidth: r, borderRadius: n, borderColor: a, strokeWidth: d, strokeColor: l, fontFace: g, fontSize: f, fontWeight: c, textAlign: _, textShadowBlur: u, textShadowColor: x, textShadowOffsetX: S, textShadowOffsetY: C, angle: w, scale: p, underline: b, fontStyle: v, fontVariant: m } = t2 || {};
        this._text = `${e}`, this._textHeight = i || 10, this._color = o, this._backgroundColor = s, this._padding = h || 0, this._borderWidth = r || 0, this._borderRadius = n || 0, this._borderColor = a || "white", this._strokeWidth = d || 0, this._strokeColor = l || "white", this._fontFace = g || "Arial", this._fontSize = f || 90, this._fontWeight = (null === c || void 0 === c ? void 0 : c.toString()) || "normal", this._textAlign = _ || "start", this._fontStyle = v || "normal", this._fontVariant = m || "normal", this._textShadowBlur = u || 0, this._textShadowColor = x, this._textShadowOffsetX = S || 0, this._textShadowOffsetY = C || 0, this._angle = w || 0, this._textScale = p || 1, this._underline = b || false, this._canvas = document.createElement("canvas"), this._genCanvas();
      }
      get text() {
        return this._text;
      }
      set text(t2) {
        this._text = t2, this._genCanvas();
      }
      get textHeight() {
        return this._textHeight;
      }
      set textHeight(t2) {
        this._textHeight = t2, this._genCanvas();
      }
      get color() {
        return this._color;
      }
      set color(t2) {
        this._color = t2, this._genCanvas();
      }
      get backgroundColor() {
        return this._backgroundColor;
      }
      set backgroundColor(t2) {
        this._backgroundColor = t2, this._genCanvas();
      }
      get padding() {
        return this._padding;
      }
      set padding(t2) {
        this._padding = t2, this._genCanvas();
      }
      get borderWidth() {
        return this._borderWidth;
      }
      set borderWidth(t2) {
        this._borderWidth = t2, this._genCanvas();
      }
      get borderRadius() {
        return this._borderRadius;
      }
      set borderRadius(t2) {
        this._borderRadius = t2, this._genCanvas();
      }
      get borderColor() {
        return this._borderColor;
      }
      set borderColor(t2) {
        this._borderColor = t2, this._genCanvas();
      }
      get fontFace() {
        return this._fontFace;
      }
      set fontFace(t2) {
        this._fontFace = t2, this._genCanvas();
      }
      get fontSize() {
        return this._fontSize;
      }
      set fontSize(t2) {
        this._fontSize = t2, this._genCanvas();
      }
      get fontWeight() {
        return this._fontWeight;
      }
      set fontWeight(t2) {
        this._fontWeight = t2, this._genCanvas();
      }
      get strokeWidth() {
        return this._strokeWidth;
      }
      set strokeWidth(t2) {
        this._strokeWidth = t2, this._genCanvas();
      }
      get strokeColor() {
        return this._strokeColor;
      }
      set strokeColor(t2) {
        this._strokeColor = t2, this._genCanvas();
      }
      get textAlign() {
        return this._textAlign;
      }
      set textAlign(t2) {
        this._textAlign = t2, this._genCanvas();
      }
      get textShadowBlur() {
        return this._textShadowBlur;
      }
      set textShadowBlur(t2) {
        this._textShadowBlur = t2, this._genCanvas();
      }
      get textShadowColor() {
        return this._textShadowColor;
      }
      set textShadowColor(t2) {
        this._textShadowColor = t2, this._genCanvas();
      }
      get textShadowOffsetX() {
        return this._textShadowOffsetX;
      }
      set textShadowOffsetX(t2) {
        this._textShadowOffsetX = t2, this._genCanvas();
      }
      get textShadowOffsetY() {
        return this._textShadowOffsetY;
      }
      set textShadowOffsetY(t2) {
        this._textShadowOffsetY = t2, this._genCanvas();
      }
      get angle() {
        return this._angle;
      }
      set angle(t2) {
        this._angle = t2, this._genCanvas();
      }
      get textScale() {
        return this._textScale;
      }
      set textScale(t2) {
        this._textScale = t2, this._genCanvas();
      }
      get underline() {
        return this._underline;
      }
      set underline(t2) {
        this._underline = t2, this._genCanvas();
      }
      get fontStyle() {
        return this._fontStyle;
      }
      set fontStyle(t2) {
        this._fontStyle = t2, this._genCanvas();
      }
      get fontVariant() {
        return this._fontVariant;
      }
      set fontVariant(t2) {
        this._fontVariant = t2, this._genCanvas();
      }
      _genCanvas() {
        const t2 = this._canvas, e = t2.getContext("2d"), i = Array.isArray(this.borderWidth) ? this.borderWidth : [this.borderWidth, this.borderWidth], o = i.map((t3) => t3 * this.fontSize * 0.1), s = (Array.isArray(this.borderRadius) ? this.borderRadius : [this.borderRadius, this.borderRadius, this.borderRadius, this.borderRadius]).map((t3) => t3 * this.fontSize * 0.1), h = Array.isArray(this.padding) ? this.padding : [this.padding, this.padding], r = h.map((t3) => t3 * this.fontSize * 0.1), n = this.text.split("\n"), a = this.font;
        e.font = a;
        const d = Math.max(...n.map((t3) => e.measureText(t3).width)), l = 4 * this.strokeWidth + (this.underline ? this.fontSize / 15 * 4 : this.fontSize / 15), g = (this.fontSize + l) * n.length;
        if (t2.width = d + 2 * o[0] + 2 * r[0], t2.height = g + 2 * o[1] + 2 * r[1], this.borderWidth) {
          if (e.strokeStyle = getSpriteTextColor(this.borderColor), o[0]) {
            const i2 = o[0] / 2;
            e.lineWidth = o[0], e.beginPath(), e.moveTo(i2, s[0]), e.lineTo(i2, t2.height - s[3]), e.moveTo(t2.width - i2, s[1]), e.lineTo(t2.width - i2, t2.height - s[2]), e.stroke();
          }
          if (o[1]) {
            const i2 = o[1] / 2;
            e.lineWidth = o[1], e.beginPath(), e.moveTo(Math.max(o[0], s[0]), i2), e.lineTo(t2.width - Math.max(o[0], s[1]), i2), e.moveTo(Math.max(o[0], s[3]), t2.height - i2), e.lineTo(t2.width - Math.max(o[0], s[2]), t2.height - i2), e.stroke();
          }
          if (this.borderRadius) {
            const i2 = Math.max(...o), h2 = i2 / 2;
            e.lineWidth = i2, e.beginPath(), [!!s[0] && [s[0], h2, h2, s[0]], !!s[1] && [t2.width - s[1], t2.width - h2, h2, s[1]], !!s[2] && [t2.width - s[2], t2.width - h2, t2.height - h2, t2.height - s[2]], !!s[3] && [s[3], h2, t2.height - h2, t2.height - s[3]]].filter((t3) => t3).forEach((t3) => {
              const [i3, o2, s2, h3] = t3;
              e.moveTo(i3, s2), e.quadraticCurveTo(o2, s2, o2, h3);
            }), e.stroke();
          }
        }
        this.backgroundColor && (e.fillStyle = getSpriteTextColor(this.backgroundColor), this.borderRadius ? (e.beginPath(), e.moveTo(o[0], s[0]), [[o[0], s[0], t2.width - s[1], o[1], o[1], o[1]], [t2.width - o[0], t2.width - o[0], t2.width - o[0], o[1], s[1], t2.height - s[2]], [t2.width - o[0], t2.width - s[2], s[3], t2.height - o[1], t2.height - o[1], t2.height - o[1]], [o[0], o[0], o[0], t2.height - o[1], t2.height - s[3], s[0]]].forEach(([t3, i2, o2, s2, h2, r2]) => {
          e.quadraticCurveTo(t3, s2, i2, h2), e.lineTo(o2, r2);
        }), e.closePath(), e.fill()) : e.fillRect(o[0], o[1], t2.width - 2 * o[0], t2.height - 2 * o[1])), e.translate(o[0], o[1]), e.translate(r[0], r[1]), e.font = a, e.fillStyle = getSpriteTextColor(this.color), e.textBaseline = "bottom", e.shadowBlur = this.textShadowBlur, e.shadowColor = new THREE.Color(this.textShadowColor).getStyle(), e.shadowOffsetX = this.textShadowOffsetX, e.shadowOffsetY = this.textShadowOffsetY;
        const f = this.strokeWidth > 0;
        f && (e.lineWidth = this.strokeWidth * this.fontSize / 10, e.strokeStyle = getSpriteTextColor(this.strokeColor));
        const c = "center" === this.textAlign, _ = "start" === this.textAlign || "left" === this.textAlign;
        n.forEach((t3, i2) => __awaiter2(this, void 0, void 0, function* () {
          let o2 = c ? 2 : 1;
          const s2 = e.measureText(t3).width, h2 = _ ? 0 : (d - s2) / o2, r2 = (i2 + 1) * (this.fontSize + l);
          f && e.strokeText(t3, h2, r2), e.fillText(t3, h2, r2), this.underline && e.fillRect(h2, r2, s2, this.fontSize / 15);
        })), this.material.map && this.material.map.dispose();
        const u = this.material.map = new THREE.Texture(t2);
        u.minFilter = THREE.LinearFilter, u.needsUpdate = true;
        const x = this.textHeight * n.length + 2 * i[1] + 2 * h[1], S = x * t2.width / t2.height;
        this.scale.set(S, x, this.scale.z), this.material.rotation = this.angle, this.scale.applyMatrix4(new THREE.Matrix4().makeScale(this.textScale, this.textScale, 1));
      }
      clone() {
        return new (0, this.constructor)(this.text, this.textHeight, this.color).copy(this);
      }
      copy(t2) {
        return THREE.Sprite.prototype.copy.call(this, t2), this.color = t2.color, this.backgroundColor = t2.backgroundColor, this.padding = t2.padding, this.borderWidth = t2.borderWidth, this.borderColor = t2.borderColor, this.fontFace = t2.fontFace, this.fontSize = t2.fontSize, this.fontWeight = t2.fontWeight, this.strokeWidth = t2.strokeWidth, this.strokeColor = t2.strokeColor, this.textAlign = t2.textAlign, this.textShadowBlur = t2.textShadowBlur, this.textShadowColor = t2.textShadowColor, this.textShadowOffsetX = t2.textShadowOffsetX, this.textShadowOffsetY = t2.textShadowOffsetY, this.angle = t2.angle, this.textScale = t2.textScale, this;
      }
      get font() {
        return toCSSFont(this.fontFace, this.fontSize, this.fontStyle, this.fontVariant, this.fontWeight);
      }
      checkFontFace() {
        try {
          const { fontFace: t2 } = this;
          return document.fonts.check(t2);
        } catch (t2) {
        }
        return true;
      }
      loadFontFace() {
        return __awaiter2(this, void 0, void 0, function* () {
          try {
            const { fontFace: t2 } = this;
            yield document.fonts.load(t2);
          } catch (t2) {
          }
        });
      }
      dispose() {
        var t2;
        null === (t2 = this.material.map) || void 0 === t2 || t2.dispose(), this.material.dispose(), this.geometry.dispose(), this.dispatchEvent({ type: "dispose" });
      }
    }
    _SpriteText = t;
  }
  return _SpriteText;
}

// ../../../../../web/MxCADOnline/MxDrawPlugin/mxdraw-sample/uniapp/node_modules/mxdraw/dist/lib/MxModule/MxDbText/MxDbText.js
var propertyDbKeys = ["text", "position", "height", "backgroundColor", "padding", "borderWidth", "borderRadius", "borderColor", "fontFace", "fontSize", "fontWeight", "strokeWidth", "strokeColor", "angle", "textAlign", "textShadowBlur", "textShadowColor", "textShadowOffsetX", "textShadowOffsetY", "scale", "underline"];
var MxDbText = class extends MxDbEntity {
  constructor() {
    super(...arguments), this.position = new THREE.Vector3(), this._text = "", this._height = 16, this._angle = 0, this._scale = 1, this._underline = false;
  }
  setPosition(t) {
    return this.position = t, this;
  }
  get text() {
    return this.spriteText ? this.spriteText.text : this._text;
  }
  set text(t) {
    this.spriteText ? this.spriteText.text = t : this._text = t;
  }
  setText(t) {
    return this.text = t, this;
  }
  get height() {
    return this.spriteText ? this.spriteText.textHeight : this._height;
  }
  set height(t) {
    this.spriteText ? this.spriteText.textHeight = t : this._height = t;
  }
  setHeight(t) {
    return this.height = t, this;
  }
  get backgroundColor() {
    return this.spriteText ? this.spriteText.backgroundColor : this._backgroundColor;
  }
  set backgroundColor(t) {
    this.spriteText ? this.spriteText.backgroundColor = t : this._backgroundColor = t;
  }
  setBackgroundColor(t) {
    return this.backgroundColor = t, this;
  }
  get padding() {
    return this.spriteText ? this.spriteText.padding : this._padding;
  }
  set padding(t) {
    this.spriteText ? this.spriteText.padding = t : this._padding = t;
  }
  setPadding(t) {
    return this.padding = t, this;
  }
  get borderWidth() {
    return this.spriteText ? this.spriteText.borderWidth : this._borderWidth;
  }
  set borderWidth(t) {
    this.spriteText ? this.spriteText.borderWidth = t : this._borderWidth = t;
  }
  setBorderWidth(t) {
    return this.borderWidth = t, this;
  }
  get borderRadius() {
    return this.spriteText ? this.spriteText.borderRadius : this._borderRadius;
  }
  set borderRadius(t) {
    this.spriteText ? this.spriteText.borderRadius = t : this._borderRadius = t;
  }
  setBorderRadius(t) {
    return this.borderRadius = t, this;
  }
  get borderColor() {
    return this.spriteText ? this.spriteText.borderColor : this._borderColor;
  }
  set borderColor(t) {
    this.spriteText ? this.spriteText.borderColor = t : this._borderColor = t;
  }
  setBorderColor(t) {
    return this.borderColor = t, this;
  }
  get fontFace() {
    return this.spriteText ? this.spriteText.fontFace : this._fontFace;
  }
  set fontFace(t) {
    this.spriteText ? this.spriteText.fontFace = t : this._fontFace = t;
  }
  setFontFace(t) {
    return this.fontFace = t, this;
  }
  get fontSize() {
    return this.spriteText ? this.spriteText.fontSize : this._fontSize;
  }
  set fontSize(t) {
    this.spriteText ? this.spriteText.fontSize = t : this._fontSize = t;
  }
  setFontSize(t) {
    return this.fontSize = t, this;
  }
  get fontWeight() {
    return this.spriteText ? this.spriteText.fontWeight : this._fontWeight;
  }
  set fontWeight(t) {
    this.spriteText ? this.spriteText.fontWeight = t : this._fontWeight = t;
  }
  setFontWeight(t) {
    return this.fontWeight = t, this;
  }
  get strokeWidth() {
    return this.spriteText ? this.spriteText.strokeWidth : this._strokeWidth;
  }
  set strokeWidth(t) {
    this.spriteText ? this.spriteText.strokeWidth = t : this._strokeWidth = t;
  }
  setStrokeWidth(t) {
    return this.strokeWidth = t, this;
  }
  get strokeColor() {
    return this.spriteText ? this.spriteText.strokeColor : this._strokeColor;
  }
  set strokeColor(t) {
    this.spriteText ? this.spriteText.strokeColor = t : this._strokeColor = t;
  }
  setStrokeColor(t) {
    return this.strokeColor = t, this;
  }
  get textAlign() {
    return this.spriteText ? this.spriteText.textAlign : this._textAlign;
  }
  set textAlign(t) {
    this.spriteText ? this.spriteText.textAlign = t : this._textAlign = t;
  }
  setTextAlign(t) {
    return this.textAlign = t, this;
  }
  get textShadowBlur() {
    return this.spriteText ? this.spriteText.textShadowBlur : this._textShadowBlur;
  }
  set textShadowBlur(t) {
    this.spriteText ? this.spriteText.textShadowBlur = t : this._textShadowBlur = t;
  }
  setTextShadowBlur(t) {
    return this.textShadowBlur = t, this;
  }
  get textShadowColor() {
    return this.spriteText ? this.spriteText.textShadowColor : this._textShadowColor;
  }
  set textShadowColor(t) {
    this.spriteText ? this.spriteText.textShadowColor = t : this._textShadowColor = t;
  }
  setTextShadowColor(t) {
    return this.textShadowColor = t, this;
  }
  get textShadowOffsetX() {
    return this.spriteText ? this.spriteText.textShadowOffsetX : this._textShadowOffsetX;
  }
  set textShadowOffsetX(t) {
    this.spriteText ? this.spriteText.textShadowOffsetX = t : this._textShadowOffsetX = t;
  }
  setTextShadowOffsetX(t) {
    return this.textShadowOffsetX = t, this;
  }
  get textShadowOffsetY() {
    return this.spriteText ? this.spriteText.textShadowOffsetY : this._textShadowOffsetY;
  }
  set textShadowOffsetY(t) {
    this.spriteText ? this.spriteText.textShadowOffsetY = t : this._textShadowOffsetY = t;
  }
  setTextShadowOffsetY(t) {
    return this.textShadowOffsetY = t, this;
  }
  get angle() {
    return this.spriteText ? this.spriteText.angle : this._angle;
  }
  set angle(t) {
    this.spriteText ? this.spriteText.angle = t : this._angle = t;
  }
  setAngle(t) {
    return this.angle = t, this;
  }
  get scale() {
    return this.spriteText ? this.spriteText.textScale : this._scale;
  }
  set scale(t) {
    this.spriteText ? this.spriteText.textScale = t : this._scale = t;
  }
  setScale(t) {
    return this.scale = t, this;
  }
  get underline() {
    return this.spriteText ? this.spriteText.underline : this._underline;
  }
  set underline(t) {
    this.spriteText ? this.spriteText.underline = t : this._underline = t;
  }
  setUnderline(t) {
    this.underline = t;
  }
  getTypeName() {
    return "MxDbText";
  }
  worldDraw(t) {
    if (this.text.length > 0) {
      t.getType() !== McGiWorldDrawType_default.kWorldDraw || this.spriteText || this.createSpriteText(), this.color !== this.spriteText.color && (this.spriteText.color = this.color), this.spriteText.material.setValues({ opacity: this.opacity, visible: this.visible });
      const { x: e, y: i, z: s } = this.position;
      this.spriteText.position.set(e, i, s), t.drawEntity(this.spriteText);
    }
  }
  createSpriteText() {
    const t = getSpriteTextClass(), { text: e, height: i, color: s, backgroundColor: r, padding: o, borderWidth: h, borderRadius: x, borderColor: n, strokeWidth: d, strokeColor: p, fontFace: a, fontSize: l, fontWeight: T, textAlign: g, textShadowBlur: u, textShadowColor: f, textShadowOffsetX: S, textShadowOffsetY: w, angle: c, scale: b, underline: C } = this;
    this.spriteText = new t({ text: e, textHeight: i, color: s, backgroundColor: r, padding: o, borderWidth: h, borderRadius: x, borderColor: n, strokeWidth: d, strokeColor: p, fontFace: a, fontSize: l, fontWeight: T, textAlign: g, textShadowBlur: u, textShadowColor: f, textShadowOffsetX: S, textShadowOffsetY: w, angle: c, scale: b, underline: C });
  }
  getGripPoints() {
    return [this.position];
  }
  moveGripPointsAt(t, e) {
    return 0 === t && this.position.add(e), true;
  }
  create() {
    return new MxDbText();
  }
  dwgIn(t) {
    return this.onDwgIn(t), this.dwgInHelp(t, propertyDbKeys), t.type === MxType_default.MxCloneType.kMxFileClone || t.type === MxType_default.MxCloneType.kSaveDwgClone ? this.createSpriteText() : this.spriteText = t.spriteText, true;
  }
  dwgOut(t) {
    return this.onDwgOut(t), this.dwgOutHelp(t, propertyDbKeys), t.type === MxType_default.MxCloneType.kMxFileClone || t.type === MxType_default.MxCloneType.kSaveDwgClone ? t.spriteText = void 0 : t.spriteText = this.spriteText, t;
  }
  getGeomExtents() {
    return new THREE.Box3().expandByObject(this.spriteText);
  }
  erase() {
    return super.erase(), this.spriteText && this.spriteText.dispose(), true;
  }
};
MxDbText.cmd = "Mx_Text", MxDbText.draw = drawMxDbText;

// ../../../../../web/MxCADOnline/MxDrawPlugin/mxdraw-sample/uniapp/node_modules/mxdraw/dist/lib/MxModule/MxDbText/index.js
addRegisterMxDbEntity(MxDbText);
var MxDbText_default = MxDbText;

export {
  MxDbText_default
};
//# sourceMappingURL=chunk-QNMYWVNI.js.map
