import {
  McGiWorldDrawType_default
} from "./chunk-3EHWTHVA.js";
import {
  McEdGetPointWorldDrawObject,
  MrxDbgUiPrPoint,
  MxDbEntity,
  MxFun_default,
  MxType_default,
  addRegisterMxDbEntity
} from "./chunk-EEK3ULSO.js";

// ../../../../../web/MxCADOnline/MxDrawPlugin/mxdraw-sample/uniapp/node_modules/mxdraw/dist/lib/MxModule/MxDbCloudLine/draw.js
function drawMxDbCloudLine() {
  const t = new MrxDbgUiPrPoint(), o = MxFun_default.getCurrentDraw(), e = new McEdGetPointWorldDrawObject();
  t.setMessage("\n点击开启绘制云线:"), t.go(() => {
    const n = MxFun_default.screenCoordLong2Doc(16);
    let r = t.value();
    const i = new MxDbCloudLine_default();
    i.setRadius(n), i.addPoint(r), e.setDraw((t2) => {
      r.distanceTo(t2) > n && (r = t2.clone(), i.addPoint(t2, true)), e.drawCustomEntity(i);
    }), t.setUserDraw(e), t.setMessage("\n再次点击结束绘制云线:"), t.go(() => {
      o.addMxEntity(i);
    });
  });
}

// ../../../../../web/MxCADOnline/MxDrawPlugin/mxdraw-sample/uniapp/node_modules/mxdraw/dist/lib/MxModule/MxDbCloudLine/index.js
var propertyDbKeys = ["points", "radius"];
var MxDbCloudLine = class extends MxDbEntity {
  constructor() {
    super(...arguments), this.points = [], this.radius = 16, this.cachePoint = null;
  }
  getTypeName() {
    return "MxDbCloudLine";
  }
  create() {
    return new MxDbCloudLine();
  }
  setRadius(t) {
    this.radius = t;
  }
  getRadius() {
    return this.radius;
  }
  getCachePoint() {
    return this.cachePoint;
  }
  clacNewArcDiameterPoint(t) {
    if (0 == this.points.length)
      return t;
    let e = this.points[this.points.length - 1];
    const n = 2 * this.radius, i = e.distanceTo(t);
    if (i < n)
      return null;
    const r = n * (t.x - e.x) / i + e.x, o = n * (t.y - e.y) / i + e.y;
    return new THREE.Vector3(r, o, e.z);
  }
  createCloudArcCurvePoints(t, e, n) {
    const i = new THREE.Vector3((t.x + e.x) / 2, (t.y + e.y) / 2, 0);
    n || (n = i.distanceTo(t));
    const { startAngle: r, endAngle: o } = function(t2, e2, n2) {
      const i2 = 2 * Math.PI / 360;
      return { startAngle: 180 * Math.atan2(e2.y - t2.y, e2.x - t2.x) / Math.PI * i2, endAngle: 180 * Math.atan2(n2.y - t2.y, n2.x - t2.x) / Math.PI * i2 };
    }(i, t, e);
    return new THREE.ArcCurve(i.x, i.y, n, r, o, true).getPoints(10);
  }
  addPoint(t, e) {
    let n = this.clacNewArcDiameterPoint(t);
    n && (this.points.push(n), this.cachePoint = null, e && (this.cachePoint = this.reCalculateDrawGeometryPoint()));
  }
  addLine(t, e) {
    this.addPoint(t);
    const n = 2 * this.radius;
    let i = this.points[this.points.length - 1], r = i.distanceTo(e);
    const o = Math.round(r / n);
    for (let t2 = 0; t2 < o; t2++) {
      r = i.distanceTo(e);
      const t3 = n * (e.x - i.x) / r + i.x, o2 = n * (e.y - i.y) / r + i.y;
      let s = new THREE.Vector3(t3, o2, e.z);
      this.addPoint(s), i = s;
    }
    return this.points[this.points.length - 1];
  }
  reCalculateDrawGeometryPoint() {
    if (this.points.length < 2)
      return null;
    let t = this.points[0], e = this.points.length, n = [];
    for (let i = 1; i < e; i++) {
      let e2 = this.points[i];
      this.createCloudArcCurvePoints(t, e2).forEach((t2) => {
        n.push(new THREE.Vector3(t2.x, t2.y, 0));
      }), t = e2;
    }
    return n;
  }
  worldDraw(t) {
    if (this.cachePoint || (this.cachePoint = this.reCalculateDrawGeometryPoint()), this.cachePoint)
      if (t.getType() === McGiWorldDrawType_default.kSelectDraw) {
        let e = new THREE.Geometry();
        this.cachePoint.forEach((t2) => {
          e.vertices.push(new THREE.Vector3(t2.x, t2.y, 0));
        }), e.computeBoundingBox();
        const n = new THREE.Vector3();
        e.boundingBox.getSize(n);
        let i = new THREE.Vector3();
        e.boundingBox.getCenter(i);
        const r = n.x / 2, o = n.y / 2, s = { x: i.x - r, y: i.y - o }, a = { x: i.x + r, y: i.y - o }, c = { x: i.x + r, y: i.y + o }, h = { x: i.x - r, y: i.y + o };
        t.drawLine(s.x, s.y, a.x, a.y), t.drawLine(a.x, a.y, c.x, c.y), t.drawLine(c.x, c.y, h.x, h.y), t.drawLine(h.x, h.y, s.x, s.y);
      } else
        t.drawLines(this.cachePoint);
  }
  getCenter() {
    const t = new THREE.Geometry();
    t.vertices = this.points;
    let e = new THREE.Vector3();
    return t.computeBoundingBox(), t.boundingBox.getCenter(e), e;
  }
  getGripPoints() {
    return [this.getCenter()];
  }
  moveGripPointsAt(t, e) {
    return this.points.forEach((t2) => {
      t2.add(e);
    }), this.cachePoint = null, true;
  }
  dwgIn(t) {
    return this.onDwgIn(t), this.dwgInHelp(t, propertyDbKeys), this.cachePoint = null, true;
  }
  dwgOut(t) {
    return this.onDwgOut(t), this.dwgOutHelp(t, propertyDbKeys), t.type === MxType_default.MxCloneType.kSaveDwgClone && this.dwgOutHelp(t, ["cachePoint"]), t;
  }
};
MxDbCloudLine.isRegister = false, MxDbCloudLine.cmd = "Mx_CloudLine", MxDbCloudLine.draw = drawMxDbCloudLine, addRegisterMxDbEntity(MxDbCloudLine);
var MxDbCloudLine_default = MxDbCloudLine;

export {
  MxDbCloudLine_default
};
//# sourceMappingURL=chunk-WACUBFYC.js.map
