import {
  McGiWorldDrawType_default
} from "./chunk-3EHWTHVA.js";
import {
  McEdGetPointWorldDrawObject,
  MrxDbgUiPrPoint,
  MxDbEntity,
  MxFun_default,
  addRegisterMxDbEntity,
  computeRectPoints,
  getToGenerateRoundedCorners,
  repairGeometryFaceVertexUvs
} from "./chunk-EEK3ULSO.js";

// ../../../../../web/MxCADOnline/MxDrawPlugin/mxdraw-sample/uniapp/node_modules/mxdraw/dist/lib/MxModule/MxDbRect/draw.js
var __awaiter = function(t, e, n, r) {
  return new (n || (n = Promise))(function(o, i) {
    function a(t2) {
      try {
        s(r.next(t2));
      } catch (t3) {
        i(t3);
      }
    }
    function c(t2) {
      try {
        s(r.throw(t2));
      } catch (t3) {
        i(t3);
      }
    }
    function s(t2) {
      var e2;
      t2.done ? o(t2.value) : (e2 = t2.value, e2 instanceof n ? e2 : new n(function(t3) {
        t3(e2);
      })).then(a, c);
    }
    s((r = r.apply(t, e || [])).next());
  });
};
function drawMxDbRect() {
  return __awaiter(this, void 0, void 0, function* () {
    const t = new MrxDbgUiPrPoint();
    t.setMessage("\n指定第一点:");
    let e = yield t.go();
    if (!e)
      return;
    let n = new MxDbRect_default();
    n.pt1 = e;
    const r = new McEdGetPointWorldDrawObject();
    r.setDraw((t2) => {
      n.pt2 = t2, r.drawCustomEntity(n);
    }), t.setBasePt(e), t.setUseBasePt(true), t.setUserDraw(r), t.setMessage("\n指定第二点:"), (yield t.go()) && (n.pt2 = t.value(), MxFun_default.getCurrentDraw().addMxEntity(n));
  });
}

// ../../../../../web/MxCADOnline/MxDrawPlugin/mxdraw-sample/uniapp/node_modules/mxdraw/dist/lib/MxModule/MxDbRect/index.js
var MxDbRect = class extends MxDbEntity {
  constructor() {
    super(...arguments), this.cornerRadius = [], this.pt1 = new THREE.Vector3(), this.pt2 = new THREE.Vector3(), this.isSolidColorFill = false, this.isLoadMaterialFromPath = true, this.material = null;
  }
  worldDraw(t) {
    let e = computeRectPoints(this.pt1, this.pt2);
    if (this.cornerRadius.length > 0 && (e = getToGenerateRoundedCorners(e, this.cornerRadius)), t.getType() != McGiWorldDrawType_default.kWorldDraw)
      return e.push(e[0]), void t.drawLines(e);
    const i = { transparent: true, depthTest: false, opacity: this.opacity, visible: this.visible };
    if (this.isSolidColorFill) {
      let r;
      e = e.map(({ x: t2, y: e2 }) => new THREE.Vector2(t2, e2)), r = new THREE.ShapeGeometry(new THREE.Shape(e));
      let a = new THREE.MeshBasicMaterial(Object.assign({ color: this.filter ? this.filter._getFilterColor(this.color, this.opacity) : new THREE.Color(this.color) }, i)), s = new THREE.Mesh(r, a);
      t.drawEntity(s);
    } else if (this.fillImageSrc) {
      if (this.material) {
        e = e.map(({ x: t2, y: e2 }) => new THREE.Vector2(t2, e2));
        let r = this.material, a = new THREE.ShapeGeometry(new THREE.Shape(e));
        if (a = repairGeometryFaceVertexUvs(a), this.filter) {
          const t2 = r.map;
          this.fillImageParam && (this.fillImageParam.center && (t2.center = this.fillImageParam.center), this.fillImageParam.offset && (t2.offset = this.fillImageParam.offset), this.fillImageParam.repeat && (t2.repeat = this.fillImageParam.repeat), this.fillImageParam.rotation && (t2.rotation = this.fillImageParam.rotation));
          const e2 = this.filter._getFilterShaderData(t2);
          r = new THREE.ShaderMaterial(Object.assign(Object.assign({}, e2), i));
        }
        r.depthTest = false, r.transparent = true, r.opacity = this.opacity, r.visible = this.visible;
        let s = new THREE.Mesh(a, r);
        t.drawEntity(s);
      } else if (this.fillImageSrc.length > 0 && this.isLoadMaterialFromPath) {
        let t2 = this;
        MxFun_default.loadImageMaterial(this.fillImageSrc, (e2) => {
          this.isLoadMaterialFromPath = false, e2 && (t2.material = e2, t2.setNeedUpdateDisplay(), MxFun_default.updateDisplay());
        });
      }
    } else {
      let r = new THREE.BufferGeometry().setFromPoints(e), a = new THREE.LineBasicMaterial(Object.assign({ color: this.getColor() }, i)), s = new THREE.LineLoop(r, a);
      t.drawEntity(s);
    }
  }
  getGripPoints() {
    let t = [];
    t.push(this.pt1);
    const e = new THREE.Line3(this.pt1, this.pt2);
    let i = new THREE.Vector3();
    return e.getCenter(i), t.push(i), t.push(this.pt2), t;
  }
  moveGripPointsAt(t, e) {
    return 0 == t ? this.pt1.add(e) : 1 == t ? (this.pt1.add(e), this.pt2.add(e)) : 2 == t && this.pt2.add(e), true;
  }
  dwgIn(t) {
    return this.onDwgIn(t), this.pt1.copy(t.pt1), this.pt2.copy(t.pt2), this.isSolidColorFill = t.isSolidColorFill, this.fillImageSrc = t.fillImageSrc, this.fillImageParam = t.fillImageParam, this.cornerRadius = t.cornerRadius, this.filter = t.filter, this.isLoadMaterialFromPath = true, this.material = null, true;
  }
  dwgOut(t) {
    return this.onDwgOut(t), t.pt1 = this.pt1, t.pt2 = this.pt2, t.isSolidColorFill = this.isSolidColorFill, t.fillImageSrc = this.fillImageSrc, t.fillImageParam = this.fillImageParam, t.cornerRadius = this.cornerRadius, t.filter = this.filter, t;
  }
  create() {
    return new MxDbRect();
  }
  transformBy(t) {
    this.pt1.applyMatrix4(t), this.pt2.applyMatrix4(t);
  }
  setRadius(t, e = true) {
    t instanceof Array ? this.cornerRadius = t.map((t2) => e ? MxFun_default.screenCoordLong2Doc(t2) : t2) : this.cornerRadius = t > 0 ? e ? [MxFun_default.screenCoordLong2Doc(t), MxFun_default.screenCoordLong2Doc(t), MxFun_default.screenCoordLong2Doc(t), MxFun_default.screenCoordLong2Doc(t)] : [t, t, t, t] : [];
  }
  getTypeName() {
    return "MxDbRect";
  }
  getFilter() {
    return this.filter;
  }
  setFilter(t) {
    this.filter = t, this.isLoadMaterialFromPath = true, this.material = null;
  }
  setFillImagePath(t) {
    this.fillImageSrc = t, this.isLoadMaterialFromPath = true, this.material = null, this.fillImageSrc && (this.isSolidColorFill = false);
  }
  getFillImagePath() {
    return this.fillImageSrc;
  }
};
MxDbRect.cmd = "Mx_DrawRect", MxDbRect.draw = drawMxDbRect, addRegisterMxDbEntity(MxDbRect);
var MxDbRect_default = MxDbRect;

export {
  MxDbRect_default
};
//# sourceMappingURL=chunk-6QCVDFG6.js.map
