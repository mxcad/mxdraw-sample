import {
  MxDbSVGText
} from "./chunk-BGF4LWHJ.js";
import {
  McGiWorldDrawType_default
} from "./chunk-3EHWTHVA.js";
import {
  MrxDbgUiPrPoint,
  MxDbEntity,
  MxFun_default,
  MxThreeJS_default,
  MxType_default,
  addRegisterMxDbEntity
} from "./chunk-EEK3ULSO.js";

// ../../../../../web/MxCADOnline/MxDrawPlugin/mxdraw-sample/uniapp/node_modules/mxdraw/dist/lib/MxModule/MxDbSVG/draw.js
var __awaiter = function(t, e, n, r) {
  return new (n || (n = Promise))(function(i, o) {
    function a(t2) {
      try {
        s(r.next(t2));
      } catch (t3) {
        o(t3);
      }
    }
    function x(t2) {
      try {
        s(r.throw(t2));
      } catch (t3) {
        o(t3);
      }
    }
    function s(t2) {
      var e2;
      t2.done ? i(t2.value) : (e2 = t2.value, e2 instanceof n ? e2 : new n(function(t3) {
        t3(e2);
      })).then(a, x);
    }
    s((r = r.apply(t, e || [])).next());
  });
};
function drawMxDbSVG() {
  return __awaiter(this, void 0, void 0, function* () {
    const t = new MrxDbgUiPrPoint();
    t.setMessage("\n指定一点:");
    let e = yield t.go();
    if (!e)
      return;
    let n = new MxDbSVG_default(), r = prompt("请输入svg图片网络或本地地址", "https://img.alicdn.com/imgextra/i2/O1CN01FF1t1g1Q3PDWpSm4b_!!6000000001920-55-tps-508-135.svg");
    if (!r)
      return;
    n.setSvgPath(r), n.setSvgPostion(e), n.svgReverse = true, n.svgMargin.x = 0.2, n.setSvgAlignmentRatio(new THREE.Vector2(0.5, -1)), n.setRenderOrder(100);
    n.setSvgSize(new THREE.Vector2(50, 0));
    let i = new MxDbSVGText();
    i.txt = "A1";
    i.txtPos = new THREE.Vector3(0, -30, 0), i.txtHeight = 30, n.addText(i), n.fixedSize = true, n.color = 65297, MxFun_default.addToCurrentSpace(n);
  });
}

// ../../../../../web/MxCADOnline/MxDrawPlugin/mxdraw-sample/uniapp/node_modules/mxdraw/dist/lib/MxModule/MxDbSVG/index.js
var __awaiter2 = function(t, e, i, s) {
  return new (i || (i = Promise))(function(o, r) {
    function n(t2) {
      try {
        a(s.next(t2));
      } catch (t3) {
        r(t3);
      }
    }
    function g(t2) {
      try {
        a(s.throw(t2));
      } catch (t3) {
        r(t3);
      }
    }
    function a(t2) {
      var e2;
      t2.done ? o(t2.value) : (e2 = t2.value, e2 instanceof i ? e2 : new i(function(t3) {
        t3(e2);
      })).then(n, g);
    }
    a((s = s.apply(t, e || [])).next());
  });
};
var MxDbSVG = class extends MxDbEntity {
  constructor() {
    super(...arguments), this.svgPos = new THREE.Vector3(), this.svg = null, this.svgPath = "", this.svgSize = new THREE.Vector2(50, 50), this.svgAlignmentRatio = new THREE.Vector2(0, 0), this.svgRotate = 0, this.svgReverse = false, this.svgMirror = false, this.svgChildColor = [], this.svgMargin = new THREE.Vector2(0, 0), this.isSvgDirtyLocation = false, this.isLoadFromPath = true, this.aryText = [], this.svgBoxSize = null, this.fixedSize = false, this.useSvgColor = false;
  }
  setSvgChildColor(t) {
    if (this.svgChildColor = t, !this.useSvgColor && this.svg) {
      let t2 = new THREE.Color(this.getColor()), e = 0, i = this;
      this.svg.traverse(function(s) {
        s.material && (e < i.svgChildColor.length ? s.material.color = new THREE.Color(i.svgChildColor[e]) : s.material.color = t2, e++);
      }), this.setNeedUpdateDisplay(true);
    }
  }
  getSvgChildColor() {
    return this.svgChildColor;
  }
  calcVewSize(t) {
    let e = this.svgSize.x, i = this.svgSize.y;
    return i <= 0 && (i = this.svgBoxSize ? this.svgBoxSize.y / this.svgBoxSize.x * e : e), this.fixedSize && (e = t.screenCoordLong2Doc(e), i = t.screenCoordLong2Doc(i)), [e, i];
  }
  calcSvgDrawRect(t) {
    if (!t)
      return;
    this.calcSvgPosition(t);
    let [e, i] = this.calcVewSize(t), s = new THREE.Matrix4();
    s.makeScale(this.svgMirror ? -1 : 1, this.svgReverse ? -1 : 1, 1);
    let o = new THREE.Matrix4();
    o.makeRotationZ(this.svgRotate);
    let r = new THREE.Matrix4(), n = new THREE.Vector3(this.svgPos.x - e * this.svgAlignmentRatio.x, this.svgPos.y - i * this.svgAlignmentRatio.y, 0);
    r.makeTranslation(n.x, n.y, n.z), o.multiply(s), o.premultiply(r);
    let g = new THREE.Vector3(0, 0, 0), a = new THREE.Vector3(e, 0, 0), l = new THREE.Vector3(e, i, 0), x = new THREE.Vector3(0, i, 0);
    return g.applyMatrix4(o), a.applyMatrix4(o), l.applyMatrix4(o), x.applyMatrix4(o), { pt1: g, pt2: l, pt3: a, pt4: x, cenpt: l.clone().add(g.clone().sub(l).multiplyScalar(0.5)), sizew: e, sizeh: i };
  }
  worldDraw(t) {
    let e = t.getMxObject(), i = this.calcSvgDrawRect(e), s = i.pt1, o = i.pt2, r = i.pt3, n = i.pt4, g = i.cenpt, a = i.sizew, l = this;
    if (t.getType() != McGiWorldDrawType_default.kSelectDraw && this.aryText.forEach((i2, s2) => {
      if (i2.txt.length > 0) {
        let n2 = new THREE.Vector3(i2.txtPos.x, i2.txtPos.y, 0);
        this.fixedSize && (i2.txtPos.x > 0 ? n2.x = this.svgPos.x + e.screenCoordLong2Doc(i2.txtPos.x) : n2.x = this.svgPos.x - e.screenCoordLong2Doc(i2.txtPos.x), i2.txtPos.y > 0 ? n2.y = this.svgPos.y + e.screenCoordLong2Doc(i2.txtPos.y) : n2.y = this.svgPos.y - e.screenCoordLong2Doc(i2.txtPos.y));
        let x = void 0;
        i2.color && (x = t.getColor(), t.setColor(i2.color));
        let h = i2.txtHeight;
        l.fixedSize && (h = e.screenCoordLong2Doc(i2.txtHeight)), t.setXData({ type: "text", txt: i2.txt, index: s2 });
        let c = t.drawText(i2.txt, h, 0, n2, void 0, (t2) => {
          let e2 = "";
          return e2 = i2.fontStyle.length > 0 ? `${i2.fontStyle} ${t2}px Arial` : `normal ${t2}px Arial`;
        });
        if (t.getType() == McGiWorldDrawType_default.kWorldDraw && (i2._txtObject = c), i2.underline && i2._txtObject) {
          const e2 = new THREE.Box3();
          e2.expandByObject(i2._txtObject);
          let s3 = new THREE.Vector3(e2.min.x, e2.min.y + 0.1 * h, 0), n3 = new THREE.Vector3(e2.max.x, e2.min.y + 0.1 * h, 0);
          var o2 = new THREE.Geometry();
          let g2 = new THREE.LineBasicMaterial({ color: t.getColor(), transparent: true, depthTest: false });
          o2.vertices.push(s3, n3);
          var r2 = new THREE.Line(o2, g2);
          t.drawEntity(r2), t.getType() == McGiWorldDrawType_default.kWorldDraw && (i2._underLine = r2);
        }
        if (i2._txtAspectRatio = -1, x && t.setColor(x), i2.drawConnectingLine) {
          let e2 = g.clone().sub(n2);
          if (e2.length() > h + a) {
            e2.normalize();
            let s3 = g.clone().sub(e2.clone().multiplyScalar(a)), l2 = n2.clone().add(e2.clone().multiplyScalar(h));
            o2 = new THREE.Geometry();
            let x2 = new THREE.LineBasicMaterial({ color: t.getColor(), transparent: true, depthTest: false });
            o2.vertices.push(s3, l2);
            r2 = new THREE.Line(o2, x2);
            t.setXData({ type: "line" }), t.drawEntity(r2), t.getType() == McGiWorldDrawType_default.kWorldDraw && (i2._connectingLine = r2);
          }
        }
      }
    }), 1 == t.getType()) {
      if (this.svg)
        t.setXData({ type: "svg" }), t.drawEntity(this.svg);
      else if (this.svgPath.length > 0 && this.isLoadFromPath) {
        let i2 = this, s2 = t.getMxObject();
        MxThreeJS_default.loadSVG(this.svgPath, void 0, (o2) => {
          if (o2) {
            let r2 = o2;
            if (r2.boxSize)
              i2.svgBoxSize = r2.boxSize.clone();
            else {
              let t2 = new THREE.Box3().setFromObject(o2);
              i2.svgBoxSize || (i2.svgBoxSize = new THREE.Vector3()), i2.svgBoxSize.x = t2.max.x - t2.min.x, i2.svgBoxSize.y = t2.max.y - t2.min.y;
            }
            let [n2, g2] = i2.calcVewSize(e);
            i2.svgBoxSize && (o2.scale.x = n2 / i2.svgBoxSize.x, o2.scale.y = g2 / i2.svgBoxSize.y), o2.scale.z = o2.scale.x, i2.svgReverse && (o2.scale.y *= -1), i2.svgMirror && (o2.scale.x *= -1), o2.rotateZ(i2.svgRotate), i2.isSvgDirtyLocation = true;
            let a2 = new THREE.Color(t.getColor()), l2 = 0;
            o2.traverse(function(t2) {
              t2.material && (t2.material = t2.material.clone(), t2.material.transparent = true, t2.material.depthTest = false, i2.useSvgColor || (l2 < i2.svgChildColor.length ? t2.material.color = new THREE.Color(i2.svgChildColor[l2]) : t2.material.color = a2), l2++);
            }), i2.svg = o2, i2.setNeedUpdateDisplay(), s2.updateDisplay();
          } else
            console.log("mx LoadSVG:" + i2.svgPath + " failed");
          i2.isLoadFromPath = false;
        });
      }
      this.fixedSize || (t.drawSelectLine(s, o), t.drawSelectLine(r, n), t.drawSelectLine(s, r), t.drawSelectLine(r, o), t.drawSelectLine(o, n), t.drawSelectLine(n, s));
    } else
      t.drawLine(s, r), t.drawLine(r, o), t.drawLine(o, n), t.drawLine(n, s);
  }
  setSvgPath(t, e = false) {
    return __awaiter2(this, void 0, void 0, function* () {
      this.svgPath = t, this.svg = null, this.isLoadFromPath = true, this.svgBoxSize = null, e && (yield MxThreeJS_default.loadSVG(t));
    });
  }
  getSvgPath() {
    return this.svgPath;
  }
  setSvgPostion(t) {
    this.svgPos = t.clone(), this.isSvgDirtyLocation = true;
  }
  getSvgPostion() {
    return this.svgPos;
  }
  setSvgSize(t) {
    this.svgSize = t, this.isSvgDirtyLocation = true;
  }
  getSvgSize() {
    return this.svgSize;
  }
  setSvgAlignmentRatio(t) {
    this.svgAlignmentRatio = t, this.isSvgDirtyLocation = true;
  }
  getSvgAlignmentRatio() {
    return this.svgAlignmentRatio;
  }
  getText(t) {
    return t < this.aryText.length ? this.aryText[t] : null;
  }
  addText(t) {
    this.aryText.push(t);
  }
  getGripPoints() {
    let t = [];
    t.push(this.svgPos);
    let e = 0;
    for (; e < this.aryText.length; e++) {
      let i = this.aryText[e];
      if (i.move) {
        let e2 = new THREE.Vector3(i.txtPos.x, i.txtPos.y, 0);
        if (this.fixedSize) {
          let t2 = MxFun_default.getCurrentDraw();
          i.txtPos.x > 0 ? e2.x = this.svgPos.x + t2.screenCoordLong2Doc(i.txtPos.x) : e2.x = this.svgPos.x - t2.screenCoordLong2Doc(i.txtPos.x), i.txtPos.y > 0 ? e2.y = this.svgPos.y + t2.screenCoordLong2Doc(i.txtPos.y) : e2.y = this.svgPos.y - t2.screenCoordLong2Doc(i.txtPos.y);
        }
        t.push(e2);
      }
    }
    return t;
  }
  moveGripPointsAt(t, e) {
    if (0 == t)
      this.svgPos.add(e), this.fixedSize || this.aryText.forEach((t2) => {
        t2.txtPos.add(e);
      });
    else if (t - 1 >= 0 && t - 1 < this.aryText.length) {
      let i = this.aryText[t - 1];
      if (i.move)
        if (this.fixedSize) {
          let t2 = MxFun_default.getCurrentDraw();
          i.txtPos.x += t2.docCoordLong2Screen(e.x), i.txtPos.y += t2.docCoordLong2Screen(e.y);
        } else
          i.txtPos.add(e);
    }
    return this.isSvgDirtyLocation = true, true;
  }
  calcSvgPosition(t) {
    if (!this.svg || !this.isSvgDirtyLocation)
      return;
    this.isSvgDirtyLocation = false;
    let [e, i] = this.calcVewSize(t);
    this.svg.position.x = this.svgPos.x - e * this.svgAlignmentRatio.x - this.svgMargin.x * e, this.svg.position.y = this.svgPos.y - i * this.svgAlignmentRatio.y - this.svgMargin.y * i;
  }
  dwgIn(t) {
    this.onDwgIn(t), this.fixedSize = t.fixedSize, this.fixedSize ? this.svg = null : t.type == MxType_default.MxCloneType.kClone && t.svg && (this.svg = t.svg.clone()), this.svgPos.copy(t.svgPos), this.svgPath = t.svgPath.substr(0), this.svgSize.copy(t.svgSize), this.svgAlignmentRatio.copy(t.svgAlignmentRatio), this.isSvgDirtyLocation = true, this.svg || (this.isLoadFromPath = true), this.svgBoxSize = null;
    let e = t.txts;
    return this.aryText = [], e.forEach((t2) => {
      let e2 = new MxDbSVGText();
      e2.txt = t2.txt, e2.txtHeight = t2.txtHeight, e2.txtPos.copy(t2.txtPos), e2.move = t2.move, e2.drawConnectingLine = t2.drawConnectingLine, this.aryText.push(e2);
    }), this.svgRotate = t.svgRotate, this.useSvgColor = t.useSvgColor, this.svgReverse = t.svgReverse, this.svgMirror = t.svgMirror, this.svgMargin = t.svgMargin, t.svgChildColor ? this.svgChildColor = t.svgChildColor : this.svgChildColor = [], true;
  }
  dwgOut(t) {
    this.onDwgOut(t);
    let e, i = this.getMxObject();
    return t.type == MxType_default.MxCloneType.kClone && (t.svg = this.svg), t.svgPath = this.svgPath, t.svgPos = this.svgPos, t.svgSize = this.svgSize, t.svgAlignmentRatio = this.svgAlignmentRatio, t.txts = [], t.type == MxType_default.MxCloneType.kSaveDwgClone && i && (e = this.calcSvgDrawRect(i)), this.aryText.forEach((e2) => {
      let i2 = { txtPos: e2.txtPos, txt: e2.txt, txtHeight: e2.txtHeight, color: e2.color, _txtAspectRatio: e2._txtAspectRatio, move: e2.move, drawConnectingLine: e2.drawConnectingLine };
      t.type == MxType_default.MxCloneType.kSaveDwgClone && (e2._connectingLine && (i2.connectingLine = e2._connectingLine.geometry.vertice), e2._underLine && (i2._underLine = e2._underLine.geometry.vertice)), t.txts.push(i2);
    }), t.fixedSize = this.fixedSize, t.svgRotate = this.svgRotate, t.useSvgColor = this.useSvgColor, t.svgReverse = this.svgReverse, t.svgMirror = this.svgMirror, t.svgMargin = this.svgMargin, t.svgChildColor = this.svgChildColor, t.type == MxType_default.MxCloneType.kSaveDwgClone && (t.svgRect = e), t;
  }
  create() {
    return new MxDbSVG();
  }
  transformBy(t) {
    this.svgPos.applyMatrix4(t), this.isSvgDirtyLocation = true, this.fixedSize || this.aryText.forEach((e) => {
      e.txtPos.applyMatrix4(t);
    });
  }
  getTypeName() {
    return "MxDbSVG";
  }
  setColor(t) {
    if (super.setColor(t), this.svg) {
      let t2 = new THREE.Color(this.color);
      this.svg.traverse(function(e) {
        e.material && (e.material.color = t2);
      });
    }
    return this;
  }
  setSvg(t) {
    this.svg = t, this.isLoadFromPath = false, this.svgBoxSize = null;
  }
  calcSvgBoxSize(t) {
    if (!this.svgBoxSize)
      if (t.boxSize)
        this.svgBoxSize = t.boxSize.clone();
      else {
        let e = new THREE.Box3().setFromObject(t);
        this.svgBoxSize || (this.svgBoxSize = new THREE.Vector3()), this.svgBoxSize.x = e.max.x - e.min.x, this.svgBoxSize.y = e.max.y - e.min.y;
      }
  }
  reComputeSVG() {
    if (!this.svg)
      return;
    let t = this.getMxObject();
    if (!t)
      return;
    this.calcSvgBoxSize(this.svg);
    let [e, i] = this.calcVewSize(t);
    this.svgBoxSize && (this.svg.scale.x = e / this.svgBoxSize.x, this.svg.scale.y = i / this.svgBoxSize.y), this.svg.scale.z = this.svg.scale.x, this.svgReverse && (this.svg.scale.y *= -1), this.svgMirror && (this.svg.scale.x *= -1), this.isSvgDirtyLocation = true, this.calcSvgPosition(t);
  }
  onViewChange() {
    if (!this.fixedSize)
      return false;
    let t = this.getMxObject();
    if (null == t)
      return false;
    if (this.svg) {
      this.calcSvgBoxSize(this.svg);
      let [e2, i2] = this.calcVewSize(t);
      this.svgBoxSize && (this.svg.scale.x = e2 / this.svgBoxSize.x, this.svg.scale.y = i2 / this.svgBoxSize.y), this.svg.scale.z = this.svg.scale.x, this.svgReverse && (this.svg.scale.y *= -1), this.svgMirror && (this.svg.scale.x *= -1), this.isSvgDirtyLocation = true, this.calcSvgPosition(t);
    }
    let e = this.calcSvgDrawRect(t), i = e.cenpt, s = e.sizew, o = this;
    return this.aryText.forEach((e2) => {
      if (e2._txtObject && t) {
        let n = t.screenCoordLong2Doc(e2.txtHeight);
        if (n > 1e-5) {
          e2._txtAspectRatio <= 0 && (e2._txtAspectRatio = e2._txtObject.scale.x / e2._txtObject.scale.y), e2._txtObject.scale.set(e2._txtAspectRatio * n * 1.5, 1.5 * n, 1), e2.txtPos.x > 0 ? e2._txtObject.position.x = o.svgPos.x + t.screenCoordLong2Doc(e2.txtPos.x) : e2._txtObject.position.x = o.svgPos.x - t.screenCoordLong2Doc(e2.txtPos.x), e2.txtPos.y > 0 ? e2._txtObject.position.y = o.svgPos.y + t.screenCoordLong2Doc(e2.txtPos.y) : e2._txtObject.position.y = o.svgPos.y - t.screenCoordLong2Doc(e2.txtPos.y);
          let g = e2._txtObject.position;
          if (e2._txtObject.updateMatrix(), e2._underLine) {
            const t2 = new THREE.Box3();
            let i2 = e2._txtObject.parent;
            e2._txtObject.parent = null, t2.expandByObject(e2._txtObject), e2._txtObject.parent = i2;
            let s2 = new THREE.Vector3(t2.min.x, t2.min.y + 0.1 * n, 0), o2 = new THREE.Vector3(t2.max.x, t2.min.y + 0.1 * n, 0);
            (r = new THREE.Geometry()).vertices.push(s2, o2), e2._underLine.geometry = r;
          }
          if (e2._connectingLine) {
            let t2 = i.clone().sub(g);
            t2.normalize();
            let o2 = i.clone().sub(t2.clone().multiplyScalar(s)), a = g.clone().add(t2.clone().multiplyScalar(n));
            var r;
            (r = new THREE.Geometry()).vertices.push(o2, a), e2._connectingLine.geometry = r;
          }
        }
      }
    }), true;
  }
};
MxDbSVG.cmd = "Mx_ModelFixedSvg", MxDbSVG.draw = drawMxDbSVG, addRegisterMxDbEntity(MxDbSVG);
var MxDbSVG_default = MxDbSVG;

export {
  MxDbSVG_default
};
//# sourceMappingURL=chunk-YY3AZ7K7.js.map
