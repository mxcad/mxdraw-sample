import {
  McGiWorldDrawType_default
} from "./chunk-3EHWTHVA.js";
import {
  McEdGetPointWorldDrawObject,
  MrxDbgUiPrPoint,
  MxDbEntity,
  MxFun_default,
  addRegisterMxDbEntity,
  require_lodash
} from "./chunk-EEK3ULSO.js";
import {
  __toESM
} from "./chunk-OZI5HTJH.js";

// ../../../../../web/MxCADOnline/MxDrawPlugin/mxdraw-sample/uniapp/node_modules/mxdraw/dist/lib/MxModule/MxDb2LineAngularDimension/index.js
var import_lodash = __toESM(require_lodash());

// ../../../../../web/MxCADOnline/MxDrawPlugin/mxdraw-sample/uniapp/node_modules/mxdraw/dist/lib/MxModule/MxDb2LineAngularDimension/draw.js
function drawMxDb2LineAngularDimension() {
  const n = new MrxDbgUiPrPoint(), t = MxFun_default.getCurrentDraw(), e = new MxDb2LineAngularDimension_default(), r = new McEdGetPointWorldDrawObject();
  return n.setMessage("\n指定第一点:"), n.go((o) => {
    0 === o && (n.setMessage("\n指定第二个角度点:"), e.point1 = n.value(), r.setDraw((n2, t2) => {
      e.point2 = n2, r.drawLine(e.point1, n2);
    }), n.setUserDraw(r), n.go((o2) => {
      n.setMessage("\n指定最后一个点:"), 0 === o2 && (e.point2 = n.value(), r.setDraw((n2, t2) => {
        e.point3 = n2, r.drawCustomEntity(e);
      }), n.go((n2) => {
        0 === n2 && t.addMxEntity(e);
      }));
    }));
  }), e;
}

// ../../../../../web/MxCADOnline/MxDrawPlugin/mxdraw-sample/uniapp/node_modules/mxdraw/dist/lib/MxModule/MxDb2LineAngularDimension/index.js
var propertyDbKeys = ["colors", "point1", "point2", "point3"];
var MxDb2LineAngularDimension = class extends MxDbEntity {
  constructor(t) {
    if (super(), this.point1 = new THREE.Vector3(), this.point2 = new THREE.Vector3(), this.point3 = new THREE.Vector3(), this.colors = [], t) {
      const { points: i, colors: n } = t;
      i && this.setPoints(i), n && this.setColor(n);
    }
  }
  calculateLineAngle(t, i, n) {
    const o = 2 * Math.PI / 360;
    return { startAngle: 180 * Math.atan2(i.y - t.y, i.x - t.x) / Math.PI * o, endAngle: 180 * Math.atan2(n.y - t.y, n.x - t.x) / Math.PI * o };
  }
  setPoints(t) {
    const [i, n, o] = t;
    return i && (this.point1 = i), n && (this.point2 = n), o && (this.point3 = o), this;
  }
  setColor(t) {
    return import_lodash.default.isArray(t) ? this.colors = t : this.color = t, this;
  }
  worldDraw(t) {
    if (t.getType() == McGiWorldDrawType_default.kWorldDraw || t.getType() == McGiWorldDrawType_default.kDynDragDraw) {
      const [i, n, o, e] = this.colors || [], r = this.getColor(), s = t.getMxObject();
      t.setColor(i || r), t.drawLine(this.point1, this.point2), t.setColor(n || r), t.drawLine(this.point2, this.point3);
      const { startAngle: a, endAngle: p } = this.calculateLineAngle(this.point2, this.point1, this.point3), l = this.point2.distanceTo(this.point1), h = this.point2.distanceTo(this.point3), d = Math.min(l, h) / 4;
      let c = THREE.MathUtils.radToDeg(a - p);
      c < 0 && (c += 360);
      let D = s.screenCoordLong2Doc(50);
      const g = new THREE.ArcCurve(this.point2.x, this.point2.y, d, a, p, true), y = new THREE.Geometry().setFromPoints(g.getPoints(50));
      t.setColor(o || r), t.drawGeometryLines(y);
      const w = g.getPoint(0.5);
      let u = new THREE.Vector3(w.x, w.y, 0);
      const M = u.sub(this.point2), m = M.length() + 0.5 * D;
      M.normalize().multiplyScalar(m), u = this.point2.clone().add(M), t.setColor(e || r), t.drawText(c.toFixed(3) + "°", 0.5 * D, 0, u);
    } else
      t.drawLine(this.point1, this.point2), t.drawLine(this.point3, this.point2);
  }
  getGripPoints() {
    return [this.point1, this.point2, this.point3];
  }
  moveGripPointsAt(t, i) {
    return 0 === t ? this.point1.add(i) : 1 === t ? this.point2.add(i) : 2 === t && this.point3.add(i), true;
  }
  dwgIn(t) {
    return this.onDwgIn(t), this.dwgInHelp(t, propertyDbKeys), true;
  }
  dwgOut(t) {
    return this.onDwgOut(t), this.dwgOutHelp(t, propertyDbKeys), t;
  }
  create() {
    return new MxDb2LineAngularDimension();
  }
  transformBy(t) {
    this.point1.applyMatrix4(t), this.point2.applyMatrix4(t);
  }
  getTypeName() {
    return "MxDb2LineAngularDimension";
  }
};
MxDb2LineAngularDimension.cmd = "Mx_AngleSurveying", MxDb2LineAngularDimension.draw = drawMxDb2LineAngularDimension, addRegisterMxDbEntity(MxDb2LineAngularDimension);
var MxDb2LineAngularDimension_default = MxDb2LineAngularDimension;

export {
  MxDb2LineAngularDimension_default
};
//# sourceMappingURL=chunk-YMVYHKP2.js.map
