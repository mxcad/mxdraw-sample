import {
  McGiWorldDrawType_default
} from "./chunk-3EHWTHVA.js";
import {
  McEdGetPointWorldDrawObject,
  MrxDbgUiPrPoint,
  MxDbEntity,
  MxFun_default,
  MxThreeJS_default,
  MxType_default,
  addRegisterMxDbEntity,
  require_lodash
} from "./chunk-EEK3ULSO.js";
import {
  __toESM
} from "./chunk-OZI5HTJH.js";

// ../../../../../web/MxCADOnline/MxDrawPlugin/mxdraw-sample/uniapp/node_modules/mxdraw/dist/lib/MxModule/MxDbAlignedDimension/index.js
var import_lodash = __toESM(require_lodash());

// ../../../../../web/MxCADOnline/MxDrawPlugin/mxdraw-sample/uniapp/node_modules/mxdraw/dist/lib/MxModule/MxDbAlignedDimension/draw.js
function drawMxDbAlignedDimension() {
  let t = new MxDbAlignedDimension_default();
  const e = new MrxDbgUiPrPoint();
  return e.setMessage("\n指定第一点:"), e.go((n) => {
    if (0 != n)
      return;
    const o = e.value();
    t.setPoint1(o), t.setColor(65314);
    const r = new McEdGetPointWorldDrawObject();
    r.setDraw((e2) => {
      t.setPoint2(e2), r.drawCustomEntity(t);
    }), e.setBasePt(o), e.setUseBasePt(true), e.setUserDraw(r), e.setMessage("\n指定第二点:"), e.setInputToucheType(MxType_default.InputToucheType.kGetEnd), e.go((n2) => {
      if (0 != n2)
        return void console.log(n2);
      const o2 = e.value();
      t.setPoint2(o2), MxFun_default.getCurrentDraw().addMxEntity(t);
    });
  }), t;
}

// ../../../../../web/MxCADOnline/MxDrawPlugin/mxdraw-sample/uniapp/node_modules/mxdraw/dist/lib/MxModule/MxDbAlignedDimension/index.js
var propertyDbKeys = ["point1", "point2", "fontColor"];
var MxDbAlignedDimension = class extends MxDbEntity {
  constructor(t) {
    if (super(), this.point1 = new THREE.Vector3(), this.point2 = new THREE.Vector3(), t) {
      const { points: e, fontColor: n } = t;
      e && this.setPoints(e), n && (this.fontColor = n);
    }
  }
  setPoints(t) {
    const [e, n] = t;
    e && (this.point1 = e), n && (this.point2 = n);
  }
  getTypeName() {
    return "MxDbAlignedDimension";
  }
  getDirection(t, e, n) {
    const i = new THREE.Vector3(t.x, t.y, 0), o = new THREE.Vector3(1, 0, 0), r = t.angleTo(o);
    let a = -1;
    (r < 7 * Math.PI / 18 || r > 10 * Math.PI / 18) && e.x > n.x && (a = 1);
    const s = new THREE.Matrix4();
    return s.makeRotationZ(Math.PI / 2 * a), i.applyMatrix4(s), i;
  }
  getDimText() {
    return new THREE.Vector3(this.point1.x - this.point2.x, this.point1.y - this.point2.y, 0).length().toFixed(3);
  }
  worldDraw(t) {
    if (t.getType() == McGiWorldDrawType_default.kWorldDraw || t.getType() == McGiWorldDrawType_default.kDynDragDraw) {
      const e = this.point1, n = this.point2;
      let i, o, r, a, s, x, y;
      const c = new THREE.Vector3(e.x - n.x, e.y - n.y, 0), p = this.getDirection(c, e, n), E = new THREE.Matrix4();
      E.makeScale(0.01, 0.01, 0.01);
      const l = new THREE.Vector3(p.x, p.y, 0);
      l.applyMatrix4(E);
      const h = new THREE.Vector3(e.x + l.x, e.y + l.y, 0), w = new THREE.Vector3(n.x + l.x, n.y + l.y, 0), M = this.getColor();
      x = MxThreeJS_default.createPoint(e, M), y = MxThreeJS_default.createPoint(n, M);
      {
        E.identity(), E.makeScale(0.2, 0.2, 0), new THREE.Vector3(p.x, p.y, 0).applyMatrix4(E), E.identity(), E.makeScale(0.02, 0.02, 0);
        const r2 = new THREE.Vector3(p.x, p.y, 0);
        r2.applyMatrix4(E), t.drawLine(h, w), i = MxThreeJS_default.createLine(new THREE.Vector3(h.x + 2 * r2.x, h.y + 2 * r2.y, 0), new THREE.Vector3(e.x + r2.x, e.y + r2.y, 0), M), o = MxThreeJS_default.createLine(new THREE.Vector3(w.x + 2 * r2.x, w.y + 2 * r2.y, 0), new THREE.Vector3(n.x + r2.x, n.y + r2.y, 0), M);
      }
      {
        const i2 = new THREE.Vector3(1, 0, 0);
        let o2 = c.angleTo(i2);
        const a2 = new THREE.Vector3(p.x, p.y, 0);
        a2.normalize();
        const s2 = e.distanceTo(n);
        c.y < 0 ? o2 = o2 < Math.PI / 2 ? 2 * Math.PI - o2 : Math.PI - o2 : o2 > Math.PI / 2 && (o2 = Math.PI + o2);
        const x2 = t.getMxObject();
        x2 && (o2 -= x2.getViewAngle());
        const y2 = this.getDimText();
        null != (r = MxThreeJS_default.creatTextSprite(y2, new THREE.Vector3(w.x + c.x / 2 + a2.x * s2 / 30, w.y + c.y / 2 + a2.y * s2 / 30, 0), 0.07 * s2, o2, this.fontColor || M)) && t.drawEntity(r);
      }
      {
        E.identity(), E.makeScale(0.08, 0.08, 0.08);
        const t2 = new THREE.Matrix4();
        t2.makeRotationZ(17 * Math.PI / 18);
        let e2 = new THREE.Vector3(c.x, c.y, 0);
        e2.applyMatrix4(E), e2.applyMatrix4(t2), t2.identity(), t2.makeRotationZ(17 * -Math.PI / 18);
        let n2 = new THREE.Vector3(c.x, c.y, 0);
        n2.applyMatrix4(E), n2.applyMatrix4(t2);
        const i2 = new Array();
        i2.push(new THREE.Vector3(h.x, h.y, 0), new THREE.Vector3(h.x + e2.x, h.y + e2.y, 0), new THREE.Vector3(h.x + n2.x, h.y + n2.y, 0)), a = MxThreeJS_default.createTriangle(i2, M), t2.identity(), t2.makeRotationZ(Math.PI / 18), (e2 = new THREE.Vector3(c.x, c.y, 0)).applyMatrix4(E), e2.applyMatrix4(t2), t2.identity(), t2.makeRotationZ(-Math.PI / 18), (n2 = new THREE.Vector3(c.x, c.y, 0)).applyMatrix4(E), n2.applyMatrix4(t2);
        const o2 = new Array();
        o2.push(new THREE.Vector3(w.x, w.y, 0), new THREE.Vector3(w.x + e2.x, w.y + e2.y, 0), new THREE.Vector3(w.x + n2.x, w.y + n2.y, 0)), s = MxThreeJS_default.createTriangle(o2, M);
      }
      t.drawEntity(i), t.drawEntity(o), a && t.drawEntity(a), s && t.drawEntity(s), t.drawEntity(x), t.drawEntity(y);
    } else
      t.drawLine(this.point1, this.point2);
  }
  setPoint1(t) {
    this.point1 = t;
  }
  setPoint2(t) {
    this.point2 = t;
  }
  setColor(t) {
    return import_lodash.default.isArray(t) ? ([this.color = this.color, this.fontColor = this.fontColor || this.color] = t, console.log("this.fontColor : ", this.fontColor)) : this.color = t, this;
  }
  getGripPoints() {
    let t = [];
    return t.push(this.point1), t.push(this.point2), t;
  }
  moveGripPointsAt(t, e) {
    return 0 == t ? this.point1.add(e) : (t = 1) && this.point2.add(e), true;
  }
  dwgIn(t) {
    return this.onDwgIn(t), this.dwgInHelp(t, propertyDbKeys), true;
  }
  dwgOut(t) {
    return this.onDwgOut(t), this.dwgOutHelp(t, propertyDbKeys), t;
  }
  create() {
    return new MxDbAlignedDimension();
  }
};
MxDbAlignedDimension.cmd = "Mx_DimensionMeasurement", MxDbAlignedDimension.draw = drawMxDbAlignedDimension, addRegisterMxDbEntity(MxDbAlignedDimension);
var MxDbAlignedDimension_default = MxDbAlignedDimension;

export {
  MxDbAlignedDimension_default
};
//# sourceMappingURL=chunk-2TFEK7HD.js.map
