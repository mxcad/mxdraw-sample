import {
  McGeTool_default
} from "./chunk-LW4ZKAF7.js";
import {
  MxDbEntity,
  MxFun_default,
  MxType_default,
  getToGenerateRoundedCorners,
  repairGeometryFaceVertexUvs
} from "./chunk-EEK3ULSO.js";

// ../../../../../web/MxCADOnline/MxDrawPlugin/mxdraw-sample/uniapp/node_modules/mxdraw/dist/lib/MxModule/MxFilters/index.js
var MxFilters = class {
  constructor() {
    this.uniformObj = {}, this.filtersStr = "", this.filtersTypes = "", this.VSHADER_SOURCE = "\n  varying vec2 v_Uv; \n  void main () {\n      v_Uv = uv;\n      gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n  }\n  ", this.FSHADER_SOURCE = `
  varying vec2 v_Uv;
  uniform sampler2D e_Texture;
  uniform mat4 colorMatrix;
  ${this.filtersStr}
  void main () {
    vec4 color = texture2D( e_Texture, v_Uv );
    color = color * colorMatrix;
    ${this.filtersTypes}
    gl_FragColor = color;
  }`, this._matrix = new THREE.Matrix4();
  }
  channel({ r: t = 1, g: r = 1, b: i = 1 }) {
    return this._matrix = new THREE.Matrix4().set(t, 0, 0, 0, 0, r, 0, 0, 0, 0, i, 0, 0, 0, 0, 1).multiply(this._matrix), this;
  }
  brightness(t) {
    return this._matrix = new THREE.Matrix4().set(t, 0, 0, 0, 0, t, 0, 0, 0, 0, t, 0, 0, 0, 0, 1).multiply(this._matrix), this;
  }
  saturate(t) {
    const r = 0.2126 * (1 - t), i = 0.7152 * (1 - t), e = 0.0722 * (1 - t);
    return this._matrix = new THREE.Matrix4().set(r + t, i, e, 0, r, i + t, e, 0, r, i, e + t, 0, 0, 0, 0, 1).multiply(this._matrix), this;
  }
  contrast(t) {
    const r = 0.5 * (1 - t);
    return this._matrix = new THREE.Matrix4().set(t, 0, 0, 0, 0, t, 0, 0, 0, 0, t, 0, r, r, r, 1).multiply(this._matrix), this;
  }
  opacity(t) {
    return this._matrix = new THREE.Matrix4().set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, t).multiply(this._matrix), this;
  }
  invert(t) {
    const r = 1 - 2 * t;
    return this._matrix = new THREE.Matrix4().set(r, 0, 0, 0, 0, r, 0, 0, 0, 0, r, 0, t, t, t, 1).multiply(this._matrix), this;
  }
  grayscale(t = 1) {
    const r = 0.2126 * t, i = 0.7152 * t, e = 0.0722 * t;
    return this._matrix = new THREE.Matrix4().set(r + 1 - t, i, e, 0, r, i + 1 - t, e, 0, r, i, e + 1 - t, 0, 0, 0, 0, 1).multiply(this._matrix), this;
  }
  sepia(t = 1) {
    return this._matrix = new THREE.Matrix4().set(1 - 0.607 * t, 0.769 * t, 0.189 * t, 0, 0.349 * t, 1 - 0.314 * t, 0.168 * t, 0, 0.272 * t, 0.534 * t, 1 - 0.869 * t, 0, 0, 0, 0, 1).multiply(this._matrix), this;
  }
  hueRotate(t) {
    const r = t / 180 * Math.PI, i = Math.cos(r), e = Math.sin(r);
    return this._matrix = new THREE.Matrix4().set(0.2126 + 0.7874 * i + -0.2126 * e, 0.7152 + -0.7152 * i + -0.7152 * e, 0.0722 + -0.0722 * i + 0.9278 * e, 0, 0.2126 + -0.2126 * i + 0.143 * e, 0.7152 + i * (1 - 0.7152) + 0.14 * e, 0.0722 + -0.0722 * i + -0.283 * e, 0, 0.2126 + -0.2126 * i + -0.7874 * e, 0.7152 + -0.7152 * i + 0.7152 * e, 0.0722 + 0.9278 * i + 0.0722 * e, 0, 0, 0, 0, 1).multiply(this._matrix), this;
  }
  convolution(t, r = 1 / 9, i = 521) {
    return this.uniformObj = Object.assign(Object.assign({}, this.uniformObj), { cKernel: { value: t.toArray() }, stStep: { value: r }, scaleFactor: { value: i } }), this.filtersTypes.indexOf("convolutionTextureColor") < 0 && (this.filtersStr += "\n        uniform float cKernel[9];\n        uniform float stStep;\n        uniform float scaleFactor;\n        vec4 convolutionTextureColor(vec4 color) {\n            vec2 offsets[9];\n            offsets[0] = vec2(-1.0,-1.0);\n            offsets[1] =  vec2(0.0,-1.0);\n            offsets[2] = vec2(1.0,-1.0);\n            offsets[3] =  vec2(-1.0,0.0);\n            offsets[4] = vec2(0.0,0.0);\n            offsets[5] = vec2(1.0,0.0);\n            offsets[6] =  vec2(-1.0,1.0);\n            offsets[7] = vec2(0.0,1.0);\n            offsets[8] = vec2(1.0,1.0);\n        \n            vec4 sum = color;\n            for(int i = 0; i < 9; i++) {\n                sum = sum + cKernel[i] * scaleFactor * texture2D(e_Texture, v_Uv + offsets[i] / stStep);\n            };\n            return sum;\n        }", this.filtersTypes += "color = convolutionTextureColor(color);\n"), this;
  }
  reset() {
    return this.uniformObj = {}, this.filtersStr = "", this.filtersTypes = "", this._matrix = new THREE.Matrix4(), this;
  }
  _getFilterShaderData(t) {
    return { uniforms: Object.assign({ e_Texture: { value: t }, colorMatrix: { value: this._matrix } }, this.uniformObj), vertexShader: this.VSHADER_SOURCE, fragmentShader: this.FSHADER_SOURCE };
  }
  _getFilterColor(t = "#000000", r = 1) {
    t = new THREE.Color(t);
    let { r: i, g: e, b: s } = t;
    const n = this._matrix.toArray(), o = (n[12], n[13], n[14], n[15], n[0] * i + n[1] * i + n[2] * i + n[3] * r), a = n[4] * e + n[5] * e + n[6] * e + n[7] * r, l = n[8] * s + n[9] * s + n[10] * s + n[11] * r;
    return t.setRGB(o, a, l), t;
  }
  toJSON() {
    return JSON.stringify({ matrix: this._matrix.toArray(), uniformObj: this.uniformObj, filtersStr: this.filtersStr, filtersTypes: this.filtersTypes });
  }
  static fromJSON(t) {
    const { matrix: r, uniformObj: i, filtersStr: e, filtersTypes: s } = JSON.parse(t), n = new MxFilters();
    return n._matrix = new THREE.Matrix4().fromArray(r), n.uniformObj = i, n.filtersStr = e, n.filtersTypes = s, n;
  }
};

// ../../../../../web/MxCADOnline/MxDrawPlugin/mxdraw-sample/uniapp/node_modules/mxdraw/dist/lib/MxModule/MxDbShape/index.js
var MxDbShape = class extends MxDbEntity {
  constructor() {
    super(...arguments), this.isLoadMaterialFromPath = true, this.strokeLineWidth = 2, this.isStrokeDashLine = false, this.isFill = false, this.curveSegments = 50, this.closed = true, this.cornerRadius = [], this._propertyDbKeys = ["isFill", "stroke", "strokeLineWidth", "isStrokeDashLine", "closed", "cornerRadius", "fillImageSrc", "fillImageParam"];
  }
  setStroke(t) {
    return this.stroke = t, this;
  }
  setStrokeLineWidth(t) {
    return this.strokeLineWidth = t, this;
  }
  setIsStrokeDashLine(t) {
    return this.isStrokeDashLine = t, this;
  }
  setIsFill(t) {
    return this.isFill = t, this;
  }
  get fillImageSrc() {
    return this._fillImageSrc;
  }
  set fillImageSrc(t) {
    this._fillImageSrc = t, this.isLoadMaterialFromPath = true, this.material = null;
  }
  setFillImageSrc(t) {
    return this.fillImageSrc = t, this;
  }
  setCurveSegments(t) {
    return this.curveSegments = t, this;
  }
  setClosed(t) {
    return this.closed = t, this;
  }
  setCornerRadius(t, e = true) {
    t instanceof Array ? this.cornerRadius = t.map((t2) => e ? MxFun_default.screenCoordLong2Doc(t2) : t2) : this.cornerRadius = e ? MxFun_default.screenCoordLong2Doc(t) : t;
  }
  getTypeName() {
    return "MxDbShape";
  }
  getShapePoints(t) {
    const { curveSegments: e } = this;
    return this.points = t.getPoints(e).map((t2) => t2 instanceof THREE.Vector2 ? new THREE.Vector3(t2.x, t2.y, 0) : t2), this.points;
  }
  createPaths(t) {
    return this._paths = new THREE.CurvePath(), Array.isArray(t) ? t.forEach((t2) => this._paths.add(t2)) : this._paths.add(t), this._paths;
  }
  _draw(t, e) {
    let { isFill: i, closed: s } = this;
    const r = t.getColor();
    t.setColor(this.filter ? this.filter._getFilterColor(this.color, this.opacity) : this.color);
    const o = this.getCornerRadiusPoints(s || i ? this.getClosedPoints(e) : e);
    i ? !this.fillImageSrc && t.drawSolid(o) : t.drawLines(o), this._fillImg(t, o), t.setColor(r);
  }
  getCornerRadiusPoints(t) {
    const { cornerRadius: e } = this;
    if (!e)
      return t;
    const i = "number" == typeof e ? t.map(() => e) : e;
    return i.length > 0 ? getToGenerateRoundedCorners(t, i) : t;
  }
  _drawStoreLine(t, e, i) {
    const { isFill: s, stroke: r, strokeLineWidth: o } = this, a = t.getLineWidth(), n = t.getColor(), l = t.isDashLineDisplay();
    r && s && (t.setDashLineDisplay(this.isStrokeDashLine), t.setColor(r), t.setLineWidth(o), i ? i(t) : t.drawLines(this.getCornerRadiusPoints(this.getClosedPoints(e))), t.setColor(n), t.setLineWidth(a), t.setDashLineDisplay(l));
  }
  getClosedPoints(t) {
    return [...t, t[0]];
  }
  getTotalLength() {
    return this._paths ? this._paths.getLength() + (this.closedLine ? this.closedLine.getLength() : 0) : 0;
  }
  getArea() {
    return this.points ? McGeTool_default.calcArea(this.closed ? this.getClosedPoints(this.points) : this.points) : 0;
  }
  worldDraw(t) {
    const e = this.createPaths(new THREE.Curve()), i = this.getShapePoints(e);
    this._draw(t, i), this._drawStoreLine(t, i);
  }
  _fillImg(t, e) {
    const i = { transparent: true, depthTest: false, opacity: this.opacity, visible: this.visible };
    if (!this.isFill || !this.fillImageSrc)
      return;
    if (!this.material) {
      let t2 = this;
      return void MxFun_default.loadImageMaterial(this.fillImageSrc, (e2) => {
        t2.isLoadMaterialFromPath = false, e2 && (t2.material = e2, t2.setNeedUpdateDisplay(), MxFun_default.updateDisplay());
      });
    }
    const s = e.map(({ x: t2, y: e2 }) => new THREE.Vector2(t2, e2));
    let r = this.material, o = new THREE.ShapeGeometry(new THREE.Shape(s));
    if (o = repairGeometryFaceVertexUvs(o), this.filter) {
      const t2 = r.map, e2 = this.filter._getFilterShaderData(t2);
      r = new THREE.ShaderMaterial(Object.assign(Object.assign({}, e2), i));
    }
    if (r.depthTest = false, r.transparent = true, r.opacity = this.opacity, r.visible = this.visible, this.fillImageParam) {
      const t2 = this.fillImageParam;
      for (let e2 in this.fillImageParam) {
        this.material.map[e2] = t2[e2];
      }
    }
    let a = new THREE.Mesh(o, r);
    t.drawEntity(a);
  }
  getGripPoints() {
    return [];
  }
  moveGripPointsAt(t, e) {
    return true;
  }
  dwgIn(t) {
    return this.onDwgIn(t), this.dwgInHelp(t, this._propertyDbKeys), this.isLoadMaterialFromPath = true, this.material = null, t.type === MxType_default.MxCloneType.kMxFileClone ? t.filter && (this.filter = MxFilters.fromJSON(t.filter)) : t.filter && (this.filter = t.filter), true;
  }
  dwgOut(t) {
    var e;
    return this.onDwgOut(t), this.dwgOutHelp(t, this._propertyDbKeys), t.type === MxType_default.MxCloneType.kMxFileClone ? this.filter && (t.filter = null === (e = this.filter) || void 0 === e ? void 0 : e.toJSON()) : t.filter = this.filter, t;
  }
};

export {
  MxFilters,
  MxDbShape
};
//# sourceMappingURL=chunk-56B5D36D.js.map
