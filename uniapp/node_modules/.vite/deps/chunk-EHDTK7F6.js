import {
  McGeTool_default
} from "./chunk-LW4ZKAF7.js";
import {
  MxDbHatch_default
} from "./chunk-BNMOQKOL.js";
import {
  McGiWorldDrawType_default
} from "./chunk-3EHWTHVA.js";
import {
  McEdGetPointWorldDrawObject,
  MrxDbgUiPrPoint,
  MxDbEntity,
  MxFun_default,
  MxThreeJS_default,
  addRegisterMxDbEntity
} from "./chunk-EEK3ULSO.js";

// ../../../../../web/MxCADOnline/MxDrawPlugin/mxdraw-sample/uniapp/node_modules/mxdraw/dist/lib/MxModule/MxDbArea/draw.js
function drawMxDbArea() {
  const t = new MrxDbgUiPrPoint();
  t.setMessage("\n指定第一点:"), t.go((r) => {
    if (0 != r)
      return;
    const e = t.value();
    let o = new MxDbArea_default();
    o.addPoint(e);
    const n = new McEdGetPointWorldDrawObject();
    n.setDraw((t2, r2) => {
      let e2 = o.clone();
      e2.addPoint(t2), n.drawCustomEntity(e2);
    }), t.setUserDraw(n), t.setMessage("\n指定下一点:"), t.goWhile((r2) => {
      if (0 == r2) {
        const r3 = t.value();
        o.addPoint(r3);
      }
    }, (t2) => {
      o.isFill = true, o.fillOpacity = 0.7, o.fillColor = 6697540, MxFun_default.getCurrentDraw().addMxEntity(o);
    });
  });
}

// ../../../../../web/MxCADOnline/MxDrawPlugin/mxdraw-sample/uniapp/node_modules/mxdraw/dist/lib/MxModule/MxDbArea/index.js
var MxDbArea = class extends MxDbEntity {
  constructor() {
    super(...arguments), this.points = [], this.isFill = false, this.fillColor = 6697540, this.fillOpacity = 0.7;
  }
  getTypeName() {
    return "MxDbArea";
  }
  create() {
    return new MxDbArea();
  }
  getDimText() {
    return McGeTool_default.calcArea(this.points).toFixed(2);
  }
  worldDraw(t) {
    if (this.points.length < 3)
      return void (2 == this.points.length && t.drawLine(this.points[0], this.points[1]));
    let i = this.points[0], r = i.clone(), e = i.clone(), o = this.points.length;
    for (let s2 = 1; s2 < o; s2++) {
      let o2 = this.points[s2];
      r.x > o2.x && (r.x = o2.x), r.y > o2.y && (r.y = o2.y), e.x < o2.x && (e.x = o2.x), e.y < o2.y && (e.y = o2.y), t.drawLine(i, o2), i = o2;
    }
    t.drawLine(i, this.points[0]);
    let s = new THREE.Vector3(r.x + 0.5 * (e.x - r.x), r.y + 0.5 * (e.y - r.y));
    const n = t.getColor();
    let l = MxFun_default.screenCoordLong2Doc(20), p = MxThreeJS_default.creatTextSprite(this.getDimText(), s, l, 0, n);
    if (null != p && t.drawEntity(p), t.getType() == McGiWorldDrawType_default.kWorldDraw && this.isFill) {
      t.setColor(this.fillColor), t.setOpacity(this.fillOpacity), t.setRenderOrder(t.getRenderOrder() - 1);
      const i2 = new MxDbHatch_default();
      i2.points = this.points, i2.worldDraw(t);
    }
  }
  getGripPoints() {
    return this.points;
  }
  moveGripPointsAt(t, i) {
    return !(t >= this.points.length) && (this.points[t].add(i), true);
  }
  dwgIn(t) {
    this.onDwgIn(t);
    let i = t.points;
    return this.points = [], i.forEach((t2) => {
      this.points.push(new THREE.Vector3(t2.x, t2.y, t2.z));
    }), this.dwgInHelp(t, ["isFill", "fillColor", "fillOpacity"]), true;
  }
  dwgOut(t) {
    return this.onDwgOut(t), t.points = this.points, this.dwgOutHelp(t, ["isFill", "fillColor", "fillOpacity"]), t;
  }
  addPoint(t) {
    this.points.push(t.clone());
  }
  getPoints() {
    return this.points;
  }
  clearPoint() {
    this.points = [];
  }
};
MxDbArea.cmd = "Mx_Area", MxDbArea.draw = drawMxDbArea, addRegisterMxDbEntity(MxDbArea);
var MxDbArea_default = MxDbArea;

export {
  MxDbArea_default
};
//# sourceMappingURL=chunk-EHDTK7F6.js.map
