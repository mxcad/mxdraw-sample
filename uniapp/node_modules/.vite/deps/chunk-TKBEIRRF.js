import {
  MrxDbgUiPrBaseReturn_default
} from "./chunk-I5AWBXB6.js";
import {
  MxDbEllipseShape
} from "./chunk-FSS5QSU3.js";
import {
  McEdGetPointWorldDrawObject,
  MrxDbgUiPrPoint,
  MxFun_default,
  addRegisterMxDbEntity,
  calculateArcAngle,
  calculateArcOrigin,
  calculateRadiusArc,
  createThreePointArc,
  judgementArcRenderDirection
} from "./chunk-EEK3ULSO.js";

// ../../../../../web/MxCADOnline/MxDrawPlugin/mxdraw-sample/uniapp/node_modules/mxdraw/dist/lib/MxModule/MxDbCircleShape/index.js
var MxDbCircleShape = class extends MxDbEllipseShape {
  getTypeName() {
    return "MxDbCircleShape";
  }
  get radius() {
    return this.xRadius;
  }
  set radius(s) {
    this.xRadius = s, this.yRadius = s;
  }
  setRadius(s) {
    return this.radius = s, this;
  }
  setXRadius(s) {
    return this.setRadius(s), this;
  }
  setYRadius(s) {
    return this.setRadius(s), this;
  }
};

// ../../../../../web/MxCADOnline/MxDrawPlugin/mxdraw-sample/uniapp/node_modules/mxdraw/dist/lib/MxModule/Mx3PointArc/draw.js
function drawMx3PointArc() {
  const r = new MrxDbgUiPrPoint(), t = new McEdGetPointWorldDrawObject(), e = new Mx3PointArc_default();
  e.closed = false, e.setColor("#ff0000").setLineWidth(10), r.setUserDraw(t), r.setMessage("\n确定圆弧开始点:"), r.go((o) => {
    o === MrxDbgUiPrBaseReturn_default.kOk && (e.point1 = r.value(), t.setDraw((r2) => {
      t.drawLine(e.point1, r2);
    })), r.setMessage("\n确定圆弧结束点:"), r.go((o2) => {
      o2 === MrxDbgUiPrBaseReturn_default.kOk && (e.point2 = r.value(), t.setDraw((r2) => {
        e.point3 = r2, t.drawCustomEntity(e);
      })), r.setMessage("\n确定圆弧上任意一点:"), r.go((r2) => {
        if (r2 === MrxDbgUiPrBaseReturn_default.kOk) {
          MxFun_default.getCurrentDraw().addMxEntity(e);
          const { radius: r3, angle: t2, arcLength: o3 } = createThreePointArc(e.point1, e.point2, e.point3, true);
          console.log("半径:", r3), console.log("圆弧圆心角度:", t2), console.log("圆弧弧长:", o3);
        }
      });
    });
  });
}

// ../../../../../web/MxCADOnline/MxDrawPlugin/mxdraw-sample/uniapp/node_modules/mxdraw/dist/lib/MxModule/Mx3PointArc/index.js
var Mx3PointArc = class extends MxDbCircleShape {
  constructor() {
    super(), this.point1 = new THREE.Vector3(), this.point2 = new THREE.Vector3(), this.point3 = new THREE.Vector3(), this.autoClockwise = true, this._propertyDbKeys = [...this._propertyDbKeys, "point1", "point2", "point3", "autoClockwise"];
  }
  getTypeName() {
    return "Mx3PointArc";
  }
  create() {
    return new Mx3PointArc();
  }
  worldDraw(t) {
    let { point1: i, point2: e, point3: r } = this;
    this.upDateCenter(i, e, r), this.upDateRadius(i);
    const [n, o, s] = this.compute3PointAngle();
    this.upDataClockwise(n, o, s), this.startAngle = THREE.MathUtils.degToRad(n), this.endAngle = THREE.MathUtils.degToRad(o), this.drawEllipseShape(t);
  }
  getGripPoints() {
    return [this.point1, this.point2, this.point3, this.center];
  }
  compute3PointAngle() {
    const { point1: t, point2: i, point3: e } = this, r = calculateArcAngle(t, this.center, this.radius), n = calculateArcAngle(i, this.center, this.radius), o = calculateArcAngle(e, this.center, this.radius);
    return [r.angle, n.angle, o.angle];
  }
  upDateCenter(t, i, e) {
    return this.center = calculateArcOrigin(t, i, e), this.center;
  }
  upDateRadius(t) {
    return this.radius = calculateRadiusArc(t, this.center), this.radius;
  }
  upDataClockwise(t, i, e) {
    const { autoClockwise: r } = this;
    r && (this.clockwise = judgementArcRenderDirection(i, t, e));
  }
  moveGripPointsAt(t, i) {
    return 0 === t ? this.point1.add(i) : 1 === t ? this.point2.add(i) : 2 === t ? this.point3.add(i) : 3 === t && (this.point1.add(i), this.point2.add(i), this.point3.add(i)), this.upDateCenter(this.point1, this.point2, this.point3), true;
  }
};
Mx3PointArc.cmd = "Mx_3PointArc", Mx3PointArc.draw = drawMx3PointArc, addRegisterMxDbEntity(Mx3PointArc);
var Mx3PointArc_default = Mx3PointArc;

export {
  MxDbCircleShape,
  Mx3PointArc_default
};
//# sourceMappingURL=chunk-TKBEIRRF.js.map
